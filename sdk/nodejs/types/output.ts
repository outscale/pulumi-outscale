// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClientGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface DhcpOptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetAccessKeyFilter {
    name: string;
    values: string[];
}

export interface GetAccessKeysAccessKey {
    /**
     * The ID of the access key.
     */
    accessKeyId: string;
    /**
     * The date and time (UTC) of creation of the access key.
     */
    creationDate: string;
    /**
     * The date (UTC) at which the access key expires.
     */
    expirationDate: string;
    /**
     * The date and time (UTC) of the last modification of the access key.
     */
    lastModificationDate: string;
    /**
     * The state of the access key (`ACTIVE` if the key is valid for API calls, or `INACTIVE` if not).
     */
    state: string;
}

export interface GetAccessKeysFilter {
    name: string;
    values: string[];
}

export interface GetAccountsAccount {
    /**
     * The ID of the account.
     */
    accountId: string;
    /**
     * One or more additional email addresses for the account. These addresses are used for notifications only.
     */
    additionalEmails: string[];
    /**
     * The city of the account owner.
     */
    city: string;
    /**
     * The name of the company for the account.
     */
    companyName: string;
    /**
     * The country of the account owner.
     */
    country: string;
    /**
     * The ID of the customer.
     */
    customerId: string;
    /**
     * The main email address for the account. This address is used for your credentials and for notifications.
     */
    email: string;
    /**
     * The first name of the account owner.
     */
    firstName: string;
    /**
     * The job title of the account owner.
     */
    jobTitle: string;
    /**
     * The last name of the account owner.
     */
    lastName: string;
    /**
     * The mobile phone number of the account owner.
     */
    mobileNumber: string;
    /**
     * The landline phone number of the account owner.
     */
    phoneNumber: string;
    /**
     * The state/province of the account.
     */
    stateProvince: string;
    /**
     * The value added tax (VAT) number for the account.
     */
    vatNumber: string;
    /**
     * The ZIP code of the city.
     */
    zipCode: string;
}

export interface GetApiAccessRuleFilter {
    name: string;
    values: string[];
}

export interface GetApiAccessRulesApiAccessRule {
    /**
     * The ID of the API access rule.
     */
    apiAccessRuleId: string;
    /**
     * One or more IDs of Client Certificate Authorities (CAs).
     */
    caIds: string[];
    /**
     * One or more Client Certificate Common Names (CNs).
     */
    cns: string[];
    /**
     * The description of the API access rule.
     */
    description: string;
    /**
     * One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).
     */
    ipRanges: string[];
}

export interface GetApiAccessRulesFilter {
    name: string;
    values: string[];
}

export interface GetCaFilter {
    name: string;
    values: string[];
}

export interface GetCasCa {
    /**
     * The fingerprint of the CA.
     */
    caFingerprint: string;
    /**
     * The ID of the CA.
     */
    caId: string;
    /**
     * The description of the CA.
     */
    description: string;
}

export interface GetCasFilter {
    name: string;
    values: string[];
}

export interface GetClientGatewayFilter {
    name: string;
    values: string[];
}

export interface GetClientGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetClientGatewaysClientGateway {
    /**
     * The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet.
     */
    bgpAsn: number;
    /**
     * The ID of the client gateway.
     */
    clientGatewayId?: string;
    /**
     * The type of communication tunnel used by the client gateway (only `ipsec.1` is supported).
     */
    connectionType: string;
    /**
     * The public IPv4 address of the client gateway (must be a fixed address into a NATed network).
     */
    publicIp: string;
    /**
     * The state of the client gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * The key/value combinations of the tags associated with the client gateways, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetClientGatewaysClientGatewayTag[];
}

export interface GetClientGatewaysClientGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetClientGatewaysFilter {
    name: string;
    values: string[];
}

export interface GetDhcpOptionFilter {
    name: string;
    values: string[];
}

export interface GetDhcpOptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetDhcpOptionsDhcpOption {
    /**
     * If true, lists all default DHCP options set. If false, lists all non-default DHCP options set.
     */
    default: boolean;
    /**
     * The ID of the DHCP options set.
     */
    dhcpOptionsSetId: string;
    /**
     * The domain name.
     */
    domainName: string;
    /**
     * The IPs of the domain name servers used for the DHCP options sets.
     */
    domainNameServers: string[];
    /**
     * The IPs of the log servers used for the DHCP options sets.
     */
    logServers: string[];
    /**
     * The IPs of the Network Time Protocol (NTP) servers used for the DHCP options sets.
     */
    ntpServers: string[];
    /**
     * The key/value combinations of the tags associated with the DHCP options sets, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetDhcpOptionsDhcpOptionTag[];
}

export interface GetDhcpOptionsDhcpOptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetDhcpOptionsFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpuCatalogFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpuCatalogFlexibleGpuCatalog {
    /**
     * The generations of VMs that the fGPU is compatible with.
     */
    generations: string[];
    /**
     * The maximum number of VM vCores that the fGPU is compatible with.
     */
    maxCpu: number;
    /**
     * The maximum amount of VM memory that the fGPU is compatible with.
     */
    maxRam: number;
    /**
     * The model of fGPU.
     */
    modelName: string;
    /**
     * The amount of video RAM (VRAM) of the fGPU.
     */
    vRam: number;
}

export interface GetFlexibleGpuFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpusFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpusFlexibleGpus {
    /**
     * Indicates whether the fGPU is deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The ID of the fGPU.
     */
    flexibleGpuId: string;
    /**
     * The compatible processor generation.
     */
    generation: string;
    /**
     * The model of fGPU. For more information, see [About Flexible GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).
     */
    modelName: string;
    /**
     * The state of the fGPU (`allocated` \| `attaching` \| `attached` \| `detaching`).
     */
    state: string;
    /**
     * The Subregion where the fGPU is located.
     */
    subregionName: string;
    /**
     * The ID of the VM the fGPU is attached to, if any.
     */
    vmId: string;
}

export interface GetImageBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsus: outputs.GetImageBlockDeviceMappingBsus[];
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName: string;
}

export interface GetImageBlockDeviceMappingBsus {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType: string;
}

export interface GetImageExportTaskFilter {
    name: string;
    values: string[];
}

export interface GetImageExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the OMI is exported to.
     */
    osuBucket: string;
    /**
     * The URL of the manifest file.
     */
    osuManifestUrl: string;
    /**
     * The prefix for the key of the OOS object corresponding to the image.
     */
    osuPrefix: string;
}

export interface GetImageExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetImageExportTasksFilter {
    name: string;
    values: string[];
}

export interface GetImageExportTasksImageExportTask {
    /**
     * If the OMI export task fails, an error message appears.
     */
    comment: string;
    /**
     * The ID of the OMI to be exported.
     */
    imageId: string;
    /**
     * Information about the OMI export task.
     */
    osuExports: outputs.GetImageExportTasksImageExportTaskOsuExport[];
    /**
     * The progress of the OMI export task, as a percentage.
     */
    progress: number;
    /**
     * The state of the OMI export task (`pending/queued` \| `pending` \| `completed` \| `failed` \| `cancelled`).
     */
    state: string;
    /**
     * One or more tags associated with the image export task.
     */
    tags: outputs.GetImageExportTasksImageExportTaskTag[];
    /**
     * The ID of the OMI export task.
     */
    taskId: string;
}

export interface GetImageExportTasksImageExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the OMI is exported to.
     */
    osuBucket: string;
    /**
     * The URL of the manifest file.
     */
    osuManifestUrl: string;
    /**
     * The prefix for the key of the OOS object corresponding to the image.
     */
    osuPrefix: string;
}

export interface GetImageExportTasksImageExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetImageFilter {
    name: string;
    values: string[];
}

export interface GetImagePermissionsToLaunch {
    /**
     * The account ID of the owner of the OMI.
     */
    accountId: string;
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetImageStateComment {
    /**
     * The code of the change of state.
     */
    stateCode: string;
    /**
     * A message explaining the change of state.
     */
    stateMessage: string;
}

export interface GetImageTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetImagesFilter {
    name: string;
    values: string[];
}

export interface GetImagesImage {
    /**
     * The account alias of the owner of the OMI.
     */
    accountAlias: string;
    /**
     * The account ID of the owner of the OMI.
     */
    accountId: string;
    /**
     * The architecture of the OMI (by default, `i386`).
     */
    architecture: string;
    /**
     * One or more block device mappings.
     */
    blockDeviceMappings: outputs.GetImagesImageBlockDeviceMapping[];
    /**
     * The date and time of creation of the OMI.
     */
    creationDate: string;
    /**
     * The description of the OMI.
     */
    description: string;
    /**
     * The location of the bucket where the OMI files are stored.
     */
    fileLocation: string;
    /**
     * The ID of the OMI.
     */
    imageId: string;
    /**
     * The name of the OMI.
     */
    imageName: string;
    /**
     * The type of the OMI.
     */
    imageType: string;
    /**
     * Information about the users who have permissions for the resource.
     */
    permissionsToLaunches: outputs.GetImagesImagePermissionsToLaunch[];
    /**
     * The product code associated with the OMI (`0001` Linux/Unix \| `0002` Windows \| `0004` Linux/Oracle \| `0005` Windows 10).
     */
    productCodes: string[];
    /**
     * The name of the root device.
     */
    rootDeviceName: string;
    /**
     * The type of root device used by the OMI (always `bsu`).
     */
    rootDeviceType: string;
    /**
     * The state of the OMI (`pending` \| `available` \| `failed`).
     */
    state: string;
    /**
     * Information about the change of state.
     */
    stateComments: outputs.GetImagesImageStateComment[];
    /**
     * The key/value combinations of the tags associated with the OMIs, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetImagesImageTag[];
}

export interface GetImagesImageBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsus: outputs.GetImagesImageBlockDeviceMappingBsus[];
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName: string;
}

export interface GetImagesImageBlockDeviceMappingBsus {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType: string;
}

export interface GetImagesImagePermissionsToLaunch {
    /**
     * The account ID of the owner of the OMI.
     */
    accountId: string;
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetImagesImageStateComment {
    /**
     * The code of the change of state.
     */
    stateCode: string;
    /**
     * A message explaining the change of state.
     */
    stateMessage: string;
}

export interface GetImagesImageTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetInternetServiceFilter {
    name: string;
    values: string[];
}

export interface GetInternetServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetInternetServicesFilter {
    name: string;
    values: string[];
}

export interface GetInternetServicesInternetService {
    /**
     * The ID of the Internet service.
     */
    internetServiceId: string;
    /**
     * The ID of the Net attached to the Internet service.
     */
    netId: string;
    /**
     * The state of the attachment of the Internet service to the Net (always `available`).
     */
    state: string;
    /**
     * The key/value combinations of the tags associated with the Internet services, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetInternetServicesInternetServiceTag[];
}

export interface GetInternetServicesInternetServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetKeypairFilter {
    name: string;
    values: string[];
}

export interface GetKeypairsFilter {
    name: string;
    values: string[];
}

export interface GetKeypairsKeypair {
    /**
     * The MD5 public key fingerprint as specified in section 4 of RFC 4716.
     */
    keypairFingerprint: string;
    /**
     * The name of the keypair.
     */
    keypairName: string;
}

export interface GetLoadBalancerAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface GetLoadBalancerApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancerFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancerHealthCheck {
    /**
     * The number of seconds between two pings (between `5` and `600` both included).
     */
    checkInterval: string;
    checkedVm: string;
    /**
     * The number of consecutive successful pings before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: string;
    /**
     * The number of consecutive failed pings before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: string;
}

export interface GetLoadBalancerListener {
    /**
     * The port on which the back-end VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId: string;
}

export interface GetLoadBalancerLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancerSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetLoadBalancerTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetLoadBalancerTagsFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancerTagsTag {
    key: string;
    loadBalancerName: string;
    value: string;
}

export interface GetLoadBalancerVmHealthBackendVmHealth {
    /**
     * The description of the state of the back-end VM.
     */
    description: string;
    /**
     * The state of the back-end VM (`InService` \| `OutOfService` \| `Unknown`).
     */
    state: string;
    /**
     * Information about the cause of `OutOfService` VMs.<br />
     * Specifically, whether the cause is Elastic Load Balancing or the VM (`ELB` \| `Instance` \| `N/A`).
     */
    stateReason: string;
    /**
     * The ID of the back-end VM.
     */
    vmId: string;
}

export interface GetLoadBalancerVmHealthFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancersFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancersLoadBalancer {
    /**
     * Information about access logs.
     */
    accessLog: outputs.GetLoadBalancersLoadBalancerAccessLog;
    /**
     * The stickiness policies defined for the load balancer.
     */
    applicationStickyCookiePolicies: outputs.GetLoadBalancersLoadBalancerApplicationStickyCookiePolicy[];
    /**
     * One or more IDs of back-end VMs for the load balancer.
     */
    backendVmIds: outputs.GetLoadBalancersLoadBalancerBackendVmId[];
    /**
     * The DNS name of the load balancer.
     */
    dnsName: string;
    /**
     * Information about the health check configuration.
     */
    healthCheck: outputs.GetLoadBalancersLoadBalancerHealthCheck;
    /**
     * The listeners for the load balancer.
     */
    listeners: outputs.GetLoadBalancersLoadBalancerListener[];
    /**
     * The name of the load balancer.
     */
    loadBalancerName: string;
    /**
     * The policies defined for the load balancer.
     */
    loadBalancerStickyCookiePolicies: outputs.GetLoadBalancersLoadBalancerLoadBalancerStickyCookiePolicy[];
    /**
     * The type of load balancer. Valid only for load balancers in a Net.<br />
     * If `loadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />
     * If `loadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.
     */
    loadBalancerType: string;
    /**
     * The ID of the Net for the load balancer.
     */
    netId: string;
    /**
     * (internet-facing only) The public IP associated with the load balancer.
     */
    publicIp: string;
    /**
     * Whether secure cookies are enabled for the load balancer.
     */
    securedCookies: boolean;
    /**
     * One or more IDs of security groups for the load balancers. Valid only for load balancers in a Net.
     */
    securityGroups: string[];
    /**
     * Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
     * To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
     */
    sourceSecurityGroup: outputs.GetLoadBalancersLoadBalancerSourceSecurityGroup;
    subnetIds: string[];
    /**
     * The ID of the Subregion in which the load balancer was created.
     */
    subregionNames: string[];
    /**
     * One or more tags associated with the load balancer.
     */
    tags: outputs.GetLoadBalancersLoadBalancerTag[];
}

export interface GetLoadBalancersLoadBalancerAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface GetLoadBalancersLoadBalancerApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancersLoadBalancerBackendVmId {
    vmId: string;
}

export interface GetLoadBalancersLoadBalancerHealthCheck {
    /**
     * The number of seconds between two pings (between `5` and `600` both included).
     */
    checkInterval: string;
    checkedVm: string;
    /**
     * The number of consecutive successful pings before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: string;
    /**
     * The number of consecutive failed pings before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: string;
}

export interface GetLoadBalancersLoadBalancerListener {
    /**
     * The port on which the back-end VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId: string;
}

export interface GetLoadBalancersLoadBalancerLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancersLoadBalancerSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetLoadBalancersLoadBalancerTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNatServiceFilter {
    name: string;
    values: string[];
}

export interface GetNatServicePublicIp {
    /**
     * The public IP associated with the NAT service.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP associated with the NAT service.
     */
    publicIpId: string;
}

export interface GetNatServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNatServicesFilter {
    name: string;
    values: string[];
}

export interface GetNatServicesNatService {
    /**
     * The ID of the NAT service.
     */
    natServiceId: string;
    /**
     * The ID of the Net in which the NAT service is.
     */
    netId: string;
    /**
     * Information about the public IP or IPs associated with the NAT service.
     */
    publicIps: outputs.GetNatServicesNatServicePublicIp[];
    /**
     * The state of the NAT service (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * The ID of the Subnet in which the NAT service is.
     */
    subnetId: string;
    /**
     * The key/value combinations of the tags associated with the NAT services, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetNatServicesNatServiceTag[];
}

export interface GetNatServicesNatServicePublicIp {
    /**
     * The public IP associated with the NAT service.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP associated with the NAT service.
     */
    publicIpId: string;
}

export interface GetNatServicesNatServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetAccessPointFilter {
    name: string;
    values: string[];
}

export interface GetNetAccessPointServicesFilter {
    name: string;
    values: string[];
}

export interface GetNetAccessPointServicesService {
    /**
     * The list of network prefixes used by the service, in CIDR notation.
     */
    ipRanges: string[];
    /**
     * The ID of the service.
     */
    serviceId: string;
    /**
     * The name of the service.
     */
    serviceName: string;
}

export interface GetNetAccessPointTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetAccessPointsFilter {
    name: string;
    values: string[];
}

export interface GetNetAccessPointsNetAccessPoint {
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net with which the Net access point is associated.
     */
    netId: string;
    /**
     * The ID of the route tables associated with the Net access point.
     */
    routeTableIds: string[];
    /**
     * The name of the service with which the Net access point is associated.
     */
    serviceName: string;
    /**
     * The state of the Net access point (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * The key/value combinations of the tags associated with the Net access points, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetNetAccessPointsNetAccessPointTag[];
}

export interface GetNetAccessPointsNetAccessPointTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetAttributesTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetFilter {
    name: string;
    values: string[];
}

export interface GetNetPeeringAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringFilter {
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
    values: string[];
}

export interface GetNetPeeringSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface GetNetPeeringTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetPeeringsFilter {
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
    values: string[];
}

export interface GetNetPeeringsNetPeering {
    /**
     * Information about the accepter Net.
     */
    accepterNet: outputs.GetNetPeeringsNetPeeringAccepterNet;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * Information about the source Net.
     */
    sourceNet: outputs.GetNetPeeringsNetPeeringSourceNet;
    /**
     * Information about the state of the Net peering.
     */
    state: outputs.GetNetPeeringsNetPeeringState;
    /**
     * The key/value combinations of the tags associated with the Net peerings, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetNetPeeringsNetPeeringTag[];
}

export interface GetNetPeeringsNetPeeringAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringsNetPeeringSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringsNetPeeringState {
    code: string;
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
}

export interface GetNetPeeringsNetPeeringTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetsFilter {
    name: string;
    values: string[];
}

export interface GetNetsNet {
    /**
     * The ID of the DHCP options set (or `default` if you want to associate the default one).
     */
    dhcpOptionsSetId: string;
    /**
     * The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the Net.
     */
    netId: string;
    /**
     * The state of the Net (`pending` \| `available` \| `deleted`).
     */
    state: string;
    /**
     * The key/value combinations of the tags associated with the Nets, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetNetsNetTag[];
    /**
     * The VM tenancy in a Net.
     */
    tenancy: string;
}

export interface GetNetsNetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNicFilter {
    name: string;
    values: string[];
}

export interface GetNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
}

export interface GetNicLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP association.
     */
    linkPublicIp: outputs.GetNicPrivateIpLinkPublicIp;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface GetNicPrivateIpLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetNicTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNicsFilter {
    name: string;
    values: string[];
}

export interface GetNicsNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the NIC attachment.
     */
    linkNic: outputs.GetNicsNicLinkNic;
    /**
     * Information about the public IP association.
     */
    linkPublicIp: outputs.GetNicsNicLinkPublicIp;
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IPs of the NIC.
     */
    privateIps: outputs.GetNicsNicPrivateIp[];
    /**
     * One or more IDs of security groups for the NIC.
     */
    securityGroups: outputs.GetNicsNicSecurityGroup[];
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
    /**
     * The Subregion in which the NIC is located.
     */
    subregionName: string;
    /**
     * The key/value combinations of the tags associated with the NICs, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetNicsNicTag[];
}

export interface GetNicsNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    nicLinkId: string;
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
}

export interface GetNicsNicLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicsNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP association.
     */
    linkPublicIp: outputs.GetNicsNicPrivateIpLinkPublicIp;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface GetNicsNicPrivateIpLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicsNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetNicsNicTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetProductTypeFilter {
    name: string;
    values: string[];
}

export interface GetProductTypesFilter {
    name: string;
    values: string[];
}

export interface GetProductTypesProductType {
    /**
     * The description of the product type.
     */
    description: string;
    /**
     * The ID of the product type.
     */
    productTypeId: string;
    /**
     * The vendor of the product type.
     */
    vendor: string;
}

export interface GetPublicIpFilter {
    name: string;
    values: string[];
}

export interface GetPublicIpTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetPublicIpsFilter {
    name: string;
    values: string[];
}

export interface GetPublicIpsPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The account ID of the owner of the NIC.
     */
    nicAccountId: string;
    /**
     * The ID of the NIC the public IP is associated with (if any).
     */
    nicId: string;
    /**
     * The private IP associated with the public IP.
     */
    privateIp: string;
    /**
     * The public IP.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
    /**
     * The key/value combinations of the tags associated with the public IPs, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetPublicIpsPublicIpTag[];
    /**
     * The ID of the VM the public IP is associated with (if any).
     */
    vmId: string;
}

export interface GetPublicIpsPublicIpTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetPulicCatalogCatalog {
    entries: outputs.GetPulicCatalogCatalogEntry[];
}

export interface GetPulicCatalogCatalogEntry {
    category: string;
    flags: string;
    operation: string;
    service: string;
    subregionName: string;
    title: string;
    type: string;
    unitPrice: number;
}

export interface GetQuotaFilter {
    /**
     * The unique name of the quota.
     */
    name: string;
    values: string[];
}

export interface GetQuotasFilter {
    /**
     * The unique name of the quota.
     */
    name: string;
    values: string[];
}

export interface GetQuotasQuota {
    /**
     * The account ID of the owner of the quotas.
     */
    accountId: string;
    /**
     * The description of the quota.
     */
    description: string;
    /**
     * The maximum value of the quota for the OUTSCALE user account (if there is no limit, `0`).
     */
    maxValue: number;
    /**
     * The unique name of the quota.
     */
    name: string;
    /**
     * The group name of the quota.
     */
    quotaCollection: string;
    /**
     * The ressource ID if it is a resource-specific quota, `global` if it is not.
     */
    quotaType: string;
    /**
     * The description of the quota.
     */
    shortDescription: string;
    /**
     * The limit value currently used by the OUTSCALE user account.
     */
    usedValue: number;
}

export interface GetRegionsRegion {
    /**
     * The hostname of the gateway to access the Region.
     */
    endpoint: string;
    /**
     * The administrative name of the Region.
     */
    regionName: string;
}

export interface GetRouteTableFilter {
    name: string;
    values: string[];
}

export interface GetRouteTableLinkRouteTable {
    /**
     * The ID of the association between the route table and the Subnet.
     */
    linkRouteTableId: string;
    /**
     * If true, the route table is the main one.
     */
    main: boolean;
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    routeTableToSubnetLinkId: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
}

export interface GetRouteTableRoute {
    /**
     * The method used to create the route.
     */
    creationMethod: string;
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The ID of the OUTSCALE service.
     */
    destinationServiceId: string;
    /**
     * The ID of the Internet service or virtual gateway attached to the Net.
     */
    gatewayId: string;
    /**
     * The ID of a NAT service attached to the Net.
     */
    natServiceId: string;
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The state of a route in the route table (always `active`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of a VM specified in a route in the table.
     */
    vmId: string;
}

export interface GetRouteTableRoutePropagatingVirtualGateway {
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface GetRouteTableTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetRouteTablesFilter {
    name: string;
    values: string[];
}

export interface GetRouteTablesRouteTable {
    /**
     * One or more associations between the route table and Subnets.
     */
    linkRouteTables: outputs.GetRouteTablesRouteTableLinkRouteTable[];
    /**
     * The ID of the Net for the route table.
     */
    netId: string;
    /**
     * Information about virtual gateways propagating routes.
     */
    routePropagatingVirtualGateways: outputs.GetRouteTablesRouteTableRoutePropagatingVirtualGateway[];
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    /**
     * One or more routes in the route table.
     */
    routes: outputs.GetRouteTablesRouteTableRoute[];
    /**
     * The key/value combinations of the tags associated with the route tables, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetRouteTablesRouteTableTag[];
}

export interface GetRouteTablesRouteTableLinkRouteTable {
    /**
     * The ID of the association between the route table and the Subnet.
     */
    linkRouteTableId: string;
    /**
     * If true, the route table is the main one.
     */
    main: boolean;
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    routeTableToSubnetLinkId: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
}

export interface GetRouteTablesRouteTableRoute {
    /**
     * The method used to create the route.
     */
    creationMethod: string;
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The ID of the OUTSCALE service.
     */
    destinationServiceId: string;
    /**
     * The ID of the Internet service or virtual gateway attached to the Net.
     */
    gatewayId: string;
    /**
     * The ID of a NAT service attached to the Net.
     */
    natServiceId: string;
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The state of a route in the route table (always `active`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of a VM specified in a route in the table.
     */
    vmId: string;
}

export interface GetRouteTablesRouteTableRoutePropagatingVirtualGateway {
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface GetRouteTablesRouteTableTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSecurityGroupFilter {
    name: string;
    values: string[];
}

export interface GetSecurityGroupInboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers: outputs.GetSecurityGroupInboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupInboundRuleSecurityGroupsMember {
    /**
     * The account ID of a user.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupOutboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers: outputs.GetSecurityGroupOutboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupOutboundRuleSecurityGroupsMember {
    /**
     * The account ID of a user.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSecurityGroupsFilter {
    name: string;
    values: string[];
}

export interface GetSecurityGroupsSecurityGroup {
    /**
     * The account ID of a user.
     */
    accountId: string;
    /**
     * The description of the security group.
     */
    description: string;
    /**
     * The inbound rules associated with the security group.
     */
    inboundRules: outputs.GetSecurityGroupsSecurityGroupInboundRule[];
    /**
     * The ID of the Net for the security group.
     */
    netId: string;
    /**
     * The outbound rules associated with the security group.
     */
    outboundRules: outputs.GetSecurityGroupsSecurityGroupOutboundRule[];
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
    /**
     * The key/value combinations of the tags associated with the security groups, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetSecurityGroupsSecurityGroupTag[];
}

export interface GetSecurityGroupsSecurityGroupInboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers: outputs.GetSecurityGroupsSecurityGroupInboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupsSecurityGroupInboundRuleSecurityGroupsMember {
    /**
     * The account ID of a user.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupsSecurityGroupOutboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers: outputs.GetSecurityGroupsSecurityGroupOutboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupsSecurityGroupOutboundRuleSecurityGroupsMember {
    /**
     * The account ID of a user.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupsSecurityGroupTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetServerCertificateFilter {
    /**
     * The name of the server certificate.
     */
    name: string;
    values: string[];
}

export interface GetServerCertificatesFilter {
    /**
     * The name of the server certificate.
     */
    name: string;
    values: string[];
}

export interface GetServerCertificatesServerCertificate {
    /**
     * The date at which the server certificate expires.
     */
    expirationDate: string;
    /**
     * The ID of the server certificate.
     */
    id: string;
    /**
     * The name of the server certificate.
     */
    name: string;
    /**
     * The Outscale Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > Outscale Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    orn: string;
    /**
     * The path to the server certificate.
     */
    path: string;
    /**
     * The date at which the server certificate has been uploaded.
     */
    uploadDate: string;
}

export interface GetSnapshotExportTaskFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the snapshot is exported to.
     */
    osuBucket: string;
    /**
     * The prefix for the key of the OOS object corresponding to the snapshot.
     */
    osuPrefix: string;
}

export interface GetSnapshotExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSnapshotExportTasksFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotExportTasksSnapshotExportTask {
    /**
     * If the snapshot export task fails, an error message appears.
     */
    comment: string;
    /**
     * Information about the snapshot export task.
     */
    osuExports: outputs.GetSnapshotExportTasksSnapshotExportTaskOsuExport[];
    /**
     * The progress of the snapshot export task, as a percentage.
     */
    progress: number;
    /**
     * The ID of the snapshot to be exported.
     */
    snapshotId: string;
    /**
     * The state of the snapshot export task (`pending` \| `active` \| `completed` \| `failed`).
     */
    state: string;
    /**
     * One or more tags associated with the snapshot export task.
     */
    tags: outputs.GetSnapshotExportTasksSnapshotExportTaskTag[];
    /**
     * The ID of the snapshot export task.
     */
    taskId: string;
}

export interface GetSnapshotExportTasksSnapshotExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the snapshot is exported to.
     */
    osuBucket: string;
    /**
     * The prefix for the key of the OOS object corresponding to the snapshot.
     */
    osuPrefix: string;
}

export interface GetSnapshotExportTasksSnapshotExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSnapshotFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotPermissionsToCreateVolume {
    /**
     * The account IDs of the owners of the snapshots.
     */
    accountIds: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetSnapshotTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSnapshotsFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotsSnapshot {
    /**
     * The account alias of the owner of the snapshot.
     */
    accountAlias: string;
    /**
     * The account ID of the owner of the snapshot.
     */
    accountId: string;
    /**
     * The date and time of creation of the snapshot.
     */
    creationDate: string;
    /**
     * The description of the snapshot.
     */
    description: string;
    /**
     * Information about the users who have permissions for the resource.
     */
    permissionsToCreateVolumes: outputs.GetSnapshotsSnapshotPermissionsToCreateVolume[];
    /**
     * The progress of the snapshot, as a percentage.
     */
    progress: number;
    /**
     * The ID of the snapshot.
     */
    snapshotId: string;
    /**
     * The state of the snapshot (`in-queue` \| `completed` \| `error`).
     */
    state: string;
    /**
     * The key/value combinations of the tags associated with the snapshots, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetSnapshotsSnapshotTag[];
    /**
     * The ID of the volume used to create the snapshot.
     */
    volumeId: string;
    /**
     * The size of the volume used to create the snapshot, in gibibytes (GiB).
     */
    volumeSize: number;
}

export interface GetSnapshotsSnapshotPermissionsToCreateVolume {
    /**
     * The account IDs of the owners of the snapshots.
     */
    accountIds: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetSnapshotsSnapshotTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSubnetFilter {
    name: string;
    values: string[];
}

export interface GetSubnetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSubnetsFilter {
    name: string;
    values: string[];
}

export interface GetSubnetsSubnet {
    /**
     * The number of available IPs in the Subnets.
     */
    availableIpsCount: number;
    /**
     * The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
     */
    mapPublicIpOnLaunch: boolean;
    /**
     * The ID of the Net in which the Subnet is.
     */
    netId: string;
    /**
     * The state of the Subnet (`pending` \| `available` \| `deleted`).
     */
    state: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
    /**
     * The name of the Subregion in which the Subnet is located.
     */
    subregionName: string;
    /**
     * The key/value combinations of the tags associated with the Subnets, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetSubnetsSubnetTag[];
}

export interface GetSubnetsSubnetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSubregionsFilter {
    name: string;
    values: string[];
}

export interface GetSubregionsSubregion {
    /**
     * The location code of the Subregion.
     */
    locationCode: string;
    /**
     * The name of the Region containing the Subregion.
     */
    regionName: string;
    /**
     * The state of the Subregion (`available` \| `information` \| `impaired` \| `unavailable`).
     */
    state: string;
    /**
     * The name of the Subregion.
     */
    subregionName: string;
}

export interface GetTagFilter {
    name: string;
    values: string[];
}

export interface GetVirtualGatewayFilter {
    name: string;
    values: string[];
}

export interface GetVirtualGatewayNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which the virtual gateway is attached.
     */
    netId: string;
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
}

export interface GetVirtualGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVirtualGatewaysFilter {
    name: string;
    values: string[];
}

export interface GetVirtualGatewaysVirtualGateway {
    /**
     * The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
     */
    connectionType: string;
    /**
     * The Net to which the virtual gateway is attached.
     */
    netToVirtualGatewayLinks: outputs.GetVirtualGatewaysVirtualGatewayNetToVirtualGatewayLink[];
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * The key/value combinations of the tags associated with the virtual gateways, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetVirtualGatewaysVirtualGatewayTag[];
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface GetVirtualGatewaysVirtualGatewayNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which the virtual gateway is attached.
     */
    netId: string;
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
}

export interface GetVirtualGatewaysVirtualGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVmBlockDeviceMappingsCreated {
    /**
     * Information about the created BSU volume.
     */
    bsu: outputs.GetVmBlockDeviceMappingsCreatedBsu;
    /**
     * The name of the device.
     */
    deviceName?: string;
}

export interface GetVmBlockDeviceMappingsCreatedBsu {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The time and date of attachment of the volume to the VM.
     */
    linkDate: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: number;
    /**
     * The ID of the volume.
     */
    volumeId: number;
}

export interface GetVmFilter {
    name: string;
    values: string[];
}

export interface GetVmNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNic: outputs.GetVmNicLinkNic;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: outputs.GetVmNicPrivateIp[];
    secondaryPrivateIpCount: number;
    securityGroupIds: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmNicSecurityGroup[];
    securityGroupsNames: string[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
}

export interface GetVmNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
}

export interface GetVmNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
}

export interface GetVmNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmStateFilter {
    name: string;
    values: string[];
}

export interface GetVmStateMaintenanceEvent {
    /**
     * The code of the event (`system-reboot` \| `system-maintenance`).
     */
    code: string;
    /**
     * The description of the event.
     */
    description: string;
    /**
     * The latest scheduled end time for the event.
     */
    notAfter: string;
    /**
     * The earliest scheduled start time for the event.
     */
    notBefore: string;
}

export interface GetVmStatesFilter {
    name: string;
    values: string[];
}

export interface GetVmStatesVmState {
    /**
     * If true, includes the status of all VMs. By default or if set to false, only includes the status of running VMs.
     */
    allVms?: boolean;
    /**
     * One or more scheduled events associated with the VM.
     */
    maintenanceEvents: outputs.GetVmStatesVmStateMaintenanceEvent[];
    /**
     * The name of the Subregion of the VM.
     */
    subregionName: string;
    /**
     * The ID of the VM.
     */
    vmId?: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    vmState: string;
}

export interface GetVmStatesVmStateMaintenanceEvent {
    /**
     * The code of the event (`system-reboot` \| `system-maintenance`).
     */
    code: string;
    /**
     * The description of the event.
     */
    description: string;
    /**
     * The latest scheduled end time for the event.
     */
    notAfter: string;
    /**
     * The earliest scheduled start time for the event.
     */
    notBefore: string;
}

export interface GetVmTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVmTypesFilter {
    name: string;
    values: string[];
}

export interface GetVmTypesVmType {
    /**
     * This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
     */
    bsuOptimized: boolean;
    /**
     * The maximum number of private IPs per network interface card (NIC).
     */
    maxPrivateIps: number;
    /**
     * The amount of memory, in gibibytes.
     */
    memorySize: number;
    /**
     * The number of vCores.
     */
    vcoreCount: number;
    /**
     * The name of the VM type.
     */
    vmTypeName: string;
    /**
     * The maximum number of ephemeral storage disks.
     */
    volumeCount: number;
    /**
     * The size of one ephemeral storage disk, in gibibytes (GiB).
     */
    volumeSize: number;
}

export interface GetVmsFilter {
    name: string;
    values: string[];
}

export interface GetVmsVm {
    /**
     * The architecture of the VM (`i386` \| `x8664`).
     */
    architecture: string;
    /**
     * The block device mapping of the VM.
     */
    blockDeviceMappingsCreateds: outputs.GetVmsVmBlockDeviceMappingsCreated[];
    bsuOptimized: boolean;
    /**
     * The idempotency token provided when launching the VM.
     */
    clientToken: string;
    /**
     * The date and time of creation of the VM.
     */
    creationDate: string;
    /**
     * If true, you cannot delete the VM unless you change this parameter back to false.
     */
    deletionProtection: boolean;
    /**
     * The hypervisor type of the VMs (`ovm` \| `xen`).
     */
    hypervisor: string;
    /**
     * The ID of the OMI used to create the VM.
     */
    imageId: string;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
     */
    isSourceDestChecked: boolean;
    /**
     * The name of the keypair used when launching the VM.
     */
    keypairName: string;
    /**
     * The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
     */
    launchNumber: number;
    /**
     * If true, nested virtualization is enabled. If false, it is disabled.
     */
    nestedVirtualization: boolean;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * (Net only) The network interface cards (NICs) the VMs are attached to.
     */
    nics: outputs.GetVmsVmNic[];
    /**
     * Indicates the operating system (OS) of the VM.
     */
    osFamily: string;
    /**
     * The performance of the VM (`medium` \| `high` \|  `highest`).
     */
    performance: string;
    placementSubregionName: string;
    placementTenancy: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps?: string[];
    /**
     * The product code associated with the OMI used to create the VM (`0001` Linux/Unix \| `0002` Windows \| `0004` Linux/Oracle \| `0005` Windows 10).
     */
    productCodes: string[];
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    requestId: string;
    /**
     * The reservation ID of the VM.
     */
    reservationId: string;
    /**
     * The name of the root device for the VM (for example, `/dev/vda1`).
     */
    rootDeviceName: string;
    /**
     * The type of root device used by the VM (always `bsu`).
     */
    rootDeviceType: string;
    securityGroupIds?: string[];
    securityGroupNames?: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmsVmSecurityGroup[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The reason explaining the current state of the VM.
     */
    stateReason: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
    /**
     * The key/value combinations of the tags associated with the VMs, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetVmsVmTag[];
    /**
     * The Base64-encoded MIME user data.
     */
    userData: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.
     */
    vmInitiatedShutdownBehavior: string;
    /**
     * The type of VM. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).
     */
    vmType: string;
}

export interface GetVmsVmBlockDeviceMappingsCreated {
    /**
     * Information about the created BSU volume.
     */
    bsu: outputs.GetVmsVmBlockDeviceMappingsCreatedBsu;
    /**
     * The name of the device.
     */
    deviceName?: string;
}

export interface GetVmsVmBlockDeviceMappingsCreatedBsu {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The time and date of attachment of the volume to the VM.
     */
    linkDate: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: number;
    /**
     * The ID of the volume.
     */
    volumeId: number;
}

export interface GetVmsVmNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNic: outputs.GetVmsVmNicLinkNic;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmsVmNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: outputs.GetVmsVmNicPrivateIp[];
    secondaryPrivateIpCount: number;
    securityGroupIds: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmsVmNicSecurityGroup[];
    securityGroupsNames: string[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
}

export interface GetVmsVmNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
}

export interface GetVmsVmNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmsVmNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmsVmNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
}

export interface GetVmsVmNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmsVmNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmsVmSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmsVmTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVolumeFilter {
    name: string;
    values: string[];
}

export interface GetVolumeLinkedVolume {
    /**
     * If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The name of the device.
     */
    deviceName: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface GetVolumeTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVolumesFilter {
    name: string;
    values: string[];
}

export interface GetVolumesVolume {
    /**
     * The date and time of creation of the volume.
     */
    creationDate: string;
    /**
     * The number of I/O operations per second (IOPS):<br />- For `io1` volumes, the number of provisioned IOPS.<br />- For `gp2` volumes, the baseline performance of the volume.
     */
    iops: number;
    /**
     * Information about your volume attachment.
     */
    linkedVolumes: outputs.GetVolumesVolumeLinkedVolume[];
    /**
     * The size of the volume, in gibibytes (GiB).
     */
    size: number;
    /**
     * The snapshot from which the volume was created.
     */
    snapshotId: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The Subregion in which the volume was created.
     */
    subregionName: string;
    /**
     * The key/value combinations of the tags associated with the volumes, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetVolumesVolumeTag[];
    /**
     * The ID of the volume.
     */
    volumeId: string;
    /**
     * The type of the volume (`standard` \| `gp2` \| `io1`).
     */
    volumeType: string;
}

export interface GetVolumesVolumeLinkedVolume {
    /**
     * If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The name of the device.
     */
    deviceName: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface GetVolumesVolumeTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVpnConnectionFilter {
    name: string;
    values: string[];
}

export interface GetVpnConnectionRoute {
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The type of route (always `static`).
     */
    routeType: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
}

export interface GetVpnConnectionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVpnConnectionVgwTelemetry {
    /**
     * The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
     */
    acceptedRouteCount: number;
    /**
     * The date and time (UTC) of the latest state update.
     */
    lastStateChangeDate: string;
    /**
     * The IP on the OUTSCALE side of the tunnel.
     */
    outsideIpAddress: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * A description of the current state of the tunnel.
     */
    stateDescription: string;
}

export interface GetVpnConnectionsFilter {
    name: string;
    values: string[];
}

export interface GetVpnConnectionsVpnConnection {
    /**
     * Example configuration for the client gateway.
     */
    clientGatewayConfiguration: string;
    /**
     * The ID of the client gateway used on the client end of the connection.
     */
    clientGatewayId: string;
    /**
     * The type of VPN connection (always `ipsec.1`).
     */
    connectionType: string;
    /**
     * Information about one or more static routes associated with the VPN connection, if any.
     */
    routes: outputs.GetVpnConnectionsVpnConnectionRoute[];
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](https://docs.outscale.com/api#createvpnconnectionroute) and [DeleteVpnConnectionRoute](https://docs.outscale.com/api#deletevpnconnectionroute).
     */
    staticRoutesOnly?: boolean;
    /**
     * The key/value combinations of the tags associated with the VPN connections, in the following format: `TAGKEY=TAGVALUE`.
     */
    tags: outputs.GetVpnConnectionsVpnConnectionTag[];
    /**
     * Information about the current state of one or more of the VPN tunnels.
     */
    vgwTelemetries: outputs.GetVpnConnectionsVpnConnectionVgwTelemetry[];
    /**
     * The ID of the virtual gateway used on the OUTSCALE end of the connection.
     */
    virtualGatewayId: string;
    /**
     * The ID of the VPN connection.
     */
    vpnConnectionId: string;
}

export interface GetVpnConnectionsVpnConnectionRoute {
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The type of route (always `static`).
     */
    routeType: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
}

export interface GetVpnConnectionsVpnConnectionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVpnConnectionsVpnConnectionVgwTelemetry {
    /**
     * The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
     */
    acceptedRouteCount: number;
    /**
     * The date and time (UTC) of the latest state update.
     */
    lastStateChangeDate: string;
    /**
     * The IP on the OUTSCALE side of the tunnel.
     */
    outsideIpAddress: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * A description of the current state of the tunnel.
     */
    stateDescription: string;
}

export interface ImageBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsus: outputs.ImageBlockDeviceMappingBsus[];
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName: string;
}

export interface ImageBlockDeviceMappingBsus {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType: string;
}

export interface ImageExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * Information about the OOS API key.
     */
    osuApiKeys?: outputs.ImageExportTaskOsuExportOsuApiKey[];
    /**
     * The name of the OOS bucket where you want to export the object.
     */
    osuBucket: string;
    /**
     * The URL of the manifest file.
     */
    osuManifestUrl: string;
    /**
     * The prefix for the key of the OOS object.
     */
    osuPrefix?: string;
}

export interface ImageExportTaskOsuExportOsuApiKey {
    /**
     * The API key of the OOS account that enables you to access the bucket.
     */
    apiKeyId: string;
    /**
     * The secret key of the OOS account that enables you to access the bucket.
     */
    secretKey: string;
}

export interface ImageExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface ImageLaunchPermissionPermissionAdditions {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: string;
}

export interface ImageLaunchPermissionPermissionRemovals {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: string;
}

export interface ImageLaunchPermissionPermissionsToLaunch {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: string;
}

export interface ImagePermissionsToLaunch {
    /**
     * The account ID of one or more users who have permissions for the resource.
     */
    accountIds: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface ImageStateComment {
    /**
     * The code of the change of state.
     */
    stateCode: string;
    /**
     * A message explaining the change of state.
     */
    stateMessage: string;
}

export interface ImageTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface InternetServiceLinkTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface InternetServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface LoadBalancerAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface LoadBalancerApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerAttributesAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName?: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix?: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval?: number;
}

export interface LoadBalancerAttributesApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerAttributesHealthCheck {
    /**
     * The number of seconds between two pings (between `5` and `600` both included).
     */
    checkInterval: number;
    /**
     * The number of consecutive successful pings before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: number;
    /**
     * If you use the HTTP or HTTPS protocols, the ping path.
     */
    path?: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: number;
    /**
     * The number of consecutive failed pings before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: number;
}

export interface LoadBalancerAttributesListener {
    /**
     * The port on which the back-end VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The name of the policy you want to enable for the listener.
     */
    policyNames: string[];
    /**
     * The Outscale Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > Outscale Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns). If this parameter is specified, you must also specify the `loadBalancerPort` parameter.
     */
    serverCertificateId: string;
}

export interface LoadBalancerAttributesLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerAttributesSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface LoadBalancerAttributesTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface LoadBalancerHealthCheck {
    /**
     * The number of seconds between two pings (between `5` and `600` both included).
     */
    checkInterval: string;
    /**
     * The number of consecutive successful pings before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: string;
    /**
     * If you use the HTTP or HTTPS protocols, the ping path.
     */
    path: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: string;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: string;
    /**
     * The number of consecutive failed pings before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: string;
}

export interface LoadBalancerListener {
    /**
     * The port on which the back-end VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId?: string;
}

export interface LoadBalancerLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerPolicyAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface LoadBalancerPolicyApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
     */
    cookieName: string;
    /**
     * The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).
     */
    policyName: string;
}

export interface LoadBalancerPolicyHealthCheck {
    /**
     * The number of seconds between two pings (between `5` and `600` both included).
     */
    checkInterval: string;
    /**
     * The number of consecutive successful pings before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: string;
    /**
     * If you use the HTTP or HTTPS protocols, the ping path.
     */
    path: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: string;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: string;
    /**
     * The number of consecutive failed pings before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: string;
}

export interface LoadBalancerPolicyListener {
    /**
     * The port on which the back-end VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId: string;
}

export interface LoadBalancerPolicyLoadBalancerStickyCookiePolicy {
    /**
     * The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).
     */
    policyName: string;
}

export interface LoadBalancerPolicySourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface LoadBalancerPolicyTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface LoadBalancerSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface LoadBalancerTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key?: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value?: string;
}

export interface NatServicePublicIp {
    /**
     * The public IP associated with the NAT service.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP to associate with the NAT service.<br />
     * If the public IP is already associated with another resource, you must first disassociate it.
     */
    publicIpId: string;
}

export interface NatServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetAccessPointTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetAttributesTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetPeeringAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringAcceptionAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringAcceptionSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringAcceptionState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface NetPeeringAcceptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetPeeringSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface NetPeeringTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
}

export interface NicLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface NicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP association.
     */
    linkPublicIp: outputs.NicPrivateIpLinkPublicIp;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface NicPrivateIpLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface NicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface NicTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface OutboundRuleRule {
    fromPortRange?: number;
    ipProtocol: string;
    ipRanges?: string[];
    securityGroupsMembers: outputs.OutboundRuleRuleSecurityGroupsMember[];
    serviceIds?: string[];
    toPortRange?: number;
}

export interface OutboundRuleRuleSecurityGroupsMember {
    accountId?: string;
    securityGroupId?: string;
    securityGroupName?: string;
}

export interface PublicIpLinkTag {
    key: string;
    value: string;
}

export interface PublicIpTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface RouteTableLinkRouteTable {
    /**
     * The ID of the association between the route table and the Subnet.
     */
    linkRouteTableId: string;
    /**
     * If true, the route table is the main one.
     */
    main: boolean;
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    routeTableToSubnetLinkId: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
}

export interface RouteTableRoute {
    /**
     * The method used to create the route.
     */
    creationMethod: string;
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The ID of the OUTSCALE service.
     */
    destinationServiceId: string;
    /**
     * The ID of the Internet service or virtual gateway attached to the Net.
     */
    gatewayId: string;
    /**
     * The ID of a NAT service attached to the Net.
     */
    natServiceId: string;
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The state of a route in the route table (always `active`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of a VM specified in a route in the table.
     */
    vmId: string;
}

export interface RouteTableRoutePropagatingVirtualGateway {
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface RouteTableTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SecurityGroupInboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers?: {[key: string]: any}[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface SecurityGroupOutboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers?: {[key: string]: any}[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface SecurityGroupRuleRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange?: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges?: string[];
    /**
     * Information about one or more members of a security group.
     */
    securityGroupsMembers: outputs.SecurityGroupRuleRuleSecurityGroupsMember[];
    /**
     * One or more service IDs to allow traffic from a Net to access the corresponding OUTSCALE services. For more information, see [ReadNetAccessPointServices](https://docs.outscale.com/api#readnetaccesspointservices).
     */
    serviceIds?: string[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number. If you specify this parameter, you cannot specify the `rules` parameter and its subparameters.
     */
    toPortRange?: number;
}

export interface SecurityGroupRuleRuleSecurityGroupsMember {
    /**
     * The account ID of a user.
     */
    accountId?: string;
    /**
     * The ID of the security group for which you want to create a rule.
     */
    securityGroupId?: string;
    /**
     * The name of the security group.
     */
    securityGroupName?: string;
}

export interface SecurityGroupTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SnapshotAttributesPermissionsToCreateVolumeAdditions {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: boolean;
}

export interface SnapshotAttributesPermissionsToCreateVolumeRemoval {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: boolean;
}

export interface SnapshotExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * Information about the OOS API key.
     */
    osuApiKeys?: outputs.SnapshotExportTaskOsuExportOsuApiKey[];
    /**
     * The name of the OOS bucket where you want to export the object.
     */
    osuBucket: string;
    /**
     * The prefix for the key of the OOS object.
     */
    osuPrefix: string;
}

export interface SnapshotExportTaskOsuExportOsuApiKey {
    /**
     * The API key of the OOS account that enables you to access the bucket.
     */
    apiKeyId: string;
    /**
     * The secret key of the OOS account that enables you to access the bucket.
     */
    secretKey: string;
}

export interface SnapshotExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SnapshotPermissionsToCreateVolume {
    /**
     * The account ID of the owner of the snapshot.
     */
    accountId: string;
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface SnapshotTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SubnetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface TagTag {
    key: string;
    resourceId: string;
    resourceType: string;
    value: string;
}

export interface VirtualGatewayLinkNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which you want to attach the virtual gateway.
     */
    netId: string;
    /**
     * The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
     */
    state: string;
}

export interface VirtualGatewayNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which the virtual gateway is attached.
     */
    netId: string;
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
}

export interface VirtualGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VmBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsu: outputs.VmBlockDeviceMappingBsu;
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName?: string;
    /**
     * Removes the device which is included in the block device mapping of the OMI.
     */
    noDevice?: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName?: string;
}

export interface VmBlockDeviceMappingBsu {
    /**
     * If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
     */
    deleteOnVmDeletion?: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops?: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId?: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize?: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType?: string;
}

export interface VmBlockDeviceMappingsCreated {
    /**
     * Information about the BSU volume to create.
     */
    bsu: outputs.VmBlockDeviceMappingsCreatedBsu;
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName?: string;
}

export interface VmBlockDeviceMappingsCreatedBsu {
    /**
     * If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
     */
    deleteOnVmDeletion: boolean;
    /**
     * The time and date of attachment of the volume to the VM.
     */
    linkDate: string;
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: number;
    /**
     * The ID of the volume.
     */
    volumeId: number;
}

export interface VmNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC, if you are creating a NIC when creating the VM.
     */
    description: string;
    /**
     * The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNic: outputs.VmNicLinkNic;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.VmNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC, if you are attaching an existing NIC when creating a VM.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * One or more private IPs of the VM.
     */
    privateIps: outputs.VmNicPrivateIp[];
    /**
     * The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `privateIps` parameter.
     */
    secondaryPrivateIpCount: number;
    /**
     * One or more IDs of security group for the VMs.
     */
    securityGroupIds?: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.VmNicSecurityGroup[];
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
    /**
     * The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `nics` parameter.
     */
    subnetId: string;
}

export interface VmNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
     */
    deleteOnVmDeletion: boolean;
    /**
     * The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
}

export interface VmNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface VmNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.VmNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface VmNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface VmNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface VmSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface VmTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VolumeLinkedVolume {
    /**
     * If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The name of the device.
     */
    deviceName: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface VolumeTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VpnConnectionRoute {
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The type of route (always `static`).
     */
    routeType: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
}

export interface VpnConnectionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VpnConnectionVgwTelemetry {
    /**
     * The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
     */
    acceptedRouteCount: number;
    /**
     * The date and time (UTC) of the latest state update.
     */
    lastStateChangeDate: string;
    /**
     * The IP on the OUTSCALE side of the tunnel.
     */
    outsideIpAddress: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * A description of the current state of the tunnel.
     */
    stateDescription: string;
}

export namespace config {
    export interface Endpoints {
        api?: string;
    }

}
