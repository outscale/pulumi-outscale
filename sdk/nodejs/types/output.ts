// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessKeyTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface ClientGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface DhcpOptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface FlexibleGpuTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface GetAccessKeyFilter {
    name: string;
    values: string[];
}

export interface GetAccessKeysAccessKey {
    /**
     * The ID of the access key.
     */
    accessKeyId: string;
    /**
     * The date and time (UTC) at which the access key was created.
     */
    creationDate: string;
    /**
     * The date and time (UTC) at which the access key expires.
     */
    expirationDate: string;
    /**
     * The date and time (UTC) at which the access key was last modified.
     */
    lastModificationDate: string;
    /**
     * The state of the access key (`ACTIVE` if the key is valid for API calls, or `INACTIVE` if not).
     */
    state: string;
}

export interface GetAccessKeysFilter {
    name: string;
    values: string[];
}

export interface GetAccountsAccount {
    /**
     * The ID of the account.
     */
    accountId: string;
    /**
     * One or more additional email addresses for the account. These addresses are used for notifications only.
     */
    additionalEmails: string[];
    /**
     * The city of the account owner.
     */
    city: string;
    /**
     * The name of the company for the account.
     */
    companyName: string;
    /**
     * The country of the account owner.
     */
    country: string;
    /**
     * The ID of the customer.
     */
    customerId: string;
    /**
     * The main email address for the account. This address is used for your credentials and for notifications.
     */
    email: string;
    /**
     * The first name of the account owner.
     */
    firstName: string;
    /**
     * The job title of the account owner.
     */
    jobTitle: string;
    /**
     * The last name of the account owner.
     */
    lastName: string;
    /**
     * The mobile phone number of the account owner.
     */
    mobileNumber: string;
    /**
     * The landline phone number of the account owner.
     */
    phoneNumber: string;
    /**
     * The state/province of the account.
     */
    stateProvince: string;
    /**
     * The value added tax (VAT) number for the account.
     */
    vatNumber: string;
    /**
     * The ZIP code of the city.
     */
    zipCode: string;
}

export interface GetApiAccessRuleFilter {
    name: string;
    values: string[];
}

export interface GetApiAccessRulesApiAccessRule {
    /**
     * The ID of the API access rule.
     */
    apiAccessRuleId: string;
    /**
     * One or more IDs of Client Certificate Authorities (CAs) used for the API access rule.
     */
    caIds: string[];
    /**
     * One or more Client Certificate Common Names (CNs).
     */
    cns: string[];
    /**
     * The description of the API access rule.
     */
    description: string;
    /**
     * One or more IP ranges used for the API access rule, in CIDR notation (for example, `192.0.2.0/16`).
     */
    ipRanges: string[];
}

export interface GetApiAccessRulesFilter {
    name: string;
    values: string[];
}

export interface GetCaFilter {
    name: string;
    values: string[];
}

export interface GetCasCa {
    /**
     * The fingerprint of the CA.
     */
    caFingerprint: string;
    /**
     * The ID of the CA.
     */
    caId: string;
    /**
     * The description of the CA.
     */
    description: string;
}

export interface GetCasFilter {
    name: string;
    values: string[];
}

export interface GetClientGatewayFilter {
    name: string;
    values: string[];
}

export interface GetClientGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetClientGatewaysClientGateway {
    /**
     * The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet.
     */
    bgpAsn: number;
    /**
     * The ID of the client gateway.
     */
    clientGatewayId?: string;
    /**
     * The type of communication tunnel used by the client gateway (always `ipsec.1`).
     */
    connectionType: string;
    /**
     * The public IPv4 address of the client gateway (must be a fixed address into a NATed network).
     */
    publicIp: string;
    /**
     * The state of the client gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * One or more tags associated with the client gateway.
     */
    tags: outputs.GetClientGatewaysClientGatewayTag[];
}

export interface GetClientGatewaysClientGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetClientGatewaysFilter {
    name: string;
    values: string[];
}

export interface GetDhcpOptionFilter {
    name: string;
    values: string[];
}

export interface GetDhcpOptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetDhcpOptionsDhcpOption {
    /**
     * If true, the DHCP options set is a default one. If false, it is not.
     */
    default: boolean;
    /**
     * The ID of the DHCP options set.
     */
    dhcpOptionsSetId: string;
    /**
     * The domain name.
     */
    domainName: string;
    /**
     * One or more IPs for the domain name servers.
     */
    domainNameServers: string[];
    /**
     * One or more IPs for the log servers.
     */
    logServers: string[];
    /**
     * One or more IPs for the NTP servers.
     */
    ntpServers: string[];
    /**
     * One or more tags associated with the DHCP options set.
     */
    tags: outputs.GetDhcpOptionsDhcpOptionTag[];
}

export interface GetDhcpOptionsDhcpOptionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetDhcpOptionsFilter {
    name: string;
    values: string[];
}

export interface GetEntitiesLinkedToPolicyPolicyEntity {
    /**
     * TODO_ARRAY
     */
    accounts: outputs.GetEntitiesLinkedToPolicyPolicyEntityAccount[];
    /**
     * TODO_ARRAY
     */
    groups: outputs.GetEntitiesLinkedToPolicyPolicyEntityGroup[];
    /**
     * TODO_ARRAY
     */
    users: outputs.GetEntitiesLinkedToPolicyPolicyEntityUser[];
}

export interface GetEntitiesLinkedToPolicyPolicyEntityAccount {
    /**
     * The ID of the entity.
     */
    id: string;
    /**
     * The name of the entity.
     */
    name: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the entity. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
}

export interface GetEntitiesLinkedToPolicyPolicyEntityGroup {
    /**
     * The ID of the entity.
     */
    id: string;
    /**
     * The name of the entity.
     */
    name: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the entity. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
}

export interface GetEntitiesLinkedToPolicyPolicyEntityUser {
    /**
     * The ID of the entity.
     */
    id: string;
    /**
     * The name of the entity.
     */
    name: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the entity. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
}

export interface GetFlexibleGpuCatalogFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpuCatalogFlexibleGpuCatalog {
    /**
     * The processor generations that the fGPUs are compatible with.
     */
    generations: string[];
    /**
     * The maximum number of VM vCores that the fGPU is compatible with.
     */
    maxCpu: number;
    /**
     * The maximum amount of VM memory that the fGPU is compatible with.
     */
    maxRam: number;
    /**
     * The model of fGPU.
     */
    modelName: string;
    /**
     * The amount of video RAM (VRAM) of the fGPU.
     */
    vRam: number;
}

export interface GetFlexibleGpuFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpusFilter {
    name: string;
    values: string[];
}

export interface GetFlexibleGpusFlexibleGpus {
    /**
     * If true, the fGPU is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The ID of the fGPU.
     */
    flexibleGpuId: string;
    /**
     * The compatible processor generation.
     */
    generation: string;
    /**
     * The model of fGPU. For more information, see [About Flexible GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).
     */
    modelName: string;
    /**
     * The state of the fGPU (`allocated` \| `attaching` \| `attached` \| `detaching`).
     */
    state: string;
    /**
     * The Subregion where the fGPU is located.
     */
    subregionName: string;
    /**
     * The ID of the VM the fGPU is attached to, if any.
     */
    vmId: string;
}

export interface GetImageBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsus: outputs.GetImageBlockDeviceMappingBsus[];
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName: string;
}

export interface GetImageBlockDeviceMappingBsus {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType: string;
}

export interface GetImageExportTaskFilter {
    name: string;
    values: string[];
}

export interface GetImageExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the OMI is exported to.
     */
    osuBucket: string;
    /**
     * The URL of the manifest file.
     */
    osuManifestUrl: string;
    /**
     * The prefix for the key of the OOS object corresponding to the image.
     */
    osuPrefix: string;
}

export interface GetImageExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetImageExportTasksFilter {
    name: string;
    values: string[];
}

export interface GetImageExportTasksImageExportTask {
    /**
     * If the OMI export task fails, an error message appears.
     */
    comment: string;
    /**
     * The ID of the OMI to be exported.
     */
    imageId: string;
    /**
     * Information about the OMI export task.
     */
    osuExports: outputs.GetImageExportTasksImageExportTaskOsuExport[];
    /**
     * The progress of the OMI export task, as a percentage.
     */
    progress: number;
    /**
     * The state of the OMI export task (`pending/queued` \| `pending` \| `completed` \| `failed` \| `cancelled`).
     */
    state: string;
    /**
     * One or more tags associated with the image export task.
     */
    tags: outputs.GetImageExportTasksImageExportTaskTag[];
    /**
     * The ID of the OMI export task.
     */
    taskId: string;
}

export interface GetImageExportTasksImageExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the OMI is exported to.
     */
    osuBucket: string;
    /**
     * The URL of the manifest file.
     */
    osuManifestUrl: string;
    /**
     * The prefix for the key of the OOS object corresponding to the image.
     */
    osuPrefix: string;
}

export interface GetImageExportTasksImageExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetImageFilter {
    name: string;
    values: string[];
}

export interface GetImagePermissionsToLaunch {
    /**
     * The account ID of the owner of the OMI.
     */
    accountId: string;
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetImageStateComment {
    /**
     * The code of the change of state.
     */
    stateCode: string;
    /**
     * A message explaining the change of state.
     */
    stateMessage: string;
}

export interface GetImageTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetImagesFilter {
    name: string;
    values: string[];
}

export interface GetImagesImage {
    /**
     * The account alias of the owner of the OMI.
     */
    accountAlias: string;
    /**
     * The account ID of the owner of the OMI.
     */
    accountId: string;
    /**
     * The architecture of the OMI.
     */
    architecture: string;
    /**
     * One or more block device mappings.
     */
    blockDeviceMappings: outputs.GetImagesImageBlockDeviceMapping[];
    /**
     * The date and time (UTC) at which the OMI was created.
     */
    creationDate: string;
    /**
     * The description of the OMI.
     */
    description: string;
    /**
     * The location from which the OMI files were created.
     */
    fileLocation: string;
    /**
     * The ID of the OMI.
     */
    imageId: string;
    /**
     * The name of the OMI.
     */
    imageName: string;
    /**
     * The type of the OMI.
     */
    imageType: string;
    /**
     * Permissions for the resource.
     */
    permissionsToLaunches: outputs.GetImagesImagePermissionsToLaunch[];
    /**
     * The product codes associated with the OMI.
     */
    productCodes: string[];
    /**
     * The name of the root device.
     */
    rootDeviceName: string;
    /**
     * The type of root device used by the OMI (always `bsu`).
     */
    rootDeviceType: string;
    /**
     * The state of the OMI (`pending` \| `available` \| `failed`).
     */
    state: string;
    /**
     * Information about the change of state.
     */
    stateComments: outputs.GetImagesImageStateComment[];
    /**
     * One or more tags associated with the OMI.
     */
    tags: outputs.GetImagesImageTag[];
}

export interface GetImagesImageBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsus: outputs.GetImagesImageBlockDeviceMappingBsus[];
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName: string;
}

export interface GetImagesImageBlockDeviceMappingBsus {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType: string;
}

export interface GetImagesImagePermissionsToLaunch {
    /**
     * The account ID of the owner of the OMI.
     */
    accountId: string;
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetImagesImageStateComment {
    /**
     * The code of the change of state.
     */
    stateCode: string;
    /**
     * A message explaining the change of state.
     */
    stateMessage: string;
}

export interface GetImagesImageTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetInternetServiceFilter {
    name: string;
    values: string[];
}

export interface GetInternetServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetInternetServicesFilter {
    name: string;
    values: string[];
}

export interface GetInternetServicesInternetService {
    /**
     * The ID of the internet service.
     */
    internetServiceId: string;
    /**
     * The ID of the Net attached to the internet service.
     */
    netId: string;
    /**
     * The state of the attachment of the internet service to the Net (always `available`).
     */
    state: string;
    /**
     * One or more tags associated with the internet service.
     */
    tags: outputs.GetInternetServicesInternetServiceTag[];
}

export interface GetInternetServicesInternetServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetKeypairFilter {
    name: string;
    values: string[];
}

export interface GetKeypairTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetKeypairsFilter {
    name: string;
    values: string[];
}

export interface GetKeypairsKeypair {
    /**
     * The MD5 public key fingerprint as specified in section 4 of RFC 4716.
     */
    keypairFingerprint: string;
    /**
     * The ID of the keypair.
     */
    keypairId: string;
    /**
     * The name of the keypair.
     */
    keypairName: string;
    /**
     * The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
     */
    keypairType: string;
    /**
     * One or more tags associated with the keypair.
     */
    tags: outputs.GetKeypairsKeypairTag[];
}

export interface GetKeypairsKeypairTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetLoadBalancerAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface GetLoadBalancerApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancerFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancerHealthCheck {
    /**
     * The number of seconds between two requests (between `5` and `600` both included).
     */
    checkInterval: number;
    /**
     * The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: number;
    /**
     * If you use the HTTP or HTTPS protocols, the request URL path.
     */
    path: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: number;
    /**
     * The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: number;
}

export interface GetLoadBalancerListener {
    /**
     * The port on which the backend VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to backend VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId: string;
}

export interface GetLoadBalancerListenerRuleFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancerListenerRulesFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancerListenerRulesListenerRule {
    /**
     * The type of action for the rule (always `forward`).
     */
    action: string;
    /**
     * A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except `-.?`.
     */
    hostNamePattern: string;
    /**
     * The ID of the listener.
     */
    listenerId: number;
    /**
     * The ID of the listener rule.
     */
    listenerRuleId: number;
    /**
     * A human-readable name for the listener rule.
     */
    listenerRuleName: string;
    /**
     * A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except `_-.$/~&quot;'@:+?`.
     */
    pathPattern: string;
    /**
     * The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
     */
    priority: number;
    /**
     * The IDs of the backend VMs.
     */
    vmIds: string[];
}

export interface GetLoadBalancerLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancerSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetLoadBalancerTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetLoadBalancerTagsFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancerTagsTag {
    key: string;
    loadBalancerName: string;
    value: string;
}

export interface GetLoadBalancerVmHealthBackendVmHealth {
    /**
     * The description of the state of the backend VM.
     */
    description: string;
    /**
     * The state of the backend VM (`InService` \| `OutOfService` \| `Unknown`).
     */
    state: string;
    /**
     * Information about the cause of `OutOfService` VMs.<br />
     * Specifically, whether the cause is Elastic Load Balancing or the VM (`ELB` \| `Instance` \| `N/A`).
     */
    stateReason: string;
    /**
     * The ID of the backend VM.
     */
    vmId: string;
}

export interface GetLoadBalancerVmHealthFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancersFilter {
    name: string;
    values: string[];
}

export interface GetLoadBalancersLoadBalancer {
    /**
     * Information about access logs.
     */
    accessLogs: outputs.GetLoadBalancersLoadBalancerAccessLog[];
    /**
     * The stickiness policies defined for the load balancer.
     */
    applicationStickyCookiePolicies: outputs.GetLoadBalancersLoadBalancerApplicationStickyCookiePolicy[];
    backendIps: string[];
    /**
     * One or more IDs of backend VMs for the load balancer.
     */
    backendVmIds: outputs.GetLoadBalancersLoadBalancerBackendVmId[];
    /**
     * The DNS name of the load balancer.
     */
    dnsName: string;
    /**
     * Information about the health check configuration.
     */
    healthChecks: outputs.GetLoadBalancersLoadBalancerHealthCheck[];
    /**
     * The listeners for the load balancer.
     */
    listeners: outputs.GetLoadBalancersLoadBalancerListener[];
    /**
     * The name of the load balancer.
     */
    loadBalancerName: string;
    /**
     * The policies defined for the load balancer.
     */
    loadBalancerStickyCookiePolicies: outputs.GetLoadBalancersLoadBalancerLoadBalancerStickyCookiePolicy[];
    /**
     * The type of load balancer. Valid only for load balancers in a Net.<br />
     * If `loadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />
     * If `loadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.
     */
    loadBalancerType: string;
    /**
     * The ID of the Net for the load balancer.
     */
    netId: string;
    /**
     * (internet-facing only) The public IP associated with the load balancer.
     */
    publicIp: string;
    /**
     * Whether secure cookies are enabled for the load balancer.
     */
    securedCookies: boolean;
    /**
     * One or more IDs of security groups for the load balancers. Valid only for load balancers in a Net.
     */
    securityGroups: string[];
    /**
     * Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
     * To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
     */
    sourceSecurityGroups: outputs.GetLoadBalancersLoadBalancerSourceSecurityGroup[];
    subnetIds: string[];
    /**
     * The ID of the Subregion in which the load balancer was created.
     */
    subregionNames: string[];
    /**
     * One or more tags associated with the load balancer.
     */
    tags: outputs.GetLoadBalancersLoadBalancerTag[];
}

export interface GetLoadBalancersLoadBalancerAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface GetLoadBalancersLoadBalancerApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancersLoadBalancerBackendVmId {
    vmId: string;
}

export interface GetLoadBalancersLoadBalancerHealthCheck {
    /**
     * The number of seconds between two requests (between `5` and `600` both included).
     */
    checkInterval: number;
    /**
     * The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: number;
    /**
     * If you use the HTTP or HTTPS protocols, the request URL path.
     */
    path: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: number;
    /**
     * The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: number;
}

export interface GetLoadBalancersLoadBalancerListener {
    /**
     * The port on which the backend VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to backend VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId: string;
}

export interface GetLoadBalancersLoadBalancerLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface GetLoadBalancersLoadBalancerSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetLoadBalancersLoadBalancerTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNatServiceFilter {
    name: string;
    values: string[];
}

export interface GetNatServicePublicIp {
    /**
     * The public IP associated with the NAT service.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP associated with the NAT service.
     */
    publicIpId: string;
}

export interface GetNatServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNatServicesFilter {
    name: string;
    values: string[];
}

export interface GetNatServicesNatService {
    /**
     * The ID of the NAT service.
     */
    natServiceId: string;
    /**
     * The ID of the Net in which the NAT service is.
     */
    netId: string;
    /**
     * Information about the public IP or IPs associated with the NAT service.
     */
    publicIps: outputs.GetNatServicesNatServicePublicIp[];
    /**
     * The state of the NAT service (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * The ID of the Subnet in which the NAT service is.
     */
    subnetId: string;
    /**
     * One or more tags associated with the NAT service.
     */
    tags: outputs.GetNatServicesNatServiceTag[];
}

export interface GetNatServicesNatServicePublicIp {
    /**
     * The public IP associated with the NAT service.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP associated with the NAT service.
     */
    publicIpId: string;
}

export interface GetNatServicesNatServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetAccessPointFilter {
    name: string;
    values: string[];
}

export interface GetNetAccessPointServicesFilter {
    name: string;
    values: string[];
}

export interface GetNetAccessPointServicesService {
    /**
     * The list of network prefixes used by the service, in CIDR notation.
     */
    ipRanges: string[];
    /**
     * The ID of the service.
     */
    serviceId: string;
    /**
     * The name of the service.
     */
    serviceName: string;
}

export interface GetNetAccessPointTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetAccessPointsFilter {
    name: string;
    values: string[];
}

export interface GetNetAccessPointsNetAccessPoint {
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net with which the Net access point is associated.
     */
    netId: string;
    /**
     * The ID of the route tables associated with the Net access point.
     */
    routeTableIds: string[];
    /**
     * The name of the service with which the Net access point is associated.
     */
    serviceName: string;
    /**
     * The state of the Net access point (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * One or more tags associated with the Net access point.
     */
    tags: outputs.GetNetAccessPointsNetAccessPointTag[];
}

export interface GetNetAccessPointsNetAccessPointTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetAttributesTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetFilter {
    name: string;
    values: string[];
}

export interface GetNetPeeringAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringFilter {
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
    values: string[];
}

export interface GetNetPeeringSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface GetNetPeeringTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetPeeringsFilter {
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
    values: string[];
}

export interface GetNetPeeringsNetPeering {
    /**
     * Information about the accepter Net.
     */
    accepterNets: outputs.GetNetPeeringsNetPeeringAccepterNet[];
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * Information about the source Net.
     */
    sourceNets: outputs.GetNetPeeringsNetPeeringSourceNet[];
    /**
     * Information about the state of the Net peering.
     */
    states: outputs.GetNetPeeringsNetPeeringState[];
    /**
     * One or more tags associated with the Net peering.
     */
    tags: outputs.GetNetPeeringsNetPeeringTag[];
}

export interface GetNetPeeringsNetPeeringAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringsNetPeeringSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface GetNetPeeringsNetPeeringState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface GetNetPeeringsNetPeeringTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNetsFilter {
    name: string;
    values: string[];
}

export interface GetNetsNet {
    /**
     * The ID of the DHCP options set (or `default` if you want to associate the default one).
     */
    dhcpOptionsSetId: string;
    /**
     * The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the Net.
     */
    netId: string;
    /**
     * The state of the Net (`pending` \| `available` \| `deleting`).
     */
    state: string;
    /**
     * One or more tags associated with the Net.
     */
    tags: outputs.GetNetsNetTag[];
    /**
     * The VM tenancy in a Net.
     */
    tenancy: string;
}

export interface GetNetsNetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNicFilter {
    name: string;
    values: string[];
}

export interface GetNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
}

export interface GetNicLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP association.
     */
    linkPublicIps: outputs.GetNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface GetNicPrivateIpLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetNicTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetNicsFilter {
    name: string;
    values: string[];
}

export interface GetNicsNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the NIC attachment.
     */
    linkNics: outputs.GetNicsNicLinkNic[];
    /**
     * Information about the public IP association.
     */
    linkPublicIps: outputs.GetNicsNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IPs of the NIC.
     */
    privateIps: outputs.GetNicsNicPrivateIp[];
    /**
     * One or more IDs of security groups for the NIC.
     */
    securityGroups: outputs.GetNicsNicSecurityGroup[];
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
    /**
     * The Subregion in which the NIC is located.
     */
    subregionName: string;
    /**
     * One or more tags associated with the NIC.
     */
    tags: outputs.GetNicsNicTag[];
}

export interface GetNicsNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
}

export interface GetNicsNicLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicsNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP association.
     */
    linkPublicIps: outputs.GetNicsNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface GetNicsNicPrivateIpLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface GetNicsNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetNicsNicTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetPoliciesFilter {
    name: string;
    values: string[];
}

export interface GetPoliciesLinkedToUserGroupFilter {
    name: string;
    values: string[];
}

export interface GetPoliciesLinkedToUserGroupPolicy {
    /**
     * The date and time (UTC) at which the linked policy was created.
     */
    creationDate: string;
    /**
     * The date and time (UTC) at which the linked policy was last modified.
     */
    lastModificationDate: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
    /**
     * The ID of the policy.
     */
    policyId: string;
    /**
     * The name of the policy.
     */
    policyName: string;
}

export interface GetPoliciesLinkedToUserPolicy {
    /**
     * The date and time (UTC) at which the linked policy was created.
     */
    creationDate: string;
    /**
     * The date and time (UTC) at which the linked policy was last modified.
     */
    lastModificationDate: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
    /**
     * The ID of the policy.
     */
    policyId: string;
    /**
     * The name of the policy.
     */
    policyName: string;
}

export interface GetPoliciesPolicy {
    /**
     * The date and time (UTC) at which the policy was created.
     */
    creationDate: string;
    /**
     * A friendly name for the policy (between 0 and 1000 characters).
     */
    description: string;
    /**
     * Indicates whether the policy can be linked to a group or an EIM user.
     */
    isLinkable: boolean;
    /**
     * The date and time (UTC) at which the policy was last modified.
     */
    lastModificationDate: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
    /**
     * The path to the policy.
     */
    path: string;
    /**
     * The ID of the policy default version.
     */
    policyDefaultVersionId: string;
    /**
     * The ID of the policy.
     */
    policyId: string;
    /**
     * The name of the policy.
     */
    policyName: string;
    /**
     * The number of resources attached to the policy.
     */
    resourcesCount: number;
}

export interface GetProductTypeFilter {
    name: string;
    values: string[];
}

export interface GetProductTypesFilter {
    name: string;
    values: string[];
}

export interface GetProductTypesProductType {
    /**
     * The description of the product type.
     */
    description: string;
    /**
     * The ID of the product type.
     */
    productTypeId: string;
    /**
     * The vendor of the product type.
     */
    vendor: string;
}

export interface GetPublicCatalogCatalog {
    entries: outputs.GetPublicCatalogCatalogEntry[];
}

export interface GetPublicCatalogCatalogEntry {
    category: string;
    flags: string;
    operation: string;
    service: string;
    subregionName: string;
    title: string;
    type: string;
    unitPrice: number;
}

export interface GetPublicIpFilter {
    name: string;
    values: string[];
}

export interface GetPublicIpTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetPublicIpsFilter {
    name: string;
    values: string[];
}

export interface GetPublicIpsPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The account ID of the owner of the NIC.
     */
    nicAccountId: string;
    /**
     * The ID of the NIC the public IP is associated with (if any).
     */
    nicId: string;
    /**
     * The private IP associated with the public IP.
     */
    privateIp: string;
    /**
     * The public IP.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
    /**
     * One or more tags associated with the public IP.
     */
    tags: outputs.GetPublicIpsPublicIpTag[];
    /**
     * The ID of the VM the public IP is associated with (if any).
     */
    vmId: string;
}

export interface GetPublicIpsPublicIpTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetQuotaFilter {
    /**
     * The unique name of the quota.
     */
    name: string;
    values: string[];
}

export interface GetQuotasFilter {
    /**
     * The unique name of the quota.
     */
    name: string;
    values: string[];
}

export interface GetQuotasQuota {
    /**
     * The account ID of the owner of the quotas.
     */
    accountId: string;
    /**
     * The description of the quota.
     */
    description: string;
    /**
     * The maximum value of the quota for the account (if there is no limit, `0`).
     */
    maxValue: number;
    /**
     * The unique name of the quota.
     */
    name: string;
    /**
     * The group name of the quota.
     */
    quotaCollection: string;
    /**
     * The ressource ID if it is a resource-specific quota, `global` if it is not.
     */
    quotaType: string;
    /**
     * The description of the quota.
     */
    shortDescription: string;
    /**
     * The limit value currently used by the account.
     */
    usedValue: number;
}

export interface GetRegionsRegion {
    /**
     * The hostname of the gateway to access the Region.
     */
    endpoint: string;
    /**
     * The administrative name of the Region.
     */
    regionName: string;
}

export interface GetRouteTableFilter {
    name: string;
    values: string[];
}

export interface GetRouteTableLinkRouteTable {
    /**
     * The ID of the association between the route table and the Net or Subnet.
     */
    linkRouteTableId: string;
    /**
     * If true, the route table is the main one.
     */
    main: boolean;
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    routeTableToSubnetLinkId: string;
    /**
     * The ID of the Subnet, if the route table is explicitly linked to a Subnet.
     */
    subnetId: string;
}

export interface GetRouteTableRoute {
    /**
     * The method used to create the route.
     */
    creationMethod: string;
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The ID of the OUTSCALE service.
     */
    destinationServiceId: string;
    /**
     * The ID of the internet service or virtual gateway attached to the Net.
     */
    gatewayId: string;
    /**
     * The ID of a NAT service attached to the Net.
     */
    natServiceId: string;
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The state of a route in the route table (always `active`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of a VM specified in a route in the table.
     */
    vmId: string;
}

export interface GetRouteTableRoutePropagatingVirtualGateway {
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface GetRouteTableTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetRouteTablesFilter {
    name: string;
    values: string[];
}

export interface GetRouteTablesRouteTable {
    /**
     * One or more associations between the route table and Subnets.
     */
    linkRouteTables: outputs.GetRouteTablesRouteTableLinkRouteTable[];
    /**
     * The ID of the Net for the route table.
     */
    netId: string;
    /**
     * Information about virtual gateways propagating routes.
     */
    routePropagatingVirtualGateways: outputs.GetRouteTablesRouteTableRoutePropagatingVirtualGateway[];
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    /**
     * One or more routes in the route table.
     */
    routes: outputs.GetRouteTablesRouteTableRoute[];
    /**
     * One or more tags associated with the route table.
     */
    tags: outputs.GetRouteTablesRouteTableTag[];
}

export interface GetRouteTablesRouteTableLinkRouteTable {
    /**
     * The ID of the association between the route table and the Net or Subnet.
     */
    linkRouteTableId: string;
    /**
     * If true, the route table is the main one.
     */
    main: boolean;
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    routeTableToSubnetLinkId: string;
    /**
     * The ID of the Subnet, if the route table is explicitly linked to a Subnet.
     */
    subnetId: string;
}

export interface GetRouteTablesRouteTableRoute {
    /**
     * The method used to create the route.
     */
    creationMethod: string;
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The ID of the OUTSCALE service.
     */
    destinationServiceId: string;
    /**
     * The ID of the internet service or virtual gateway attached to the Net.
     */
    gatewayId: string;
    /**
     * The ID of a NAT service attached to the Net.
     */
    natServiceId: string;
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The state of a route in the route table (always `active`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of a VM specified in a route in the table.
     */
    vmId: string;
}

export interface GetRouteTablesRouteTableRoutePropagatingVirtualGateway {
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface GetRouteTablesRouteTableTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSecurityGroupFilter {
    name: string;
    values: string[];
}

export interface GetSecurityGroupInboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers: outputs.GetSecurityGroupInboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupInboundRuleSecurityGroupsMember {
    /**
     * The account ID that owns the source or destination security group.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupOutboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers: outputs.GetSecurityGroupOutboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupOutboundRuleSecurityGroupsMember {
    /**
     * The account ID that owns the source or destination security group.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSecurityGroupsFilter {
    name: string;
    values: string[];
}

export interface GetSecurityGroupsSecurityGroup {
    /**
     * The account ID that owns the source or destination security group.
     */
    accountId: string;
    /**
     * The description of the security group.
     */
    description: string;
    /**
     * The inbound rules associated with the security group.
     */
    inboundRules: outputs.GetSecurityGroupsSecurityGroupInboundRule[];
    /**
     * The ID of the Net for the security group.
     */
    netId: string;
    /**
     * The outbound rules associated with the security group.
     */
    outboundRules: outputs.GetSecurityGroupsSecurityGroupOutboundRule[];
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
    /**
     * One or more tags associated with the security group.
     */
    tags: outputs.GetSecurityGroupsSecurityGroupTag[];
}

export interface GetSecurityGroupsSecurityGroupInboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers: outputs.GetSecurityGroupsSecurityGroupInboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupsSecurityGroupInboundRuleSecurityGroupsMember {
    /**
     * The account ID that owns the source or destination security group.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupsSecurityGroupOutboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    prefixListIds: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers: outputs.GetSecurityGroupsSecurityGroupOutboundRuleSecurityGroupsMember[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface GetSecurityGroupsSecurityGroupOutboundRuleSecurityGroupsMember {
    /**
     * The account ID that owns the source or destination security group.
     */
    accountId: string;
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetSecurityGroupsSecurityGroupTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetServerCertificateFilter {
    /**
     * The name of the server certificate.
     */
    name: string;
    values: string[];
}

export interface GetServerCertificatesFilter {
    /**
     * The name of the server certificate.
     */
    name: string;
    values: string[];
}

export interface GetServerCertificatesServerCertificate {
    /**
     * The date on which the server certificate expires.
     */
    expirationDate: string;
    /**
     * The ID of the server certificate.
     */
    id: string;
    /**
     * The name of the server certificate.
     */
    name: string;
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    orn: string;
    /**
     * The path to the server certificate.
     */
    path: string;
    /**
     * The date on which the server certificate has been uploaded.
     */
    uploadDate: string;
}

export interface GetSnapshotExportTaskFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the snapshot is exported to.
     */
    osuBucket: string;
    /**
     * The prefix for the key of the OOS object corresponding to the snapshot.
     */
    osuPrefix: string;
}

export interface GetSnapshotExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSnapshotExportTasksFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotExportTasksSnapshotExportTask {
    /**
     * If the snapshot export task fails, an error message appears.
     */
    comment: string;
    /**
     * Information about the snapshot export task.
     */
    osuExports: outputs.GetSnapshotExportTasksSnapshotExportTaskOsuExport[];
    /**
     * The progress of the snapshot export task, as a percentage.
     */
    progress: number;
    /**
     * The ID of the snapshot to be exported.
     */
    snapshotId: string;
    /**
     * The state of the snapshot export task (`pending` \| `active` \| `completed` \| `failed`).
     */
    state: string;
    /**
     * One or more tags associated with the snapshot export task.
     */
    tags: outputs.GetSnapshotExportTasksSnapshotExportTaskTag[];
    /**
     * The ID of the snapshot export task.
     */
    taskId: string;
}

export interface GetSnapshotExportTasksSnapshotExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * The name of the OOS bucket the snapshot is exported to.
     */
    osuBucket: string;
    /**
     * The prefix for the key of the OOS object corresponding to the snapshot.
     */
    osuPrefix: string;
}

export interface GetSnapshotExportTasksSnapshotExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSnapshotFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotPermissionsToCreateVolume {
    /**
     * One or more account IDs that the permission is associated with.
     */
    accountIds: string[];
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetSnapshotTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSnapshotsFilter {
    name: string;
    values: string[];
}

export interface GetSnapshotsSnapshot {
    /**
     * The account alias of the owner of the snapshot.
     */
    accountAlias: string;
    /**
     * The account ID of the owner of the snapshot.
     */
    accountId: string;
    /**
     * The date and time (UTC) at which the snapshot was created.
     */
    creationDate: string;
    /**
     * The description of the snapshot.
     */
    description: string;
    /**
     * Permissions for the resource.
     */
    permissionsToCreateVolumes: outputs.GetSnapshotsSnapshotPermissionsToCreateVolume[];
    /**
     * The progress of the snapshot, as a percentage.
     */
    progress: number;
    /**
     * The ID of the snapshot.
     */
    snapshotId: string;
    /**
     * The state of the snapshot (`in-queue` \| `pending` \| `completed` \| `error` \| `deleting`)).
     */
    state: string;
    /**
     * One or more tags associated with the snapshot.
     */
    tags: outputs.GetSnapshotsSnapshotTag[];
    /**
     * The ID of the volume used to create the snapshot.
     */
    volumeId: string;
    /**
     * The size of the volume used to create the snapshot, in gibibytes (GiB).
     */
    volumeSize: number;
}

export interface GetSnapshotsSnapshotPermissionsToCreateVolume {
    /**
     * One or more account IDs that the permission is associated with.
     */
    accountIds: string[];
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface GetSnapshotsSnapshotTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSubnetFilter {
    name: string;
    values: string[];
}

export interface GetSubnetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSubnetsFilter {
    name: string;
    values: string[];
}

export interface GetSubnetsSubnet {
    /**
     * The number of available IPs in the Subnets.
     */
    availableIpsCount: number;
    /**
     * The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
     */
    mapPublicIpOnLaunch: boolean;
    /**
     * The ID of the Net in which the Subnet is.
     */
    netId: string;
    /**
     * The state of the Subnet (`pending` \| `available` \| `deleted`).
     */
    state: string;
    /**
     * The ID of the Subnet.
     */
    subnetId: string;
    /**
     * The name of the Subregion in which the Subnet is located.
     */
    subregionName: string;
    /**
     * One or more tags associated with the Subnet.
     */
    tags: outputs.GetSubnetsSubnetTag[];
}

export interface GetSubnetsSubnetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetSubregionsFilter {
    name: string;
    values: string[];
}

export interface GetSubregionsSubregion {
    /**
     * The location code (physical zone) of the Subregion. For more information, see [About Regions > Mapping Between Subregions and Physical Zones](https://docs.outscale.com/en/userguide/About-Regions-and-Subregions.html#_mapping_between_subregions_and_physical_zones).
     */
    locationCode: string;
    /**
     * The name of the Region containing the Subregion.
     */
    regionName: string;
    /**
     * The state of the Subregion.
     */
    state: string;
    /**
     * The name of the Subregion.
     */
    subregionName: string;
}

export interface GetTagFilter {
    name: string;
    values: string[];
}

export interface GetTagsFilter {
    name: string;
    values: string[];
}

export interface GetTagsTag {
    key: string;
    resourceId: string;
    resourceType: string;
    value: string;
}

export interface GetUserFilter {
    name: string;
    values: string[];
}

export interface GetUserGroupUser {
    /**
     * The date and time (UTC) of creation of the EIM user.
     */
    creationDate: string;
    /**
     * The date and time (UTC) of the last modification of the EIM user.
     */
    lastModificationDate: string;
    /**
     * The path to the group. If not specified, it is set to a slash (`/`).
     */
    path: string;
    /**
     * The email address of the EIM user.
     */
    userEmail: string;
    /**
     * The ID of the EIM user.
     */
    userId: string;
    /**
     * The name of the EIM user.
     */
    userName: string;
}

export interface GetUserGroupsFilter {
    /**
     * The name of the user group.
     */
    name: string;
    values: string[];
}

export interface GetUserGroupsPerUserUserGroup {
    /**
     * The date and time (UTC) of creation of the user group.
     */
    creationDate: string;
    /**
     * The date and time (UTC) of the last modification of the user group.
     */
    lastModificationDate: string;
    /**
     * The Outscale Resource Name (ORN) of the user group. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
    /**
     * The path to the user group.
     */
    path: string;
    /**
     * The ID of the user group.
     */
    userGroupId: string;
    userGroupName: string;
}

export interface GetUserGroupsUserGroup {
    /**
     * The date and time (UTC) of creation of the user group.
     */
    creationDate: string;
    /**
     * The date and time (UTC) of the last modification of the user group.
     */
    lastModificationDate: string;
    /**
     * The Outscale Resource Name (ORN) of the user group. For more information, see [Resource Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).
     */
    orn: string;
    /**
     * The path to the user group.
     */
    path: string;
    /**
     * The ID of the user group.
     */
    userGroupId: string;
    userGroupName: string;
}

export interface GetUsersFilter {
    name: string;
    values: string[];
}

export interface GetUsersUser {
    /**
     * The date and time (UTC) of creation of the EIM user.
     */
    creationDate: string;
    /**
     * The date and time (UTC) of the last modification of the EIM user.
     */
    lastModificationDate: string;
    /**
     * The path to the EIM user.
     */
    path: string;
    /**
     * The email address of the EIM user.
     */
    userEmail: string;
    /**
     * The ID of the EIM user.
     */
    userId: string;
    /**
     * The name of the EIM user.
     */
    userName: string;
}

export interface GetVirtualGatewayFilter {
    name: string;
    values: string[];
}

export interface GetVirtualGatewayNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which the virtual gateway is attached.
     */
    netId: string;
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
}

export interface GetVirtualGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVirtualGatewaysFilter {
    name: string;
    values: string[];
}

export interface GetVirtualGatewaysVirtualGateway {
    /**
     * The type of VPN connection supported by the virtual gateway (always `ipsec.1`).
     */
    connectionType: string;
    /**
     * The Net to which the virtual gateway is attached.
     */
    netToVirtualGatewayLinks: outputs.GetVirtualGatewaysVirtualGatewayNetToVirtualGatewayLink[];
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
    /**
     * One or more tags associated with the virtual gateway.
     */
    tags: outputs.GetVirtualGatewaysVirtualGatewayTag[];
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface GetVirtualGatewaysVirtualGatewayNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which the virtual gateway is attached.
     */
    netId: string;
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
}

export interface GetVirtualGatewaysVirtualGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVmActionsOnNextBoot {
    secureBoot: string;
}

export interface GetVmBlockDeviceMappingsCreated {
    /**
     * Information about the created BSU volume.
     */
    bsus: outputs.GetVmBlockDeviceMappingsCreatedBsus[];
    /**
     * The name of the device.
     */
    deviceName: string;
}

export interface GetVmBlockDeviceMappingsCreatedBsus {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The date and time (UTC) at which the volume was attached to the VM, in ISO 8601 date-time format.
     */
    linkDate: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * One or more tags associated with the VM.
     */
    tags?: outputs.GetVmBlockDeviceMappingsCreatedBsusTag[];
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface GetVmBlockDeviceMappingsCreatedBsusTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVmFilter {
    name: string;
    values: string[];
}

export interface GetVmNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNics: outputs.GetVmNicLinkNic[];
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: outputs.GetVmNicPrivateIp[];
    secondaryPrivateIpCount: number;
    /**
     * The IDs of the security groups for the VMs (only in the public Cloud).
     */
    securityGroupIds: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmNicSecurityGroup[];
    securityGroupsNames: string[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
}

export interface GetVmNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
}

export interface GetVmNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
}

export interface GetVmNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmPrimaryNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNics: outputs.GetVmPrimaryNicLinkNic[];
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmPrimaryNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: outputs.GetVmPrimaryNicPrivateIp[];
    secondaryPrivateIpCount: number;
    /**
     * The IDs of the security groups for the VMs (only in the public Cloud).
     */
    securityGroupIds: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmPrimaryNicSecurityGroup[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
}

export interface GetVmPrimaryNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
}

export interface GetVmPrimaryNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmPrimaryNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmPrimaryNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
}

export interface GetVmPrimaryNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmPrimaryNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmStateFilter {
    name: string;
    values: string[];
}

export interface GetVmStateMaintenanceEvent {
    /**
     * The code of the event (`system-reboot` \| `system-maintenance`).
     */
    code: string;
    /**
     * The description of the event.
     */
    description: string;
    /**
     * The latest scheduled end date and time (UTC) for the event.
     */
    notAfter: string;
    /**
     * The earliest scheduled start date and time (UTC) for the event.
     */
    notBefore: string;
}

export interface GetVmStatesFilter {
    name: string;
    values: string[];
}

export interface GetVmStatesVmState {
    /**
     * If true, includes the status of all VMs. By default or if set to false, only includes the status of running VMs.
     */
    allVms?: boolean;
    /**
     * One or more scheduled events associated with the VM.
     */
    maintenanceEvents: outputs.GetVmStatesVmStateMaintenanceEvent[];
    /**
     * The name of the Subregion of the VM.
     */
    subregionName: string;
    /**
     * The ID of the VM.
     */
    vmId?: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    vmState: string;
}

export interface GetVmStatesVmStateMaintenanceEvent {
    /**
     * The code of the event (`system-reboot` \| `system-maintenance`).
     */
    code: string;
    /**
     * The description of the event.
     */
    description: string;
    /**
     * The latest scheduled end date and time (UTC) for the event.
     */
    notAfter: string;
    /**
     * The earliest scheduled start date and time (UTC) for the event.
     */
    notBefore: string;
}

export interface GetVmTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVmTypesFilter {
    name: string;
    values: string[];
}

export interface GetVmTypesVmType {
    /**
     * This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
     */
    bsuOptimized: boolean;
    /**
     * The maximum number of private IPs per network interface card (NIC).
     */
    maxPrivateIps: number;
    /**
     * The amount of memory, in gibibytes.
     */
    memorySize: number;
    /**
     * The number of vCores.
     */
    vcoreCount: number;
    /**
     * The name of the VM type.
     */
    vmTypeName: string;
    /**
     * The maximum number of ephemeral storage disks.
     */
    volumeCount: number;
    /**
     * The size of one ephemeral storage disk, in gibibytes (GiB).
     */
    volumeSize: number;
}

export interface GetVmsFilter {
    name: string;
    values: string[];
}

export interface GetVmsVm {
    actionsOnNextBoots: outputs.GetVmsVmActionsOnNextBoot[];
    /**
     * The architecture of the VM (`i386` \| `x8664`).
     */
    architecture: string;
    /**
     * The block device mapping of the VM.
     */
    blockDeviceMappingsCreateds: outputs.GetVmsVmBlockDeviceMappingsCreated[];
    bootMode: string;
    bsuOptimized: boolean;
    /**
     * The idempotency token provided when launching the VM.
     */
    clientToken: string;
    /**
     * The date and time (UTC) at which the VM was created.
     */
    creationDate: string;
    /**
     * If true, you cannot delete the VM unless you change this parameter back to false.
     */
    deletionProtection: boolean;
    /**
     * The hypervisor type of the VMs (`ovm` \| `xen`).
     */
    hypervisor: string;
    /**
     * The ID of the OMI used to create the VM.
     */
    imageId: string;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * The name of the keypair used when launching the VM.
     */
    keypairName: string;
    /**
     * The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
     */
    launchNumber: number;
    /**
     * If true, nested virtualization is enabled. If false, it is disabled.
     */
    nestedVirtualization: boolean;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * (Net only) The network interface cards (NICs) the VMs are attached to.
     */
    nics: outputs.GetVmsVmNic[];
    /**
     * Indicates the operating system (OS) of the VM.
     */
    osFamily: string;
    /**
     * The performance of the VM (`medium` \| `high` \|  `highest`).
     */
    performance: string;
    placementSubregionName: string;
    placementTenancy: string;
    primaryNics: outputs.GetVmsVmPrimaryNic[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: string[];
    /**
     * The product codes associated with the OMI used to create the VM.
     */
    productCodes: string[];
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    requestId: string;
    /**
     * The reservation ID of the VM.
     */
    reservationId: string;
    /**
     * The name of the root device for the VM (for example, `/dev/sda1`).
     */
    rootDeviceName: string;
    /**
     * The type of root device used by the VM (always `bsu`).
     */
    rootDeviceType: string;
    /**
     * The IDs of the security groups for the VMs (only in the public Cloud).
     */
    securityGroupIds: string[];
    /**
     * The names of the security groups for the VMs (only in the public Cloud).
     */
    securityGroupNames: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmsVmSecurityGroup[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The reason explaining the current state of the VM.
     */
    stateReason: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
    /**
     * One or more tags associated with the VM.
     */
    tags: outputs.GetVmsVmTag[];
    /**
     * The Base64-encoded MIME user data.
     */
    userData: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.
     */
    vmInitiatedShutdownBehavior: string;
    /**
     * The type of VM. For more information, see [VM Types](https://docs.outscale.com/en/userguide/VM-Types.html).
     */
    vmType: string;
}

export interface GetVmsVmActionsOnNextBoot {
    secureBoot: string;
}

export interface GetVmsVmBlockDeviceMappingsCreated {
    /**
     * Information about the created BSU volume.
     */
    bsus: outputs.GetVmsVmBlockDeviceMappingsCreatedBsus[];
    /**
     * The name of the device.
     */
    deviceName: string;
}

export interface GetVmsVmBlockDeviceMappingsCreatedBsus {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The date and time (UTC) at which the volume was attached to the VM, in ISO 8601 date-time format.
     */
    linkDate: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * One or more tags associated with the VM.
     */
    tags?: outputs.GetVmsVmBlockDeviceMappingsCreatedBsusTag[];
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface GetVmsVmBlockDeviceMappingsCreatedBsusTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVmsVmNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNics: outputs.GetVmsVmNicLinkNic[];
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmsVmNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: outputs.GetVmsVmNicPrivateIp[];
    secondaryPrivateIpCount: number;
    /**
     * The IDs of the security groups for the VMs (only in the public Cloud).
     */
    securityGroupIds: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmsVmNicSecurityGroup[];
    securityGroupsNames: string[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
}

export interface GetVmsVmNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
}

export interface GetVmsVmNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmsVmNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmsVmNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
}

export interface GetVmsVmNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmsVmNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmsVmPrimaryNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC.
     */
    description: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNics: outputs.GetVmsVmPrimaryNicLinkNic[];
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmsVmPrimaryNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP or IPs of the NIC.
     */
    privateIps: outputs.GetVmsVmPrimaryNicPrivateIp[];
    secondaryPrivateIpCount: number;
    /**
     * The IDs of the security groups for the VMs (only in the public Cloud).
     */
    securityGroupIds: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.GetVmsVmPrimaryNicSecurityGroup[];
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
    /**
     * The ID of the Subnet for the VM.
     */
    subnetId: string;
}

export interface GetVmsVmPrimaryNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
     */
    state: string;
}

export interface GetVmsVmPrimaryNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmsVmPrimaryNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.GetVmsVmPrimaryNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The primary private IP of the VM.
     */
    privateIp: string;
}

export interface GetVmsVmPrimaryNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface GetVmsVmPrimaryNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmsVmSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface GetVmsVmTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVolumeFilter {
    name: string;
    values: string[];
}

export interface GetVolumeLinkedVolume {
    /**
     * If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The name of the device.
     */
    deviceName: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface GetVolumeTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVolumesFilter {
    name: string;
    values: string[];
}

export interface GetVolumesVolume {
    /**
     * The date and time (UTC) at which the volume was created.
     */
    creationDate: string;
    /**
     * The number of I/O operations per second (IOPS):<br />- For `io1` volumes, the number of provisioned IOPS.<br />- For `gp2` volumes, the baseline performance of the volume.
     */
    iops: number;
    /**
     * Information about your volume attachment.
     */
    linkedVolumes: outputs.GetVolumesVolumeLinkedVolume[];
    /**
     * The size of the volume, in gibibytes (GiB).
     */
    size: number;
    /**
     * The snapshot from which the volume was created.
     */
    snapshotId: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The Subregion in which the volume was created.
     */
    subregionName: string;
    /**
     * One or more tags associated with the volume.
     */
    tags: outputs.GetVolumesVolumeTag[];
    /**
     * The ID of the volume.
     */
    volumeId: string;
    /**
     * The type of the volume (`standard` \| `gp2` \| `io1`).
     */
    volumeType: string;
}

export interface GetVolumesVolumeLinkedVolume {
    /**
     * If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The name of the device.
     */
    deviceName: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface GetVolumesVolumeTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVpnConnectionFilter {
    name: string;
    values: string[];
}

export interface GetVpnConnectionRoute {
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The type of route (always `static`).
     */
    routeType: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
}

export interface GetVpnConnectionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVpnConnectionVgwTelemetry {
    /**
     * The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
     */
    acceptedRouteCount: number;
    /**
     * The date and time (UTC) of the latest state update.
     */
    lastStateChangeDate: string;
    /**
     * The IP on the OUTSCALE side of the tunnel.
     */
    outsideIpAddress: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * A description of the current state of the tunnel.
     */
    stateDescription: string;
}

export interface GetVpnConnectionsFilter {
    name: string;
    values: string[];
}

export interface GetVpnConnectionsVpnConnection {
    /**
     * Example configuration for the client gateway.
     */
    clientGatewayConfiguration: string;
    /**
     * The ID of the client gateway used on the client end of the connection.
     */
    clientGatewayId: string;
    /**
     * The type of VPN connection (always `ipsec.1`).
     */
    connectionType: string;
    /**
     * Information about one or more static routes associated with the VPN connection, if any.
     */
    routes: outputs.GetVpnConnectionsVpnConnectionRoute[];
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](https://docs.outscale.com/api#createvpnconnectionroute) and [DeleteVpnConnectionRoute](https://docs.outscale.com/api#deletevpnconnectionroute).
     */
    staticRoutesOnly?: boolean;
    /**
     * One or more tags associated with the VPN connection.
     */
    tags: outputs.GetVpnConnectionsVpnConnectionTag[];
    /**
     * Information about the current state of one or more of the VPN tunnels.
     */
    vgwTelemetries: outputs.GetVpnConnectionsVpnConnectionVgwTelemetry[];
    /**
     * The ID of the virtual gateway used on the OUTSCALE end of the connection.
     */
    virtualGatewayId: string;
    /**
     * The ID of the VPN connection.
     */
    vpnConnectionId: string;
}

export interface GetVpnConnectionsVpnConnectionRoute {
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The type of route (always `static`).
     */
    routeType: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
}

export interface GetVpnConnectionsVpnConnectionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface GetVpnConnectionsVpnConnectionVgwTelemetry {
    /**
     * The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
     */
    acceptedRouteCount: number;
    /**
     * The date and time (UTC) of the latest state update.
     */
    lastStateChangeDate: string;
    /**
     * The IP on the OUTSCALE side of the tunnel.
     */
    outsideIpAddress: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * A description of the current state of the tunnel.
     */
    stateDescription: string;
}

export interface ImageBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsus: outputs.ImageBlockDeviceMappingBsus[];
    /**
     * The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
     */
    deviceName: string;
    /**
     * The name of the virtual device (`ephemeralN`).
     */
    virtualDeviceName: string;
}

export interface ImageBlockDeviceMappingBsus {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId: string;
    /**
     * The size of the volume, in gibibytes (GiB).<br />
     * If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
     * If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
     */
    volumeSize: number;
    /**
     * The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
     * For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
     */
    volumeType: string;
}

export interface ImageExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * Information about the OOS API key.
     */
    osuApiKeys?: outputs.ImageExportTaskOsuExportOsuApiKey[];
    /**
     * The name of the OOS bucket where you want to export the object.
     */
    osuBucket: string;
    /**
     * The URL of the manifest file.
     */
    osuManifestUrl: string;
    /**
     * The prefix for the key of the OOS object.
     */
    osuPrefix?: string;
}

export interface ImageExportTaskOsuExportOsuApiKey {
    /**
     * The API key of the OOS account that enables you to access the bucket.
     */
    apiKeyId: string;
    /**
     * The secret key of the OOS account that enables you to access the bucket.
     */
    secretKey: string;
}

export interface ImageExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface ImageLaunchPermissionPermissionAdditions {
    /**
     * The account ID of one or more users to whom you want to give permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: string;
}

export interface ImageLaunchPermissionPermissionRemovals {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: string;
}

export interface ImageLaunchPermissionPermissionsToLaunch {
    /**
     * One or more account IDs that the permission is associated with.
     */
    accountIds: string[];
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `additions`) or to make the resource private (if the parent parameter is `removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: string;
}

export interface ImagePermissionsToLaunch {
    /**
     * One or more account IDs that the permission is associated with.
     */
    accountIds: string[];
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface ImageStateComment {
    /**
     * The code of the change of state.
     */
    stateCode: string;
    /**
     * A message explaining the change of state.
     */
    stateMessage: string;
}

export interface ImageTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface InternetServiceLinkTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface InternetServiceLinkTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface InternetServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface InternetServiceTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface KeypairTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface KeypairTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface LoadBalancerAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface LoadBalancerApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerAttributesAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName?: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix?: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval?: number;
}

export interface LoadBalancerAttributesApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness.
     */
    cookieName: string;
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerAttributesHealthCheck {
    /**
     * The number of seconds between two requests (between `5` and `600` both included).
     */
    checkInterval: number;
    /**
     * The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: number;
    /**
     * If you use the HTTP or HTTPS protocols, the request URL path.
     */
    path?: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: number;
    /**
     * The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: number;
}

export interface LoadBalancerAttributesListener {
    /**
     * The port on which the backend VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to backend VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The name of the policy you want to enable for the listener.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns). If this parameter is specified, you must also specify the `loadBalancerPort` parameter.
     */
    serverCertificateId: string;
}

export interface LoadBalancerAttributesLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerAttributesSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface LoadBalancerAttributesTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface LoadBalancerHealthCheck {
    /**
     * The number of seconds between two requests (between `5` and `600` both included).
     */
    checkInterval: number;
    /**
     * The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: number;
    /**
     * If you use the HTTP or HTTPS protocols, the request URL path.
     */
    path: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: number;
    /**
     * The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: number;
}

export interface LoadBalancerListener {
    /**
     * The port on which the backend VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to backend VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId?: string;
}

export interface LoadBalancerListenerRuleListener {
    /**
     * The name of the load balancer to which the listener is attached.
     */
    loadBalancerName: string;
    /**
     * The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
     */
    loadBalancerPort: number;
}

export interface LoadBalancerListenerRuleListenerRule {
    /**
     * The type of action for the rule (always `forward`).
     */
    action: string;
    /**
     * A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except `-.?`.
     */
    hostNamePattern: string;
    /**
     * The ID of the listener.
     */
    listenerId: number;
    /**
     * The ID of the listener rule.
     */
    listenerRuleId: number;
    /**
     * A human-readable name for the listener rule.
     */
    listenerRuleName: string;
    /**
     * A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except `_-.$/~&quot;'@:+?`.
     */
    pathPattern: string;
    /**
     * The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
     */
    priority: number;
}

export interface LoadBalancerLoadBalancerStickyCookiePolicy {
    /**
     * The name of the stickiness policy.
     */
    policyName: string;
}

export interface LoadBalancerPolicyAccessLog {
    /**
     * If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osuBucketName` parameter is required.
     */
    isEnabled: boolean;
    /**
     * The name of the OOS bucket for the access logs.
     */
    osuBucketName: string;
    /**
     * The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
     */
    osuBucketPrefix: string;
    /**
     * The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
     */
    publicationInterval: number;
}

export interface LoadBalancerPolicyApplicationStickyCookiePolicy {
    /**
     * The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
     */
    cookieName: string;
    /**
     * The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
     */
    policyName: string;
}

export interface LoadBalancerPolicyHealthCheck {
    /**
     * The number of seconds between two requests (between `5` and `600` both included).
     */
    checkInterval: number;
    /**
     * The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
     */
    healthyThreshold: number;
    /**
     * If you use the HTTP or HTTPS protocols, the request URL path.
     */
    path: string;
    /**
     * The port number (between `1` and `65535`, both included).
     */
    port: number;
    /**
     * The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    protocol: string;
    /**
     * The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
     */
    timeout: number;
    /**
     * The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
     */
    unhealthyThreshold: number;
}

export interface LoadBalancerPolicyListener {
    /**
     * The port on which the backend VM is listening (between `1` and `65535`, both included).
     */
    backendPort: number;
    /**
     * The protocol for routing traffic to backend VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    backendProtocol: string;
    /**
     * The port on which the load balancer is listening (between `1` and `65535`, both included).
     */
    loadBalancerPort: number;
    /**
     * The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
     */
    loadBalancerProtocol: string;
    /**
     * The names of the policies. If there are no policies enabled, the list is empty.
     */
    policyNames: string[];
    /**
     * The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
     */
    serverCertificateId: string;
}

export interface LoadBalancerPolicyLoadBalancerStickyCookiePolicy {
    /**
     * The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
     */
    policyName: string;
}

export interface LoadBalancerPolicySourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface LoadBalancerPolicyTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface LoadBalancerSourceSecurityGroup {
    /**
     * The account ID of the owner of the security group.
     */
    securityGroupAccountId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface LoadBalancerTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key?: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value?: string;
}

export interface LoadBalancerVmsTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface MainRouteTableLinkTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface NatServicePublicIp {
    /**
     * The public IP associated with the NAT service.
     */
    publicIp: string;
    /**
     * The allocation ID of the public IP to associate with the NAT service.<br />
     * If the public IP is already associated with another resource, you must first disassociate it.
     */
    publicIpId: string;
}

export interface NatServiceTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetAccessPointTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetAccessPointTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface NetAttributesTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetAttributesTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface NetPeeringAcceptationAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringAcceptationSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringAcceptationState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface NetPeeringAcceptationTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetPeeringAcceptationTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface NetPeeringAccepterNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringSourceNet {
    /**
     * The account ID of the owner of the source Net.
     */
    accountId: string;
    /**
     * The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRange: string;
    /**
     * The ID of the source Net.
     */
    netId: string;
}

export interface NetPeeringState {
    /**
     * Additional information about the state of the Net peering.
     */
    message: string;
    /**
     * The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
     */
    name: string;
}

export interface NetPeeringTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetPeeringTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface NetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface NetTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface NicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: string;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: number;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
}

export interface NicLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface NicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP association.
     */
    linkPublicIps: outputs.NicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface NicPrivateIpLinkPublicIp {
    /**
     * (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
     */
    linkPublicIpId: string;
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP associated with the NIC.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
    /**
     * The allocation ID of the public IP.
     */
    publicIpId: string;
}

export interface NicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface NicTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface OutboundRuleRule {
    fromPortRange?: number;
    ipProtocol: string;
    ipRanges?: string[];
    securityGroupsMembers: outputs.OutboundRuleRuleSecurityGroupsMember[];
    serviceIds?: string[];
    toPortRange?: number;
}

export interface OutboundRuleRuleSecurityGroupsMember {
    accountId?: string;
    securityGroupId?: string;
    securityGroupName?: string;
}

export interface PublicIpLinkTag {
    key: string;
    value: string;
}

export interface PublicIpTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface RouteTableLinkRouteTable {
    /**
     * The ID of the association between the route table and the Net or Subnet.
     */
    linkRouteTableId: string;
    /**
     * If true, the route table is the main one.
     */
    main: boolean;
    /**
     * The ID of the Net for which you want to create a route table.
     */
    netId: string;
    /**
     * The ID of the route table.
     */
    routeTableId: string;
    /**
     * The ID of the Subnet, if the route table is explicitly linked to a Subnet.
     */
    subnetId: string;
}

export interface RouteTableLinkTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface RouteTableRoute {
    /**
     * The method used to create the route.
     */
    creationMethod: string;
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The ID of the OUTSCALE service.
     */
    destinationServiceId: string;
    /**
     * The ID of the internet service or virtual gateway attached to the Net.
     */
    gatewayId: string;
    /**
     * The ID of a NAT service attached to the Net.
     */
    natServiceId: string;
    /**
     * The ID of the Net access point.
     */
    netAccessPointId: string;
    /**
     * The ID of the Net peering.
     */
    netPeeringId: string;
    /**
     * The ID of the NIC.
     */
    nicId: string;
    /**
     * The state of a route in the route table (always `active`).
     */
    state: string;
    /**
     * The account ID of the owner of the VM.
     */
    vmAccountId: string;
    /**
     * The ID of a VM specified in a route in the table.
     */
    vmId: string;
}

export interface RouteTableRoutePropagatingVirtualGateway {
    /**
     * The ID of the virtual gateway.
     */
    virtualGatewayId: string;
}

export interface RouteTableTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface RouteTableTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface RouteTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface SecurityGroupInboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers?: {[key: string]: string}[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface SecurityGroupOutboundRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers?: {[key: string]: string}[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange: number;
}

export interface SecurityGroupRuleRule {
    /**
     * The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
     */
    fromPortRange?: number;
    /**
     * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
     */
    ipProtocol: string;
    /**
     * One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
     */
    ipRanges?: string[];
    /**
     * Information about one or more source or destination security groups.
     */
    securityGroupsMembers: outputs.SecurityGroupRuleRuleSecurityGroupsMember[];
    /**
     * One or more service IDs to allow traffic from a Net to access the corresponding OUTSCALE services. For more information, see [ReadNetAccessPointServices](https://docs.outscale.com/api#readnetaccesspointservices).
     */
    serviceIds?: string[];
    /**
     * The end of the port range for the TCP and UDP protocols, or an ICMP code number.
     */
    toPortRange?: number;
}

export interface SecurityGroupRuleRuleSecurityGroupsMember {
    /**
     * The account ID that owns the source or destination security group.
     */
    accountId?: string;
    /**
     * The ID of a source or destination security group that you want to link to the security group of the rule.
     */
    securityGroupId?: string;
    /**
     * (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
     */
    securityGroupName?: string;
}

export interface SecurityGroupTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SnapshotAttributesPermissionsToCreateVolumeAdditions {
    /**
     * The account ID of one or more users to whom you want to give permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: boolean;
}

export interface SnapshotAttributesPermissionsToCreateVolumeRemoval {
    /**
     * The account ID of one or more users from whom you want to remove permissions.
     */
    accountIds?: string[];
    /**
     * If true, the resource is public. If false, the resource is private.
     */
    globalPermission?: boolean;
}

export interface SnapshotExportTaskOsuExport {
    /**
     * The format of the export disk (`qcow2` \| `raw`).
     */
    diskImageFormat: string;
    /**
     * Information about the OOS API key.
     */
    osuApiKeys?: outputs.SnapshotExportTaskOsuExportOsuApiKey[];
    /**
     * The name of the OOS bucket where you want to export the object.
     */
    osuBucket: string;
    /**
     * The prefix for the key of the OOS object.
     */
    osuPrefix: string;
}

export interface SnapshotExportTaskOsuExportOsuApiKey {
    /**
     * The API key of the OOS account that enables you to access the bucket.
     */
    apiKeyId: string;
    /**
     * The secret key of the OOS account that enables you to access the bucket.
     */
    secretKey: string;
}

export interface SnapshotExportTaskTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SnapshotPermissionsToCreateVolume {
    /**
     * The account ID of the owner of the snapshot.
     */
    accountId: string;
    /**
     * A global permission for all accounts.<br />
     * (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
     * (Response) If true, the resource is public. If false, the resource is private.
     */
    globalPermission: boolean;
}

export interface SnapshotTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SubnetTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface SubnetTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface TagTag {
    key: string;
    resourceId: string;
    resourceType: string;
    value: string;
}

export interface UserGroupPolicy {
    /**
     * The date and time (UTC) of creation of the user group.
     */
    creationDate: string;
    /**
     * The ID of a policy version that you want to make the default one (the active one).
     */
    defaultVersionId: string;
    /**
     * The date and time (UTC) of the last modification of the user group.
     */
    lastModificationDate: string;
    policyId: string;
    policyName: string;
    policyOrn: string;
}

export interface UserGroupUser {
    /**
     * The date and time (UTC) of creation of the user group.
     */
    creationDate: string;
    /**
     * The date and time (UTC) of the last modification of the user group.
     */
    lastModificationDate: string;
    /**
     * The path to the group. If not specified, it is set to a slash (`/`).
     */
    path: string;
    userId: string;
    userName: string;
}

export interface UserPolicy {
    /**
     * The date and time (UTC) of creation of the EIM user.
     */
    creationDate: string;
    /**
     * The ID of a policy version that you want to make the default one (the active one).
     */
    defaultVersionId: string;
    /**
     * The date and time (UTC) of the last modification of the EIM user.
     */
    lastModificationDate: string;
    policyId: string;
    policyName: string;
    policyOrn: string;
}

export interface VirtualGatewayLinkNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which you want to attach the virtual gateway.
     */
    netId: string;
    /**
     * The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
     */
    state: string;
}

export interface VirtualGatewayNetToVirtualGatewayLink {
    /**
     * The ID of the Net to which the virtual gateway is attached.
     */
    netId: string;
    /**
     * The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
     */
    state: string;
}

export interface VirtualGatewayTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VmActionsOnNextBoot {
    /**
     * One action to perform on the next boot of the VM (`enable` | `disable` | `setup-mode` |`none`). For more information, see [About Secure Boot](https://docs.outscale.com/en/userguide/About-Secure-Boot.html#_secure_boot_actions).
     */
    secureBoot: string;
}

export interface VmBlockDeviceMapping {
    /**
     * Information about the BSU volume to create.
     */
    bsu: outputs.VmBlockDeviceMappingBsu;
    /**
     * The name of the device.
     */
    deviceName?: string;
    noDevice?: string;
    virtualDeviceName?: string;
}

export interface VmBlockDeviceMappingBsu {
    /**
     * By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
     */
    iops?: number;
    /**
     * The ID of the snapshot used to create the volume.
     */
    snapshotId?: string;
    /**
     * One or more tags associated with the VM.
     */
    tags?: outputs.VmBlockDeviceMappingBsuTag[];
    /**
     * The size of the volume, in gibibytes (GiB).
     */
    volumeSize?: number;
    volumeType?: string;
}

export interface VmBlockDeviceMappingBsuTag {
    /**
     * The key of the tag with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VmBlockDeviceMappingsCreated {
    /**
     * Information about the created BSU volume.
     */
    bsus: outputs.VmBlockDeviceMappingsCreatedBsus[];
    /**
     * The name of the device.
     */
    deviceName: string;
}

export interface VmBlockDeviceMappingsCreatedBsus {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The date and time (UTC) at which the volume was attached to the VM, in ISO 8601 date-time format.
     */
    linkDate: string;
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
    /**
     * A tag to add to this resource. You can specify this argument several times.
     */
    tags?: outputs.VmBlockDeviceMappingsCreatedBsusTag[];
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface VmBlockDeviceMappingsCreatedBsusTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VmNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC, if you are creating a NIC when creating the VM.
     */
    description: string;
    /**
     * The index of the VM device for the NIC attachment (between `1` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNics: outputs.VmNicLinkNic[];
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.VmNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC, if you are attaching an existing NIC when creating a VM.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
     */
    privateIps: outputs.VmNicPrivateIp[];
    /**
     * The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `privateIps` parameter.
     */
    secondaryPrivateIpCount: number;
    /**
     * One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
     */
    securityGroupIds?: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.VmNicSecurityGroup[];
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
    /**
     * The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
     */
    subnetId: string;
}

export interface VmNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
}

export interface VmNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface VmNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.VmNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface VmNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface VmNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface VmPrimaryNic {
    /**
     * The account ID of the owner of the NIC.
     */
    accountId: string;
    /**
     * If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
     */
    deleteOnVmDeletion: boolean;
    /**
     * The description of the NIC, if you are creating a NIC when creating the VM.
     */
    description: string;
    /**
     * The index of the VM device for the NIC attachment (must be `0`). This parameter is required if you create a NIC when creating the VM.
     */
    deviceNumber: number;
    /**
     * (Net only) If true, the source/destination check is enabled. If false, it is disabled.
     */
    isSourceDestChecked: boolean;
    /**
     * Information about the network interface card (NIC).
     */
    linkNics: outputs.VmPrimaryNicLinkNic[];
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.VmPrimaryNicLinkPublicIp[];
    /**
     * The Media Access Control (MAC) address of the NIC.
     */
    macAddress: string;
    /**
     * The ID of the Net for the NIC.
     */
    netId: string;
    /**
     * The ID of the NIC, if you are attaching an existing NIC when creating a VM.
     */
    nicId: string;
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
     */
    privateIps: outputs.VmPrimaryNicPrivateIp[];
    /**
     * The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `privateIps` parameter.
     */
    secondaryPrivateIpCount: number;
    /**
     * One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
     */
    securityGroupIds?: string[];
    /**
     * One or more security groups associated with the VM.
     */
    securityGroups: outputs.VmPrimaryNicSecurityGroup[];
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
    /**
     * The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
     */
    subnetId: string;
}

export interface VmPrimaryNicLinkNic {
    /**
     * If true, the NIC is deleted when the VM is terminated.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The device index for the NIC attachment (between `1` and `7`, both included).
     */
    deviceNumber: string;
    /**
     * The ID of the NIC to attach.
     */
    linkNicId: string;
    /**
     * The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vmInitiatedShutdownBehavior` argument.
     */
    state: string;
}

export interface VmPrimaryNicLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface VmPrimaryNicPrivateIp {
    /**
     * If true, the IP is the primary private IP of the NIC.
     */
    isPrimary: boolean;
    /**
     * Information about the public IP associated with the NIC.
     */
    linkPublicIps: outputs.VmPrimaryNicPrivateIpLinkPublicIp[];
    /**
     * The name of the private DNS.
     */
    privateDnsName: string;
    /**
     * The private IP of the NIC.
     */
    privateIp: string;
}

export interface VmPrimaryNicPrivateIpLinkPublicIp {
    /**
     * The name of the public DNS.
     */
    publicDnsName: string;
    /**
     * The public IP of the VM.
     */
    publicIp: string;
    /**
     * The account ID of the owner of the public IP.
     */
    publicIpAccountId: string;
}

export interface VmPrimaryNicSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface VmSecurityGroup {
    /**
     * The ID of the security group.
     */
    securityGroupId: string;
    /**
     * The name of the security group.
     */
    securityGroupName: string;
}

export interface VmTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VolumeLinkTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface VolumeLinkedVolume {
    /**
     * If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
     */
    deleteOnVmDeletion: boolean;
    /**
     * The name of the device.
     */
    deviceName: string;
    /**
     * The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
     */
    state: string;
    /**
     * The ID of the VM.
     */
    vmId: string;
    /**
     * The ID of the volume.
     */
    volumeId: string;
}

export interface VolumeTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VolumeTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface VpnConnectionRoute {
    /**
     * The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
     */
    destinationIpRange: string;
    /**
     * The type of route (always `static`).
     */
    routeType: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
}

export interface VpnConnectionTag {
    /**
     * The key of the tag, with a minimum of 1 character.
     */
    key: string;
    /**
     * The value of the tag, between 0 and 255 characters.
     */
    value: string;
}

export interface VpnConnectionVgwTelemetry {
    /**
     * The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
     */
    acceptedRouteCount: number;
    /**
     * The date and time (UTC) of the latest state update.
     */
    lastStateChangeDate: string;
    /**
     * The IP on the OUTSCALE side of the tunnel.
     */
    outsideIpAddress: string;
    /**
     * The state of the IPSEC tunnel (`UP` \| `DOWN`).
     */
    state: string;
    /**
     * A description of the current state of the tunnel.
     */
    stateDescription: string;
}

export namespace config {
    export interface Endpoints {
        /**
         * Use this to override the default service endpoint URL
         */
        api?: string;
    }

}
