// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package outscale

import (
	"context"
	"reflect"

	"errors"
	"github.com/outscale/pulumi-outscale/sdk/go/outscale/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a volume link.
//
// For more information on this resource, see the [User Guide](https://docs.outscale.com/en/userguide/About-Volumes.html).\
// For more information on this resource actions, see the [API documentation](https://docs.outscale.com/api#3ds-outscale-api-volume).
//
// ## Example Usage
//
// ### Required resources
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/outscale/pulumi-outscale/sdk/go/outscale"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := outscale.NewVolume(ctx, "volume01", &outscale.VolumeArgs{
//				SubregionName: pulumi.Sprintf("%va", region),
//				Size:          pulumi.Int(40),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = outscale.NewVm(ctx, "vm01", &outscale.VmArgs{
//				ImageId:     pulumi.Any(imageId),
//				VmType:      pulumi.Any(vmType),
//				KeypairName: pulumi.Any(keypairName),
//				SecurityGroupIds: pulumi.StringArray{
//					securityGroupId,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Link a volume to a VM
//
// ```go
// package main
//
// import (
//
//	"github.com/outscale/pulumi-outscale/sdk/go/outscale"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := outscale.NewVolumeLink(ctx, "volume_link01", &outscale.VolumeLinkArgs{
//				DeviceName: pulumi.String("/dev/xvdc"),
//				VolumeId:   pulumi.Any(volume01.Id),
//				VmId:       pulumi.Any(vm01.Id),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// A volume link can be imported using a volume ID. For example:
//
// ```sh
// $ pulumi import outscale:index/volumeLink:VolumeLink ImportedVolumeLink vol-12345678
// ```
type VolumeLink struct {
	pulumi.CustomResourceState

	// If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion pulumi.BoolOutput `pulumi:"deleteOnVmDeletion"`
	// The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName  pulumi.StringOutput `pulumi:"deviceName"`
	ForceUnlink pulumi.BoolOutput   `pulumi:"forceUnlink"`
	RequestId   pulumi.StringOutput `pulumi:"requestId"`
	// The state of the attachment of the volume (`attaching` | `detaching` | `attached` | `detached`).
	State    pulumi.StringOutput         `pulumi:"state"`
	Timeouts VolumeLinkTimeoutsPtrOutput `pulumi:"timeouts"`
	// The ID of the VM you want to attach the volume to.
	VmId pulumi.StringOutput `pulumi:"vmId"`
	// The ID of the volume you want to attach.
	VolumeId pulumi.StringOutput `pulumi:"volumeId"`
}

// NewVolumeLink registers a new resource with the given unique name, arguments, and options.
func NewVolumeLink(ctx *pulumi.Context,
	name string, args *VolumeLinkArgs, opts ...pulumi.ResourceOption) (*VolumeLink, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DeviceName == nil {
		return nil, errors.New("invalid value for required argument 'DeviceName'")
	}
	if args.VmId == nil {
		return nil, errors.New("invalid value for required argument 'VmId'")
	}
	if args.VolumeId == nil {
		return nil, errors.New("invalid value for required argument 'VolumeId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VolumeLink
	err := ctx.RegisterResource("outscale:index/volumeLink:VolumeLink", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVolumeLink gets an existing VolumeLink resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVolumeLink(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VolumeLinkState, opts ...pulumi.ResourceOption) (*VolumeLink, error) {
	var resource VolumeLink
	err := ctx.ReadResource("outscale:index/volumeLink:VolumeLink", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VolumeLink resources.
type volumeLinkState struct {
	// If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `pulumi:"deleteOnVmDeletion"`
	// The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName  *string `pulumi:"deviceName"`
	ForceUnlink *bool   `pulumi:"forceUnlink"`
	RequestId   *string `pulumi:"requestId"`
	// The state of the attachment of the volume (`attaching` | `detaching` | `attached` | `detached`).
	State    *string             `pulumi:"state"`
	Timeouts *VolumeLinkTimeouts `pulumi:"timeouts"`
	// The ID of the VM you want to attach the volume to.
	VmId *string `pulumi:"vmId"`
	// The ID of the volume you want to attach.
	VolumeId *string `pulumi:"volumeId"`
}

type VolumeLinkState struct {
	// If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion pulumi.BoolPtrInput
	// The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName  pulumi.StringPtrInput
	ForceUnlink pulumi.BoolPtrInput
	RequestId   pulumi.StringPtrInput
	// The state of the attachment of the volume (`attaching` | `detaching` | `attached` | `detached`).
	State    pulumi.StringPtrInput
	Timeouts VolumeLinkTimeoutsPtrInput
	// The ID of the VM you want to attach the volume to.
	VmId pulumi.StringPtrInput
	// The ID of the volume you want to attach.
	VolumeId pulumi.StringPtrInput
}

func (VolumeLinkState) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeLinkState)(nil)).Elem()
}

type volumeLinkArgs struct {
	// The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName  string              `pulumi:"deviceName"`
	ForceUnlink *bool               `pulumi:"forceUnlink"`
	Timeouts    *VolumeLinkTimeouts `pulumi:"timeouts"`
	// The ID of the VM you want to attach the volume to.
	VmId string `pulumi:"vmId"`
	// The ID of the volume you want to attach.
	VolumeId string `pulumi:"volumeId"`
}

// The set of arguments for constructing a VolumeLink resource.
type VolumeLinkArgs struct {
	// The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName  pulumi.StringInput
	ForceUnlink pulumi.BoolPtrInput
	Timeouts    VolumeLinkTimeoutsPtrInput
	// The ID of the VM you want to attach the volume to.
	VmId pulumi.StringInput
	// The ID of the volume you want to attach.
	VolumeId pulumi.StringInput
}

func (VolumeLinkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeLinkArgs)(nil)).Elem()
}

type VolumeLinkInput interface {
	pulumi.Input

	ToVolumeLinkOutput() VolumeLinkOutput
	ToVolumeLinkOutputWithContext(ctx context.Context) VolumeLinkOutput
}

func (*VolumeLink) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeLink)(nil)).Elem()
}

func (i *VolumeLink) ToVolumeLinkOutput() VolumeLinkOutput {
	return i.ToVolumeLinkOutputWithContext(context.Background())
}

func (i *VolumeLink) ToVolumeLinkOutputWithContext(ctx context.Context) VolumeLinkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeLinkOutput)
}

// VolumeLinkArrayInput is an input type that accepts VolumeLinkArray and VolumeLinkArrayOutput values.
// You can construct a concrete instance of `VolumeLinkArrayInput` via:
//
//	VolumeLinkArray{ VolumeLinkArgs{...} }
type VolumeLinkArrayInput interface {
	pulumi.Input

	ToVolumeLinkArrayOutput() VolumeLinkArrayOutput
	ToVolumeLinkArrayOutputWithContext(context.Context) VolumeLinkArrayOutput
}

type VolumeLinkArray []VolumeLinkInput

func (VolumeLinkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VolumeLink)(nil)).Elem()
}

func (i VolumeLinkArray) ToVolumeLinkArrayOutput() VolumeLinkArrayOutput {
	return i.ToVolumeLinkArrayOutputWithContext(context.Background())
}

func (i VolumeLinkArray) ToVolumeLinkArrayOutputWithContext(ctx context.Context) VolumeLinkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeLinkArrayOutput)
}

// VolumeLinkMapInput is an input type that accepts VolumeLinkMap and VolumeLinkMapOutput values.
// You can construct a concrete instance of `VolumeLinkMapInput` via:
//
//	VolumeLinkMap{ "key": VolumeLinkArgs{...} }
type VolumeLinkMapInput interface {
	pulumi.Input

	ToVolumeLinkMapOutput() VolumeLinkMapOutput
	ToVolumeLinkMapOutputWithContext(context.Context) VolumeLinkMapOutput
}

type VolumeLinkMap map[string]VolumeLinkInput

func (VolumeLinkMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VolumeLink)(nil)).Elem()
}

func (i VolumeLinkMap) ToVolumeLinkMapOutput() VolumeLinkMapOutput {
	return i.ToVolumeLinkMapOutputWithContext(context.Background())
}

func (i VolumeLinkMap) ToVolumeLinkMapOutputWithContext(ctx context.Context) VolumeLinkMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeLinkMapOutput)
}

type VolumeLinkOutput struct{ *pulumi.OutputState }

func (VolumeLinkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeLink)(nil)).Elem()
}

func (o VolumeLinkOutput) ToVolumeLinkOutput() VolumeLinkOutput {
	return o
}

func (o VolumeLinkOutput) ToVolumeLinkOutputWithContext(ctx context.Context) VolumeLinkOutput {
	return o
}

// If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
func (o VolumeLinkOutput) DeleteOnVmDeletion() pulumi.BoolOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.BoolOutput { return v.DeleteOnVmDeletion }).(pulumi.BoolOutput)
}

// The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
func (o VolumeLinkOutput) DeviceName() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.StringOutput { return v.DeviceName }).(pulumi.StringOutput)
}

func (o VolumeLinkOutput) ForceUnlink() pulumi.BoolOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.BoolOutput { return v.ForceUnlink }).(pulumi.BoolOutput)
}

func (o VolumeLinkOutput) RequestId() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.StringOutput { return v.RequestId }).(pulumi.StringOutput)
}

// The state of the attachment of the volume (`attaching` | `detaching` | `attached` | `detached`).
func (o VolumeLinkOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

func (o VolumeLinkOutput) Timeouts() VolumeLinkTimeoutsPtrOutput {
	return o.ApplyT(func(v *VolumeLink) VolumeLinkTimeoutsPtrOutput { return v.Timeouts }).(VolumeLinkTimeoutsPtrOutput)
}

// The ID of the VM you want to attach the volume to.
func (o VolumeLinkOutput) VmId() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.StringOutput { return v.VmId }).(pulumi.StringOutput)
}

// The ID of the volume you want to attach.
func (o VolumeLinkOutput) VolumeId() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeLink) pulumi.StringOutput { return v.VolumeId }).(pulumi.StringOutput)
}

type VolumeLinkArrayOutput struct{ *pulumi.OutputState }

func (VolumeLinkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VolumeLink)(nil)).Elem()
}

func (o VolumeLinkArrayOutput) ToVolumeLinkArrayOutput() VolumeLinkArrayOutput {
	return o
}

func (o VolumeLinkArrayOutput) ToVolumeLinkArrayOutputWithContext(ctx context.Context) VolumeLinkArrayOutput {
	return o
}

func (o VolumeLinkArrayOutput) Index(i pulumi.IntInput) VolumeLinkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VolumeLink {
		return vs[0].([]*VolumeLink)[vs[1].(int)]
	}).(VolumeLinkOutput)
}

type VolumeLinkMapOutput struct{ *pulumi.OutputState }

func (VolumeLinkMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VolumeLink)(nil)).Elem()
}

func (o VolumeLinkMapOutput) ToVolumeLinkMapOutput() VolumeLinkMapOutput {
	return o
}

func (o VolumeLinkMapOutput) ToVolumeLinkMapOutputWithContext(ctx context.Context) VolumeLinkMapOutput {
	return o
}

func (o VolumeLinkMapOutput) MapIndex(k pulumi.StringInput) VolumeLinkOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VolumeLink {
		return vs[0].(map[string]*VolumeLink)[vs[1].(string)]
	}).(VolumeLinkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeLinkInput)(nil)).Elem(), &VolumeLink{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeLinkArrayInput)(nil)).Elem(), VolumeLinkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeLinkMapInput)(nil)).Elem(), VolumeLinkMap{})
	pulumi.RegisterOutputType(VolumeLinkOutput{})
	pulumi.RegisterOutputType(VolumeLinkArrayOutput{})
	pulumi.RegisterOutputType(VolumeLinkMapOutput{})
}
