# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['LoadBalancerArgs', 'LoadBalancer']

@pulumi.input_type
class LoadBalancerArgs:
    def __init__(__self__, *,
                 listeners: pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]],
                 load_balancer_name: pulumi.Input[str],
                 access_logs: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]]] = None,
                 backend_vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_type: Optional[pulumi.Input[str]] = None,
                 public_ip: Optional[pulumi.Input[str]] = None,
                 secured_cookies: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subregion_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]]] = None):
        """
        The set of arguments for constructing a LoadBalancer resource.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]] listeners: One or more listeners to create.
        :param pulumi.Input[str] load_balancer_name: The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]] access_logs: Information about access logs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_vm_ids: One or more IDs of back-end VMs for the load balancer.
        :param pulumi.Input[str] load_balancer_type: The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        :param pulumi.Input[str] public_ip: (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        :param pulumi.Input[bool] secured_cookies: Whether secure cookies are enabled for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subregion_names: (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]] tags: A tag to add to this resource. You can specify this argument several times.
        """
        pulumi.set(__self__, "listeners", listeners)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if access_logs is not None:
            pulumi.set(__self__, "access_logs", access_logs)
        if backend_vm_ids is not None:
            pulumi.set(__self__, "backend_vm_ids", backend_vm_ids)
        if load_balancer_type is not None:
            pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if secured_cookies is not None:
            pulumi.set(__self__, "secured_cookies", secured_cookies)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if subregion_names is not None:
            pulumi.set(__self__, "subregion_names", subregion_names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def listeners(self) -> pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]]:
        """
        One or more listeners to create.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> pulumi.Input[str]:
        """
        The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        """
        return pulumi.get(self, "load_balancer_name")

    @load_balancer_name.setter
    def load_balancer_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_name", value)

    @property
    @pulumi.getter(name="accessLogs")
    def access_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]]]:
        """
        Information about access logs.
        """
        return pulumi.get(self, "access_logs")

    @access_logs.setter
    def access_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]]]):
        pulumi.set(self, "access_logs", value)

    @property
    @pulumi.getter(name="backendVmIds")
    def backend_vm_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more IDs of back-end VMs for the load balancer.
        """
        return pulumi.get(self, "backend_vm_ids")

    @backend_vm_ids.setter
    def backend_vm_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_vm_ids", value)

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        """
        return pulumi.get(self, "load_balancer_type")

    @load_balancer_type.setter
    def load_balancer_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_type", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter(name="securedCookies")
    def secured_cookies(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether secure cookies are enabled for the load balancer.
        """
        return pulumi.get(self, "secured_cookies")

    @secured_cookies.setter
    def secured_cookies(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secured_cookies", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="subregionNames")
    def subregion_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        """
        return pulumi.get(self, "subregion_names")

    @subregion_names.setter
    def subregion_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subregion_names", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]]]:
        """
        A tag to add to this resource. You can specify this argument several times.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class _LoadBalancerState:
    def __init__(__self__, *,
                 access_logs: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]]] = None,
                 application_sticky_cookie_policies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerApplicationStickyCookiePolicyArgs']]]] = None,
                 backend_vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_name: Optional[pulumi.Input[str]] = None,
                 health_checks: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerHealthCheckArgs']]]] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]]] = None,
                 load_balancer_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_sticky_cookie_policies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerStickyCookiePolicyArgs']]]] = None,
                 load_balancer_type: Optional[pulumi.Input[str]] = None,
                 net_id: Optional[pulumi.Input[str]] = None,
                 public_ip: Optional[pulumi.Input[str]] = None,
                 request_id: Optional[pulumi.Input[str]] = None,
                 secured_cookies: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerSourceSecurityGroupArgs']]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subregion_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]]] = None):
        """
        Input properties used for looking up and filtering LoadBalancer resources.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]] access_logs: Information about access logs.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerApplicationStickyCookiePolicyArgs']]] application_sticky_cookie_policies: The stickiness policies defined for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_vm_ids: One or more IDs of back-end VMs for the load balancer.
        :param pulumi.Input[str] dns_name: The DNS name of the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerHealthCheckArgs']]] health_checks: Information about the health check configuration.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]] listeners: One or more listeners to create.
        :param pulumi.Input[str] load_balancer_name: The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerStickyCookiePolicyArgs']]] load_balancer_sticky_cookie_policies: The policies defined for the load balancer.
        :param pulumi.Input[str] load_balancer_type: The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        :param pulumi.Input[str] net_id: The ID of the Net for the load balancer.
        :param pulumi.Input[str] public_ip: (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        :param pulumi.Input[bool] secured_cookies: Whether secure cookies are enabled for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerSourceSecurityGroupArgs']]] source_security_groups: Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
               To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subregion_names: (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]] tags: A tag to add to this resource. You can specify this argument several times.
        """
        if access_logs is not None:
            pulumi.set(__self__, "access_logs", access_logs)
        if application_sticky_cookie_policies is not None:
            pulumi.set(__self__, "application_sticky_cookie_policies", application_sticky_cookie_policies)
        if backend_vm_ids is not None:
            pulumi.set(__self__, "backend_vm_ids", backend_vm_ids)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if health_checks is not None:
            pulumi.set(__self__, "health_checks", health_checks)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if load_balancer_name is not None:
            pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if load_balancer_sticky_cookie_policies is not None:
            pulumi.set(__self__, "load_balancer_sticky_cookie_policies", load_balancer_sticky_cookie_policies)
        if load_balancer_type is not None:
            pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if request_id is not None:
            pulumi.set(__self__, "request_id", request_id)
        if secured_cookies is not None:
            pulumi.set(__self__, "secured_cookies", secured_cookies)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_security_groups is not None:
            pulumi.set(__self__, "source_security_groups", source_security_groups)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if subregion_names is not None:
            pulumi.set(__self__, "subregion_names", subregion_names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLogs")
    def access_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]]]:
        """
        Information about access logs.
        """
        return pulumi.get(self, "access_logs")

    @access_logs.setter
    def access_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerAccessLogArgs']]]]):
        pulumi.set(self, "access_logs", value)

    @property
    @pulumi.getter(name="applicationStickyCookiePolicies")
    def application_sticky_cookie_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerApplicationStickyCookiePolicyArgs']]]]:
        """
        The stickiness policies defined for the load balancer.
        """
        return pulumi.get(self, "application_sticky_cookie_policies")

    @application_sticky_cookie_policies.setter
    def application_sticky_cookie_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerApplicationStickyCookiePolicyArgs']]]]):
        pulumi.set(self, "application_sticky_cookie_policies", value)

    @property
    @pulumi.getter(name="backendVmIds")
    def backend_vm_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more IDs of back-end VMs for the load balancer.
        """
        return pulumi.get(self, "backend_vm_ids")

    @backend_vm_ids.setter
    def backend_vm_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_vm_ids", value)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS name of the load balancer.
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerHealthCheckArgs']]]]:
        """
        Information about the health check configuration.
        """
        return pulumi.get(self, "health_checks")

    @health_checks.setter
    def health_checks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerHealthCheckArgs']]]]):
        pulumi.set(self, "health_checks", value)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]]]:
        """
        One or more listeners to create.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerListenerArgs']]]]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> Optional[pulumi.Input[str]]:
        """
        The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        """
        return pulumi.get(self, "load_balancer_name")

    @load_balancer_name.setter
    def load_balancer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_name", value)

    @property
    @pulumi.getter(name="loadBalancerStickyCookiePolicies")
    def load_balancer_sticky_cookie_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerStickyCookiePolicyArgs']]]]:
        """
        The policies defined for the load balancer.
        """
        return pulumi.get(self, "load_balancer_sticky_cookie_policies")

    @load_balancer_sticky_cookie_policies.setter
    def load_balancer_sticky_cookie_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerStickyCookiePolicyArgs']]]]):
        pulumi.set(self, "load_balancer_sticky_cookie_policies", value)

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        """
        return pulumi.get(self, "load_balancer_type")

    @load_balancer_type.setter
    def load_balancer_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_type", value)

    @property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Net for the load balancer.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_id", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter(name="requestId")
    def request_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "request_id")

    @request_id.setter
    def request_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_id", value)

    @property
    @pulumi.getter(name="securedCookies")
    def secured_cookies(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether secure cookies are enabled for the load balancer.
        """
        return pulumi.get(self, "secured_cookies")

    @secured_cookies.setter
    def secured_cookies(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secured_cookies", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="sourceSecurityGroups")
    def source_security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerSourceSecurityGroupArgs']]]]:
        """
        Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
        To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        """
        return pulumi.get(self, "source_security_groups")

    @source_security_groups.setter
    def source_security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerSourceSecurityGroupArgs']]]]):
        pulumi.set(self, "source_security_groups", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="subregionNames")
    def subregion_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        """
        return pulumi.get(self, "subregion_names")

    @subregion_names.setter
    def subregion_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subregion_names", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]]]:
        """
        A tag to add to this resource. You can specify this argument several times.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerTagArgs']]]]):
        pulumi.set(self, "tags", value)


class LoadBalancer(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 access_logs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerAccessLogArgs']]]]] = None,
                 backend_vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerListenerArgs']]]]] = None,
                 load_balancer_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_type: Optional[pulumi.Input[str]] = None,
                 public_ip: Optional[pulumi.Input[str]] = None,
                 secured_cookies: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subregion_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerTagArgs']]]]] = None,
                 __props__=None):
        """
        Manages a load balancer.

        For more information on this resource, see the [User Guide](https://docs.outscale.com/en/userguide/About-Load-Balancers.html).\\
        For more information on this resource actions, see the [API documentation](https://docs.outscale.com/api#3ds-outscale-api-loadbalancer).

        ## Example Usage
        ### Create a load balancer in the public Cloud

        ```python
        import pulumi
        import pulumi_outscale as outscale

        load_balancer01 = outscale.LoadBalancer("loadBalancer01",
            listeners=[outscale.LoadBalancerListenerArgs(
                backend_port=8080,
                backend_protocol="HTTP",
                load_balancer_port=8080,
                load_balancer_protocol="HTTP",
            )],
            load_balancer_name="terraform-public-load-balancer",
            subregion_names=[f"{var['region']}a"],
            tags=[outscale.LoadBalancerTagArgs(
                key="name",
                value="terraform-public-load-balancer",
            )])
        ```
        ### Create a load balancer in a Net

        ```python
        import pulumi
        import pulumi_outscale as outscale

        net01 = outscale.Net("net01", ip_range="10.0.0.0/16")
        subnet01 = outscale.Subnet("subnet01",
            net_id=net01.net_id,
            ip_range="10.0.0.0/24",
            tags=[outscale.SubnetTagArgs(
                key="Name",
                value="terraform-subnet-for-internal-load-balancer",
            )])
        security_group01 = outscale.SecurityGroup("securityGroup01",
            description="Terraform security group for internal load balancer",
            security_group_name="terraform-security-group-for-internal-load-balancer",
            net_id=net01.net_id,
            tags=[outscale.SecurityGroupTagArgs(
                key="Name",
                value="terraform-security-group-for-internal-load-balancer",
            )])
        load_balancer02 = outscale.LoadBalancer("loadBalancer02",
            load_balancer_name="terraform-private-load-balancer",
            listeners=[outscale.LoadBalancerListenerArgs(
                backend_port=80,
                backend_protocol="TCP",
                load_balancer_protocol="TCP",
                load_balancer_port=80,
            )],
            subnets=[subnet01.subnet_id],
            security_groups=[security_group01.security_group_id],
            load_balancer_type="internal",
            tags=[outscale.LoadBalancerTagArgs(
                key="name",
                value="terraform-private-load-balancer",
            )])
        ```
        ### Create an internet-facing load balancer in a Net

        ```python
        import pulumi
        import pulumi_outscale as outscale

        net02 = outscale.Net("net02", ip_range="10.0.0.0/16")
        subnet02 = outscale.Subnet("subnet02",
            net_id=net02.net_id,
            ip_range="10.0.0.0/24",
            tags=[outscale.SubnetTagArgs(
                key="Name",
                value="terraform-security-group-for-load-balancer",
            )])
        internet_service01 = outscale.InternetService("internetService01", opts=pulumi.ResourceOptions(depends_on=[net02]))
        internet_service_link01 = outscale.InternetServiceLink("internetServiceLink01",
            internet_service_id=internet_service01.internet_service_id,
            net_id=net02.net_id)
        route_table01 = outscale.RouteTable("routeTable01",
            net_id=net02.net_id,
            tags=[outscale.RouteTableTagArgs(
                key="name",
                value="terraform-route-table-for-load-balancer",
            )])
        route01 = outscale.Route("route01",
            gateway_id=internet_service01.id,
            destination_ip_range="10.0.0.0/0",
            route_table_id=route_table01.route_table_id)
        route_table_link01 = outscale.RouteTableLink("routeTableLink01",
            route_table_id=route_table01.route_table_id,
            subnet_id=subnet02.subnet_id)
        load_balancer03 = outscale.LoadBalancer("loadBalancer03",
            load_balancer_name="terraform-internet-private-lb",
            listeners=[
                outscale.LoadBalancerListenerArgs(
                    backend_port=80,
                    backend_protocol="TCP",
                    load_balancer_protocol="TCP",
                    load_balancer_port=80,
                ),
                outscale.LoadBalancerListenerArgs(
                    backend_port=8080,
                    backend_protocol="HTTP",
                    load_balancer_protocol="HTTP",
                    load_balancer_port=8080,
                ),
            ],
            subnets=[subnet02.subnet_id],
            load_balancer_type="internet-facing",
            public_ip="192.0.2.0",
            tags=[outscale.LoadBalancerTagArgs(
                key="name",
                value="terraform-internet-private-lb",
            )],
            opts=pulumi.ResourceOptions(depends_on=[
                    route01,
                    route_table_link01,
                ]))
        ```

        ## Import

        A load balancer can be imported using its name. For exampleconsole

        ```sh
         $ pulumi import outscale:index/loadBalancer:LoadBalancer ImportedLbu Name-of-the-Lbu
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerAccessLogArgs']]]] access_logs: Information about access logs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_vm_ids: One or more IDs of back-end VMs for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerListenerArgs']]]] listeners: One or more listeners to create.
        :param pulumi.Input[str] load_balancer_name: The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        :param pulumi.Input[str] load_balancer_type: The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        :param pulumi.Input[str] public_ip: (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        :param pulumi.Input[bool] secured_cookies: Whether secure cookies are enabled for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subregion_names: (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerTagArgs']]]] tags: A tag to add to this resource. You can specify this argument several times.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: LoadBalancerArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a load balancer.

        For more information on this resource, see the [User Guide](https://docs.outscale.com/en/userguide/About-Load-Balancers.html).\\
        For more information on this resource actions, see the [API documentation](https://docs.outscale.com/api#3ds-outscale-api-loadbalancer).

        ## Example Usage
        ### Create a load balancer in the public Cloud

        ```python
        import pulumi
        import pulumi_outscale as outscale

        load_balancer01 = outscale.LoadBalancer("loadBalancer01",
            listeners=[outscale.LoadBalancerListenerArgs(
                backend_port=8080,
                backend_protocol="HTTP",
                load_balancer_port=8080,
                load_balancer_protocol="HTTP",
            )],
            load_balancer_name="terraform-public-load-balancer",
            subregion_names=[f"{var['region']}a"],
            tags=[outscale.LoadBalancerTagArgs(
                key="name",
                value="terraform-public-load-balancer",
            )])
        ```
        ### Create a load balancer in a Net

        ```python
        import pulumi
        import pulumi_outscale as outscale

        net01 = outscale.Net("net01", ip_range="10.0.0.0/16")
        subnet01 = outscale.Subnet("subnet01",
            net_id=net01.net_id,
            ip_range="10.0.0.0/24",
            tags=[outscale.SubnetTagArgs(
                key="Name",
                value="terraform-subnet-for-internal-load-balancer",
            )])
        security_group01 = outscale.SecurityGroup("securityGroup01",
            description="Terraform security group for internal load balancer",
            security_group_name="terraform-security-group-for-internal-load-balancer",
            net_id=net01.net_id,
            tags=[outscale.SecurityGroupTagArgs(
                key="Name",
                value="terraform-security-group-for-internal-load-balancer",
            )])
        load_balancer02 = outscale.LoadBalancer("loadBalancer02",
            load_balancer_name="terraform-private-load-balancer",
            listeners=[outscale.LoadBalancerListenerArgs(
                backend_port=80,
                backend_protocol="TCP",
                load_balancer_protocol="TCP",
                load_balancer_port=80,
            )],
            subnets=[subnet01.subnet_id],
            security_groups=[security_group01.security_group_id],
            load_balancer_type="internal",
            tags=[outscale.LoadBalancerTagArgs(
                key="name",
                value="terraform-private-load-balancer",
            )])
        ```
        ### Create an internet-facing load balancer in a Net

        ```python
        import pulumi
        import pulumi_outscale as outscale

        net02 = outscale.Net("net02", ip_range="10.0.0.0/16")
        subnet02 = outscale.Subnet("subnet02",
            net_id=net02.net_id,
            ip_range="10.0.0.0/24",
            tags=[outscale.SubnetTagArgs(
                key="Name",
                value="terraform-security-group-for-load-balancer",
            )])
        internet_service01 = outscale.InternetService("internetService01", opts=pulumi.ResourceOptions(depends_on=[net02]))
        internet_service_link01 = outscale.InternetServiceLink("internetServiceLink01",
            internet_service_id=internet_service01.internet_service_id,
            net_id=net02.net_id)
        route_table01 = outscale.RouteTable("routeTable01",
            net_id=net02.net_id,
            tags=[outscale.RouteTableTagArgs(
                key="name",
                value="terraform-route-table-for-load-balancer",
            )])
        route01 = outscale.Route("route01",
            gateway_id=internet_service01.id,
            destination_ip_range="10.0.0.0/0",
            route_table_id=route_table01.route_table_id)
        route_table_link01 = outscale.RouteTableLink("routeTableLink01",
            route_table_id=route_table01.route_table_id,
            subnet_id=subnet02.subnet_id)
        load_balancer03 = outscale.LoadBalancer("loadBalancer03",
            load_balancer_name="terraform-internet-private-lb",
            listeners=[
                outscale.LoadBalancerListenerArgs(
                    backend_port=80,
                    backend_protocol="TCP",
                    load_balancer_protocol="TCP",
                    load_balancer_port=80,
                ),
                outscale.LoadBalancerListenerArgs(
                    backend_port=8080,
                    backend_protocol="HTTP",
                    load_balancer_protocol="HTTP",
                    load_balancer_port=8080,
                ),
            ],
            subnets=[subnet02.subnet_id],
            load_balancer_type="internet-facing",
            public_ip="192.0.2.0",
            tags=[outscale.LoadBalancerTagArgs(
                key="name",
                value="terraform-internet-private-lb",
            )],
            opts=pulumi.ResourceOptions(depends_on=[
                    route01,
                    route_table_link01,
                ]))
        ```

        ## Import

        A load balancer can be imported using its name. For exampleconsole

        ```sh
         $ pulumi import outscale:index/loadBalancer:LoadBalancer ImportedLbu Name-of-the-Lbu
        ```

        :param str resource_name: The name of the resource.
        :param LoadBalancerArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(LoadBalancerArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 access_logs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerAccessLogArgs']]]]] = None,
                 backend_vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerListenerArgs']]]]] = None,
                 load_balancer_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_type: Optional[pulumi.Input[str]] = None,
                 public_ip: Optional[pulumi.Input[str]] = None,
                 secured_cookies: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subregion_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerTagArgs']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = LoadBalancerArgs.__new__(LoadBalancerArgs)

            __props__.__dict__["access_logs"] = access_logs
            __props__.__dict__["backend_vm_ids"] = backend_vm_ids
            if listeners is None and not opts.urn:
                raise TypeError("Missing required property 'listeners'")
            __props__.__dict__["listeners"] = listeners
            if load_balancer_name is None and not opts.urn:
                raise TypeError("Missing required property 'load_balancer_name'")
            __props__.__dict__["load_balancer_name"] = load_balancer_name
            __props__.__dict__["load_balancer_type"] = load_balancer_type
            __props__.__dict__["public_ip"] = public_ip
            __props__.__dict__["secured_cookies"] = secured_cookies
            __props__.__dict__["security_groups"] = security_groups
            __props__.__dict__["subnets"] = subnets
            __props__.__dict__["subregion_names"] = subregion_names
            __props__.__dict__["tags"] = tags
            __props__.__dict__["application_sticky_cookie_policies"] = None
            __props__.__dict__["dns_name"] = None
            __props__.__dict__["health_checks"] = None
            __props__.__dict__["load_balancer_sticky_cookie_policies"] = None
            __props__.__dict__["net_id"] = None
            __props__.__dict__["request_id"] = None
            __props__.__dict__["source_security_groups"] = None
        super(LoadBalancer, __self__).__init__(
            'outscale:index/loadBalancer:LoadBalancer',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            access_logs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerAccessLogArgs']]]]] = None,
            application_sticky_cookie_policies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerApplicationStickyCookiePolicyArgs']]]]] = None,
            backend_vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            dns_name: Optional[pulumi.Input[str]] = None,
            health_checks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerHealthCheckArgs']]]]] = None,
            listeners: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerListenerArgs']]]]] = None,
            load_balancer_name: Optional[pulumi.Input[str]] = None,
            load_balancer_sticky_cookie_policies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerLoadBalancerStickyCookiePolicyArgs']]]]] = None,
            load_balancer_type: Optional[pulumi.Input[str]] = None,
            net_id: Optional[pulumi.Input[str]] = None,
            public_ip: Optional[pulumi.Input[str]] = None,
            request_id: Optional[pulumi.Input[str]] = None,
            secured_cookies: Optional[pulumi.Input[bool]] = None,
            security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            source_security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerSourceSecurityGroupArgs']]]]] = None,
            subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            subregion_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerTagArgs']]]]] = None) -> 'LoadBalancer':
        """
        Get an existing LoadBalancer resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerAccessLogArgs']]]] access_logs: Information about access logs.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerApplicationStickyCookiePolicyArgs']]]] application_sticky_cookie_policies: The stickiness policies defined for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_vm_ids: One or more IDs of back-end VMs for the load balancer.
        :param pulumi.Input[str] dns_name: The DNS name of the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerHealthCheckArgs']]]] health_checks: Information about the health check configuration.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerListenerArgs']]]] listeners: One or more listeners to create.
        :param pulumi.Input[str] load_balancer_name: The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerLoadBalancerStickyCookiePolicyArgs']]]] load_balancer_sticky_cookie_policies: The policies defined for the load balancer.
        :param pulumi.Input[str] load_balancer_type: The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        :param pulumi.Input[str] net_id: The ID of the Net for the load balancer.
        :param pulumi.Input[str] public_ip: (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        :param pulumi.Input[bool] secured_cookies: Whether secure cookies are enabled for the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerSourceSecurityGroupArgs']]]] source_security_groups: Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
               To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subregion_names: (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LoadBalancerTagArgs']]]] tags: A tag to add to this resource. You can specify this argument several times.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _LoadBalancerState.__new__(_LoadBalancerState)

        __props__.__dict__["access_logs"] = access_logs
        __props__.__dict__["application_sticky_cookie_policies"] = application_sticky_cookie_policies
        __props__.__dict__["backend_vm_ids"] = backend_vm_ids
        __props__.__dict__["dns_name"] = dns_name
        __props__.__dict__["health_checks"] = health_checks
        __props__.__dict__["listeners"] = listeners
        __props__.__dict__["load_balancer_name"] = load_balancer_name
        __props__.__dict__["load_balancer_sticky_cookie_policies"] = load_balancer_sticky_cookie_policies
        __props__.__dict__["load_balancer_type"] = load_balancer_type
        __props__.__dict__["net_id"] = net_id
        __props__.__dict__["public_ip"] = public_ip
        __props__.__dict__["request_id"] = request_id
        __props__.__dict__["secured_cookies"] = secured_cookies
        __props__.__dict__["security_groups"] = security_groups
        __props__.__dict__["source_security_groups"] = source_security_groups
        __props__.__dict__["subnets"] = subnets
        __props__.__dict__["subregion_names"] = subregion_names
        __props__.__dict__["tags"] = tags
        return LoadBalancer(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="accessLogs")
    def access_logs(self) -> pulumi.Output[Sequence['outputs.LoadBalancerAccessLog']]:
        """
        Information about access logs.
        """
        return pulumi.get(self, "access_logs")

    @property
    @pulumi.getter(name="applicationStickyCookiePolicies")
    def application_sticky_cookie_policies(self) -> pulumi.Output[Sequence['outputs.LoadBalancerApplicationStickyCookiePolicy']]:
        """
        The stickiness policies defined for the load balancer.
        """
        return pulumi.get(self, "application_sticky_cookie_policies")

    @property
    @pulumi.getter(name="backendVmIds")
    def backend_vm_ids(self) -> pulumi.Output[Sequence[str]]:
        """
        One or more IDs of back-end VMs for the load balancer.
        """
        return pulumi.get(self, "backend_vm_ids")

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> pulumi.Output[str]:
        """
        The DNS name of the load balancer.
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> pulumi.Output[Sequence['outputs.LoadBalancerHealthCheck']]:
        """
        Information about the health check configuration.
        """
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter
    def listeners(self) -> pulumi.Output[Sequence['outputs.LoadBalancerListener']]:
        """
        One or more listeners to create.
        """
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> pulumi.Output[str]:
        """
        The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="loadBalancerStickyCookiePolicies")
    def load_balancer_sticky_cookie_policies(self) -> pulumi.Output[Sequence['outputs.LoadBalancerLoadBalancerStickyCookiePolicy']]:
        """
        The policies defined for the load balancer.
        """
        return pulumi.get(self, "load_balancer_sticky_cookie_policies")

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> pulumi.Output[str]:
        """
        The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
        """
        return pulumi.get(self, "load_balancer_type")

    @property
    @pulumi.getter(name="netId")
    def net_id(self) -> pulumi.Output[str]:
        """
        The ID of the Net for the load balancer.
        """
        return pulumi.get(self, "net_id")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> pulumi.Output[str]:
        """
        (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="requestId")
    def request_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "request_id")

    @property
    @pulumi.getter(name="securedCookies")
    def secured_cookies(self) -> pulumi.Output[bool]:
        """
        Whether secure cookies are enabled for the load balancer.
        """
        return pulumi.get(self, "secured_cookies")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Output[Sequence[str]]:
        """
        (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceSecurityGroups")
    def source_security_groups(self) -> pulumi.Output[Sequence['outputs.LoadBalancerSourceSecurityGroup']]:
        """
        Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
        To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        """
        return pulumi.get(self, "source_security_groups")

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Output[Sequence[str]]:
        """
        (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="subregionNames")
    def subregion_names(self) -> pulumi.Output[Sequence[str]]:
        """
        (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
        """
        return pulumi.get(self, "subregion_names")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Sequence['outputs.LoadBalancerTag']]]:
        """
        A tag to add to this resource. You can specify this argument several times.
        """
        return pulumi.get(self, "tags")

