# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessKeyTimeoutsArgs',
    'AccessKeyTimeoutsArgsDict',
    'ClientGatewayTagArgs',
    'ClientGatewayTagArgsDict',
    'DhcpOptionTagArgs',
    'DhcpOptionTagArgsDict',
    'FlexibleGpuTimeoutsArgs',
    'FlexibleGpuTimeoutsArgsDict',
    'ImageBlockDeviceMappingArgs',
    'ImageBlockDeviceMappingArgsDict',
    'ImageBlockDeviceMappingBsusArgs',
    'ImageBlockDeviceMappingBsusArgsDict',
    'ImageExportTaskOsuExportArgs',
    'ImageExportTaskOsuExportArgsDict',
    'ImageExportTaskOsuExportOsuApiKeyArgs',
    'ImageExportTaskOsuExportOsuApiKeyArgsDict',
    'ImageExportTaskTagArgs',
    'ImageExportTaskTagArgsDict',
    'ImageLaunchPermissionPermissionAdditionsArgs',
    'ImageLaunchPermissionPermissionAdditionsArgsDict',
    'ImageLaunchPermissionPermissionRemovalsArgs',
    'ImageLaunchPermissionPermissionRemovalsArgsDict',
    'ImageLaunchPermissionPermissionsToLaunchArgs',
    'ImageLaunchPermissionPermissionsToLaunchArgsDict',
    'ImagePermissionsToLaunchArgs',
    'ImagePermissionsToLaunchArgsDict',
    'ImageStateCommentArgs',
    'ImageStateCommentArgsDict',
    'ImageTagArgs',
    'ImageTagArgsDict',
    'InternetServiceLinkTagArgs',
    'InternetServiceLinkTagArgsDict',
    'InternetServiceLinkTimeoutsArgs',
    'InternetServiceLinkTimeoutsArgsDict',
    'InternetServiceTagArgs',
    'InternetServiceTagArgsDict',
    'InternetServiceTimeoutsArgs',
    'InternetServiceTimeoutsArgsDict',
    'KeypairTagArgs',
    'KeypairTagArgsDict',
    'KeypairTimeoutsArgs',
    'KeypairTimeoutsArgsDict',
    'LoadBalancerAccessLogArgs',
    'LoadBalancerAccessLogArgsDict',
    'LoadBalancerApplicationStickyCookiePolicyArgs',
    'LoadBalancerApplicationStickyCookiePolicyArgsDict',
    'LoadBalancerAttributesAccessLogArgs',
    'LoadBalancerAttributesAccessLogArgsDict',
    'LoadBalancerAttributesApplicationStickyCookiePolicyArgs',
    'LoadBalancerAttributesApplicationStickyCookiePolicyArgsDict',
    'LoadBalancerAttributesHealthCheckArgs',
    'LoadBalancerAttributesHealthCheckArgsDict',
    'LoadBalancerAttributesListenerArgs',
    'LoadBalancerAttributesListenerArgsDict',
    'LoadBalancerAttributesLoadBalancerStickyCookiePolicyArgs',
    'LoadBalancerAttributesLoadBalancerStickyCookiePolicyArgsDict',
    'LoadBalancerAttributesSourceSecurityGroupArgs',
    'LoadBalancerAttributesSourceSecurityGroupArgsDict',
    'LoadBalancerAttributesTagArgs',
    'LoadBalancerAttributesTagArgsDict',
    'LoadBalancerHealthCheckArgs',
    'LoadBalancerHealthCheckArgsDict',
    'LoadBalancerListenerArgs',
    'LoadBalancerListenerArgsDict',
    'LoadBalancerListenerRuleListenerArgs',
    'LoadBalancerListenerRuleListenerArgsDict',
    'LoadBalancerListenerRuleListenerRuleArgs',
    'LoadBalancerListenerRuleListenerRuleArgsDict',
    'LoadBalancerLoadBalancerStickyCookiePolicyArgs',
    'LoadBalancerLoadBalancerStickyCookiePolicyArgsDict',
    'LoadBalancerPolicyAccessLogArgs',
    'LoadBalancerPolicyAccessLogArgsDict',
    'LoadBalancerPolicyApplicationStickyCookiePolicyArgs',
    'LoadBalancerPolicyApplicationStickyCookiePolicyArgsDict',
    'LoadBalancerPolicyHealthCheckArgs',
    'LoadBalancerPolicyHealthCheckArgsDict',
    'LoadBalancerPolicyListenerArgs',
    'LoadBalancerPolicyListenerArgsDict',
    'LoadBalancerPolicyLoadBalancerStickyCookiePolicyArgs',
    'LoadBalancerPolicyLoadBalancerStickyCookiePolicyArgsDict',
    'LoadBalancerPolicySourceSecurityGroupArgs',
    'LoadBalancerPolicySourceSecurityGroupArgsDict',
    'LoadBalancerPolicyTagArgs',
    'LoadBalancerPolicyTagArgsDict',
    'LoadBalancerSourceSecurityGroupArgs',
    'LoadBalancerSourceSecurityGroupArgsDict',
    'LoadBalancerTagArgs',
    'LoadBalancerTagArgsDict',
    'LoadBalancerVmsTimeoutsArgs',
    'LoadBalancerVmsTimeoutsArgsDict',
    'MainRouteTableLinkTimeoutsArgs',
    'MainRouteTableLinkTimeoutsArgsDict',
    'NatServicePublicIpArgs',
    'NatServicePublicIpArgsDict',
    'NatServiceTagArgs',
    'NatServiceTagArgsDict',
    'NetAccessPointTagArgs',
    'NetAccessPointTagArgsDict',
    'NetAccessPointTimeoutsArgs',
    'NetAccessPointTimeoutsArgsDict',
    'NetAttributesTagArgs',
    'NetAttributesTagArgsDict',
    'NetAttributesTimeoutsArgs',
    'NetAttributesTimeoutsArgsDict',
    'NetPeeringAcceptationAccepterNetArgs',
    'NetPeeringAcceptationAccepterNetArgsDict',
    'NetPeeringAcceptationSourceNetArgs',
    'NetPeeringAcceptationSourceNetArgsDict',
    'NetPeeringAcceptationStateArgs',
    'NetPeeringAcceptationStateArgsDict',
    'NetPeeringAcceptationTagArgs',
    'NetPeeringAcceptationTagArgsDict',
    'NetPeeringAcceptationTimeoutsArgs',
    'NetPeeringAcceptationTimeoutsArgsDict',
    'NetPeeringAccepterNetArgs',
    'NetPeeringAccepterNetArgsDict',
    'NetPeeringSourceNetArgs',
    'NetPeeringSourceNetArgsDict',
    'NetPeeringStateArgs',
    'NetPeeringStateArgsDict',
    'NetPeeringTagArgs',
    'NetPeeringTagArgsDict',
    'NetPeeringTimeoutsArgs',
    'NetPeeringTimeoutsArgsDict',
    'NetTagArgs',
    'NetTagArgsDict',
    'NetTimeoutsArgs',
    'NetTimeoutsArgsDict',
    'NicLinkNicArgs',
    'NicLinkNicArgsDict',
    'NicLinkPublicIpArgs',
    'NicLinkPublicIpArgsDict',
    'NicPrivateIpArgs',
    'NicPrivateIpArgsDict',
    'NicPrivateIpLinkPublicIpArgs',
    'NicPrivateIpLinkPublicIpArgsDict',
    'NicSecurityGroupArgs',
    'NicSecurityGroupArgsDict',
    'NicTagArgs',
    'NicTagArgsDict',
    'OutboundRuleRuleArgs',
    'OutboundRuleRuleArgsDict',
    'OutboundRuleRuleSecurityGroupsMemberArgs',
    'OutboundRuleRuleSecurityGroupsMemberArgsDict',
    'ProviderEndpointArgs',
    'ProviderEndpointArgsDict',
    'PublicIpLinkTagArgs',
    'PublicIpLinkTagArgsDict',
    'PublicIpTagArgs',
    'PublicIpTagArgsDict',
    'RouteTableLinkRouteTableArgs',
    'RouteTableLinkRouteTableArgsDict',
    'RouteTableLinkTimeoutsArgs',
    'RouteTableLinkTimeoutsArgsDict',
    'RouteTableRouteArgs',
    'RouteTableRouteArgsDict',
    'RouteTableRoutePropagatingVirtualGatewayArgs',
    'RouteTableRoutePropagatingVirtualGatewayArgsDict',
    'RouteTableTagArgs',
    'RouteTableTagArgsDict',
    'RouteTableTimeoutsArgs',
    'RouteTableTimeoutsArgsDict',
    'RouteTimeoutsArgs',
    'RouteTimeoutsArgsDict',
    'SecurityGroupInboundRuleArgs',
    'SecurityGroupInboundRuleArgsDict',
    'SecurityGroupOutboundRuleArgs',
    'SecurityGroupOutboundRuleArgsDict',
    'SecurityGroupRuleRuleArgs',
    'SecurityGroupRuleRuleArgsDict',
    'SecurityGroupRuleRuleSecurityGroupsMemberArgs',
    'SecurityGroupRuleRuleSecurityGroupsMemberArgsDict',
    'SecurityGroupTagArgs',
    'SecurityGroupTagArgsDict',
    'SnapshotAttributesPermissionsToCreateVolumeAdditionsArgs',
    'SnapshotAttributesPermissionsToCreateVolumeAdditionsArgsDict',
    'SnapshotAttributesPermissionsToCreateVolumeRemovalArgs',
    'SnapshotAttributesPermissionsToCreateVolumeRemovalArgsDict',
    'SnapshotExportTaskOsuExportArgs',
    'SnapshotExportTaskOsuExportArgsDict',
    'SnapshotExportTaskOsuExportOsuApiKeyArgs',
    'SnapshotExportTaskOsuExportOsuApiKeyArgsDict',
    'SnapshotExportTaskTagArgs',
    'SnapshotExportTaskTagArgsDict',
    'SnapshotPermissionsToCreateVolumeArgs',
    'SnapshotPermissionsToCreateVolumeArgsDict',
    'SnapshotTagArgs',
    'SnapshotTagArgsDict',
    'SubnetTagArgs',
    'SubnetTagArgsDict',
    'SubnetTimeoutsArgs',
    'SubnetTimeoutsArgsDict',
    'TagTagArgs',
    'TagTagArgsDict',
    'UserGroupPolicyArgs',
    'UserGroupPolicyArgsDict',
    'UserGroupUserArgs',
    'UserGroupUserArgsDict',
    'UserPolicyArgs',
    'UserPolicyArgsDict',
    'VirtualGatewayLinkNetToVirtualGatewayLinkArgs',
    'VirtualGatewayLinkNetToVirtualGatewayLinkArgsDict',
    'VirtualGatewayNetToVirtualGatewayLinkArgs',
    'VirtualGatewayNetToVirtualGatewayLinkArgsDict',
    'VirtualGatewayTagArgs',
    'VirtualGatewayTagArgsDict',
    'VmActionsOnNextBootArgs',
    'VmActionsOnNextBootArgsDict',
    'VmBlockDeviceMappingArgs',
    'VmBlockDeviceMappingArgsDict',
    'VmBlockDeviceMappingBsuArgs',
    'VmBlockDeviceMappingBsuArgsDict',
    'VmBlockDeviceMappingBsuTagArgs',
    'VmBlockDeviceMappingBsuTagArgsDict',
    'VmBlockDeviceMappingsCreatedArgs',
    'VmBlockDeviceMappingsCreatedArgsDict',
    'VmBlockDeviceMappingsCreatedBsusArgs',
    'VmBlockDeviceMappingsCreatedBsusArgsDict',
    'VmBlockDeviceMappingsCreatedBsusTagArgs',
    'VmBlockDeviceMappingsCreatedBsusTagArgsDict',
    'VmNicArgs',
    'VmNicArgsDict',
    'VmNicLinkNicArgs',
    'VmNicLinkNicArgsDict',
    'VmNicLinkPublicIpArgs',
    'VmNicLinkPublicIpArgsDict',
    'VmNicPrivateIpArgs',
    'VmNicPrivateIpArgsDict',
    'VmNicPrivateIpLinkPublicIpArgs',
    'VmNicPrivateIpLinkPublicIpArgsDict',
    'VmNicSecurityGroupArgs',
    'VmNicSecurityGroupArgsDict',
    'VmPrimaryNicArgs',
    'VmPrimaryNicArgsDict',
    'VmPrimaryNicLinkNicArgs',
    'VmPrimaryNicLinkNicArgsDict',
    'VmPrimaryNicLinkPublicIpArgs',
    'VmPrimaryNicLinkPublicIpArgsDict',
    'VmPrimaryNicPrivateIpArgs',
    'VmPrimaryNicPrivateIpArgsDict',
    'VmPrimaryNicPrivateIpLinkPublicIpArgs',
    'VmPrimaryNicPrivateIpLinkPublicIpArgsDict',
    'VmPrimaryNicSecurityGroupArgs',
    'VmPrimaryNicSecurityGroupArgsDict',
    'VmSecurityGroupArgs',
    'VmSecurityGroupArgsDict',
    'VmTagArgs',
    'VmTagArgsDict',
    'VolumeLinkTimeoutsArgs',
    'VolumeLinkTimeoutsArgsDict',
    'VolumeLinkedVolumeArgs',
    'VolumeLinkedVolumeArgsDict',
    'VolumeTagArgs',
    'VolumeTagArgsDict',
    'VolumeTimeoutsArgs',
    'VolumeTimeoutsArgsDict',
    'VpnConnectionRouteArgs',
    'VpnConnectionRouteArgsDict',
    'VpnConnectionTagArgs',
    'VpnConnectionTagArgsDict',
    'VpnConnectionVgwTelemetryArgs',
    'VpnConnectionVgwTelemetryArgsDict',
    'GetAccessKeyFilterArgs',
    'GetAccessKeyFilterArgsDict',
    'GetAccessKeysFilterArgs',
    'GetAccessKeysFilterArgsDict',
    'GetApiAccessRuleFilterArgs',
    'GetApiAccessRuleFilterArgsDict',
    'GetApiAccessRulesFilterArgs',
    'GetApiAccessRulesFilterArgsDict',
    'GetCaFilterArgs',
    'GetCaFilterArgsDict',
    'GetCasFilterArgs',
    'GetCasFilterArgsDict',
    'GetClientGatewayFilterArgs',
    'GetClientGatewayFilterArgsDict',
    'GetClientGatewaysFilterArgs',
    'GetClientGatewaysFilterArgsDict',
    'GetDhcpOptionFilterArgs',
    'GetDhcpOptionFilterArgsDict',
    'GetDhcpOptionsFilterArgs',
    'GetDhcpOptionsFilterArgsDict',
    'GetFlexibleGpuCatalogFilterArgs',
    'GetFlexibleGpuCatalogFilterArgsDict',
    'GetFlexibleGpuFilterArgs',
    'GetFlexibleGpuFilterArgsDict',
    'GetFlexibleGpusFilterArgs',
    'GetFlexibleGpusFilterArgsDict',
    'GetImageBlockDeviceMappingArgs',
    'GetImageBlockDeviceMappingArgsDict',
    'GetImageBlockDeviceMappingBsusArgs',
    'GetImageBlockDeviceMappingBsusArgsDict',
    'GetImageExportTaskFilterArgs',
    'GetImageExportTaskFilterArgsDict',
    'GetImageExportTasksFilterArgs',
    'GetImageExportTasksFilterArgsDict',
    'GetImageFilterArgs',
    'GetImageFilterArgsDict',
    'GetImagesFilterArgs',
    'GetImagesFilterArgsDict',
    'GetInternetServiceFilterArgs',
    'GetInternetServiceFilterArgsDict',
    'GetInternetServicesFilterArgs',
    'GetInternetServicesFilterArgsDict',
    'GetKeypairFilterArgs',
    'GetKeypairFilterArgsDict',
    'GetKeypairsFilterArgs',
    'GetKeypairsFilterArgsDict',
    'GetLoadBalancerAccessLogArgs',
    'GetLoadBalancerAccessLogArgsDict',
    'GetLoadBalancerFilterArgs',
    'GetLoadBalancerFilterArgsDict',
    'GetLoadBalancerHealthCheckArgs',
    'GetLoadBalancerHealthCheckArgsDict',
    'GetLoadBalancerListenerArgs',
    'GetLoadBalancerListenerArgsDict',
    'GetLoadBalancerListenerRuleFilterArgs',
    'GetLoadBalancerListenerRuleFilterArgsDict',
    'GetLoadBalancerListenerRulesFilterArgs',
    'GetLoadBalancerListenerRulesFilterArgsDict',
    'GetLoadBalancerTagArgs',
    'GetLoadBalancerTagArgsDict',
    'GetLoadBalancerTagsFilterArgs',
    'GetLoadBalancerTagsFilterArgsDict',
    'GetLoadBalancerVmHealthFilterArgs',
    'GetLoadBalancerVmHealthFilterArgsDict',
    'GetLoadBalancersFilterArgs',
    'GetLoadBalancersFilterArgsDict',
    'GetNatServiceFilterArgs',
    'GetNatServiceFilterArgsDict',
    'GetNatServicesFilterArgs',
    'GetNatServicesFilterArgsDict',
    'GetNetAccessPointFilterArgs',
    'GetNetAccessPointFilterArgsDict',
    'GetNetAccessPointServicesFilterArgs',
    'GetNetAccessPointServicesFilterArgsDict',
    'GetNetAccessPointsFilterArgs',
    'GetNetAccessPointsFilterArgsDict',
    'GetNetFilterArgs',
    'GetNetFilterArgsDict',
    'GetNetPeeringFilterArgs',
    'GetNetPeeringFilterArgsDict',
    'GetNetPeeringsFilterArgs',
    'GetNetPeeringsFilterArgsDict',
    'GetNetsFilterArgs',
    'GetNetsFilterArgsDict',
    'GetNicFilterArgs',
    'GetNicFilterArgsDict',
    'GetNicsFilterArgs',
    'GetNicsFilterArgsDict',
    'GetPoliciesFilterArgs',
    'GetPoliciesFilterArgsDict',
    'GetPoliciesLinkedToUserGroupFilterArgs',
    'GetPoliciesLinkedToUserGroupFilterArgsDict',
    'GetProductTypeFilterArgs',
    'GetProductTypeFilterArgsDict',
    'GetProductTypesFilterArgs',
    'GetProductTypesFilterArgsDict',
    'GetPublicIpFilterArgs',
    'GetPublicIpFilterArgsDict',
    'GetPublicIpsFilterArgs',
    'GetPublicIpsFilterArgsDict',
    'GetQuotaFilterArgs',
    'GetQuotaFilterArgsDict',
    'GetQuotasFilterArgs',
    'GetQuotasFilterArgsDict',
    'GetRouteTableFilterArgs',
    'GetRouteTableFilterArgsDict',
    'GetRouteTablesFilterArgs',
    'GetRouteTablesFilterArgsDict',
    'GetSecurityGroupFilterArgs',
    'GetSecurityGroupFilterArgsDict',
    'GetSecurityGroupsFilterArgs',
    'GetSecurityGroupsFilterArgsDict',
    'GetServerCertificateFilterArgs',
    'GetServerCertificateFilterArgsDict',
    'GetServerCertificatesFilterArgs',
    'GetServerCertificatesFilterArgsDict',
    'GetSnapshotExportTaskFilterArgs',
    'GetSnapshotExportTaskFilterArgsDict',
    'GetSnapshotExportTasksFilterArgs',
    'GetSnapshotExportTasksFilterArgsDict',
    'GetSnapshotFilterArgs',
    'GetSnapshotFilterArgsDict',
    'GetSnapshotsFilterArgs',
    'GetSnapshotsFilterArgsDict',
    'GetSubnetFilterArgs',
    'GetSubnetFilterArgsDict',
    'GetSubnetsFilterArgs',
    'GetSubnetsFilterArgsDict',
    'GetSubregionsFilterArgs',
    'GetSubregionsFilterArgsDict',
    'GetTagFilterArgs',
    'GetTagFilterArgsDict',
    'GetTagsFilterArgs',
    'GetTagsFilterArgsDict',
    'GetUserFilterArgs',
    'GetUserFilterArgsDict',
    'GetUserGroupUserArgs',
    'GetUserGroupUserArgsDict',
    'GetUserGroupsFilterArgs',
    'GetUserGroupsFilterArgsDict',
    'GetUsersFilterArgs',
    'GetUsersFilterArgsDict',
    'GetVirtualGatewayFilterArgs',
    'GetVirtualGatewayFilterArgsDict',
    'GetVirtualGatewaysFilterArgs',
    'GetVirtualGatewaysFilterArgsDict',
    'GetVmFilterArgs',
    'GetVmFilterArgsDict',
    'GetVmStateFilterArgs',
    'GetVmStateFilterArgsDict',
    'GetVmStatesFilterArgs',
    'GetVmStatesFilterArgsDict',
    'GetVmTypesFilterArgs',
    'GetVmTypesFilterArgsDict',
    'GetVmsFilterArgs',
    'GetVmsFilterArgsDict',
    'GetVolumeFilterArgs',
    'GetVolumeFilterArgsDict',
    'GetVolumesFilterArgs',
    'GetVolumesFilterArgsDict',
    'GetVpnConnectionFilterArgs',
    'GetVpnConnectionFilterArgsDict',
    'GetVpnConnectionsFilterArgs',
    'GetVpnConnectionsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AccessKeyTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AccessKeyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessKeyTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ClientGatewayTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    ClientGatewayTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientGatewayTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DhcpOptionTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    DhcpOptionTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpOptionTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FlexibleGpuTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    FlexibleGpuTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlexibleGpuTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ImageBlockDeviceMappingArgsDict(TypedDict):
        bsus: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImageBlockDeviceMappingBsusArgsDict']]]]
        """
        Information about the BSU volume to create.
        """
        device_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
        """
        virtual_device_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the virtual device (`ephemeralN`).
        """
elif False:
    ImageBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 bsus: Optional[pulumi.Input[Sequence[pulumi.Input['ImageBlockDeviceMappingBsusArgs']]]] = None,
                 device_name: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_device_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ImageBlockDeviceMappingBsusArgs']]] bsus: Information about the BSU volume to create.
        :param pulumi.Input[_builtins.str] device_name: The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
        :param pulumi.Input[_builtins.str] virtual_device_name: The name of the virtual device (`ephemeralN`).
        """
        if bsus is not None:
            pulumi.set(__self__, "bsus", bsus)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_device_name is not None:
            pulumi.set(__self__, "virtual_device_name", virtual_device_name)

    @_builtins.property
    @pulumi.getter
    def bsus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImageBlockDeviceMappingBsusArgs']]]]:
        """
        Information about the BSU volume to create.
        """
        return pulumi.get(self, "bsus")

    @bsus.setter
    def bsus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImageBlockDeviceMappingBsusArgs']]]]):
        pulumi.set(self, "bsus", value)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter(name="virtualDeviceName")
    def virtual_device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the virtual device (`ephemeralN`).
        """
        return pulumi.get(self, "virtual_device_name")

    @virtual_device_name.setter
    def virtual_device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_device_name", value)


if not MYPY:
    class ImageBlockDeviceMappingBsusArgsDict(TypedDict):
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot used to create the volume.
        """
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume, in gibibytes (GiB).<br />
        If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
        If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />
        For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
        """
elif False:
    ImageBlockDeviceMappingBsusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageBlockDeviceMappingBsusArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        :param pulumi.Input[_builtins.int] iops: The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot used to create the volume.
        :param pulumi.Input[_builtins.int] volume_size: The size of the volume, in gibibytes (GiB).<br />
               If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
               If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
        :param pulumi.Input[_builtins.str] volume_type: The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />
               For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
        """
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot used to create the volume.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume, in gibibytes (GiB).<br />
        If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
        If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />
        For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ImageExportTaskOsuExportArgsDict(TypedDict):
        disk_image_format: pulumi.Input[_builtins.str]
        """
        The format of the export disk (`qcow2` \\| `raw`).
        """
        osu_bucket: pulumi.Input[_builtins.str]
        """
        The name of the OOS bucket where you want to export the object.
        """
        osu_api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImageExportTaskOsuExportOsuApiKeyArgsDict']]]]
        """
        Information about the OOS API key.
        """
        osu_manifest_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the manifest file.
        """
        osu_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prefix for the key of the OOS object.
        """
elif False:
    ImageExportTaskOsuExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageExportTaskOsuExportArgs:
    def __init__(__self__, *,
                 disk_image_format: pulumi.Input[_builtins.str],
                 osu_bucket: pulumi.Input[_builtins.str],
                 osu_api_keys: Optional[pulumi.Input[Sequence[pulumi.Input['ImageExportTaskOsuExportOsuApiKeyArgs']]]] = None,
                 osu_manifest_url: Optional[pulumi.Input[_builtins.str]] = None,
                 osu_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] disk_image_format: The format of the export disk (`qcow2` \\| `raw`).
        :param pulumi.Input[_builtins.str] osu_bucket: The name of the OOS bucket where you want to export the object.
        :param pulumi.Input[Sequence[pulumi.Input['ImageExportTaskOsuExportOsuApiKeyArgs']]] osu_api_keys: Information about the OOS API key.
        :param pulumi.Input[_builtins.str] osu_manifest_url: The URL of the manifest file.
        :param pulumi.Input[_builtins.str] osu_prefix: The prefix for the key of the OOS object.
        """
        pulumi.set(__self__, "disk_image_format", disk_image_format)
        pulumi.set(__self__, "osu_bucket", osu_bucket)
        if osu_api_keys is not None:
            pulumi.set(__self__, "osu_api_keys", osu_api_keys)
        if osu_manifest_url is not None:
            pulumi.set(__self__, "osu_manifest_url", osu_manifest_url)
        if osu_prefix is not None:
            pulumi.set(__self__, "osu_prefix", osu_prefix)

    @_builtins.property
    @pulumi.getter(name="diskImageFormat")
    def disk_image_format(self) -> pulumi.Input[_builtins.str]:
        """
        The format of the export disk (`qcow2` \\| `raw`).
        """
        return pulumi.get(self, "disk_image_format")

    @disk_image_format.setter
    def disk_image_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "disk_image_format", value)

    @_builtins.property
    @pulumi.getter(name="osuBucket")
    def osu_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OOS bucket where you want to export the object.
        """
        return pulumi.get(self, "osu_bucket")

    @osu_bucket.setter
    def osu_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "osu_bucket", value)

    @_builtins.property
    @pulumi.getter(name="osuApiKeys")
    def osu_api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImageExportTaskOsuExportOsuApiKeyArgs']]]]:
        """
        Information about the OOS API key.
        """
        return pulumi.get(self, "osu_api_keys")

    @osu_api_keys.setter
    def osu_api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImageExportTaskOsuExportOsuApiKeyArgs']]]]):
        pulumi.set(self, "osu_api_keys", value)

    @_builtins.property
    @pulumi.getter(name="osuManifestUrl")
    def osu_manifest_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the manifest file.
        """
        return pulumi.get(self, "osu_manifest_url")

    @osu_manifest_url.setter
    def osu_manifest_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_manifest_url", value)

    @_builtins.property
    @pulumi.getter(name="osuPrefix")
    def osu_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prefix for the key of the OOS object.
        """
        return pulumi.get(self, "osu_prefix")

    @osu_prefix.setter
    def osu_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_prefix", value)


if not MYPY:
    class ImageExportTaskOsuExportOsuApiKeyArgsDict(TypedDict):
        api_key_id: pulumi.Input[_builtins.str]
        """
        The API key of the OOS account that enables you to access the bucket.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The secret key of the OOS account that enables you to access the bucket.
        """
elif False:
    ImageExportTaskOsuExportOsuApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageExportTaskOsuExportOsuApiKeyArgs:
    def __init__(__self__, *,
                 api_key_id: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_key_id: The API key of the OOS account that enables you to access the bucket.
        :param pulumi.Input[_builtins.str] secret_key: The secret key of the OOS account that enables you to access the bucket.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The API key of the OOS account that enables you to access the bucket.
        """
        return pulumi.get(self, "api_key_id")

    @api_key_id.setter
    def api_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key of the OOS account that enables you to access the bucket.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class ImageExportTaskTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    ImageExportTaskTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageExportTaskTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ImageLaunchPermissionPermissionAdditionsArgsDict(TypedDict):
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The account ID of one or more users to whom you want to give permissions.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.str]]
        """
        If true, the resource is public. If false, the resource is private.
        """
elif False:
    ImageLaunchPermissionPermissionAdditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageLaunchPermissionPermissionAdditionsArgs:
    def __init__(__self__, *,
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: The account ID of one or more users to whom you want to give permissions.
        :param pulumi.Input[_builtins.str] global_permission: If true, the resource is public. If false, the resource is private.
        """
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The account ID of one or more users to whom you want to give permissions.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class ImageLaunchPermissionPermissionRemovalsArgsDict(TypedDict):
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The account ID of one or more users from whom you want to remove permissions.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.str]]
        """
        If true, the resource is public. If false, the resource is private.
        """
elif False:
    ImageLaunchPermissionPermissionRemovalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageLaunchPermissionPermissionRemovalsArgs:
    def __init__(__self__, *,
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: The account ID of one or more users from whom you want to remove permissions.
        :param pulumi.Input[_builtins.str] global_permission: If true, the resource is public. If false, the resource is private.
        """
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The account ID of one or more users from whom you want to remove permissions.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class ImageLaunchPermissionPermissionsToLaunchArgsDict(TypedDict):
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more account IDs that the permission is associated with.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.str]]
        """
        A global permission for all accounts.<br />
        (Request) Set this parameter to true to make the resource public (if the parent parameter is `additions`) or to make the resource private (if the parent parameter is `removals`).<br />
        (Response) If true, the resource is public. If false, the resource is private.
        """
elif False:
    ImageLaunchPermissionPermissionsToLaunchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageLaunchPermissionPermissionsToLaunchArgs:
    def __init__(__self__, *,
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: One or more account IDs that the permission is associated with.
        :param pulumi.Input[_builtins.str] global_permission: A global permission for all accounts.<br />
               (Request) Set this parameter to true to make the resource public (if the parent parameter is `additions`) or to make the resource private (if the parent parameter is `removals`).<br />
               (Response) If true, the resource is public. If false, the resource is private.
        """
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more account IDs that the permission is associated with.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A global permission for all accounts.<br />
        (Request) Set this parameter to true to make the resource public (if the parent parameter is `additions`) or to make the resource private (if the parent parameter is `removals`).<br />
        (Response) If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class ImagePermissionsToLaunchArgsDict(TypedDict):
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more account IDs that the permission is associated with.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A global permission for all accounts.<br />
        (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
        (Response) If true, the resource is public. If false, the resource is private.
        """
elif False:
    ImagePermissionsToLaunchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePermissionsToLaunchArgs:
    def __init__(__self__, *,
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: One or more account IDs that the permission is associated with.
        :param pulumi.Input[_builtins.bool] global_permission: A global permission for all accounts.<br />
               (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
               (Response) If true, the resource is public. If false, the resource is private.
        """
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more account IDs that the permission is associated with.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A global permission for all accounts.<br />
        (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
        (Response) If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class ImageStateCommentArgsDict(TypedDict):
        state_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The code of the change of state.
        """
        state_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message explaining the change of state.
        """
elif False:
    ImageStateCommentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageStateCommentArgs:
    def __init__(__self__, *,
                 state_code: Optional[pulumi.Input[_builtins.str]] = None,
                 state_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] state_code: The code of the change of state.
        :param pulumi.Input[_builtins.str] state_message: A message explaining the change of state.
        """
        if state_code is not None:
            pulumi.set(__self__, "state_code", state_code)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter(name="stateCode")
    def state_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The code of the change of state.
        """
        return pulumi.get(self, "state_code")

    @state_code.setter
    def state_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state_code", value)

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message explaining the change of state.
        """
        return pulumi.get(self, "state_message")

    @state_message.setter
    def state_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state_message", value)


if not MYPY:
    class ImageTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    ImageTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InternetServiceLinkTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    InternetServiceLinkTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetServiceLinkTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InternetServiceLinkTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    InternetServiceLinkTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetServiceLinkTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class InternetServiceTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    InternetServiceTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetServiceTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InternetServiceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    InternetServiceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetServiceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class KeypairTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    KeypairTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeypairTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KeypairTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    KeypairTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeypairTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class LoadBalancerAccessLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        osu_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the OOS bucket for the access logs.
        """
        osu_bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        publication_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
elif False:
    LoadBalancerAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 osu_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 osu_bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 publication_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        :param pulumi.Input[_builtins.str] osu_bucket_name: The name of the OOS bucket for the access logs.
        :param pulumi.Input[_builtins.str] osu_bucket_prefix: The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        :param pulumi.Input[_builtins.int] publication_interval: The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if osu_bucket_name is not None:
            pulumi.set(__self__, "osu_bucket_name", osu_bucket_name)
        if osu_bucket_prefix is not None:
            pulumi.set(__self__, "osu_bucket_prefix", osu_bucket_prefix)
        if publication_interval is not None:
            pulumi.set(__self__, "publication_interval", publication_interval)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketName")
    def osu_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the OOS bucket for the access logs.
        """
        return pulumi.get(self, "osu_bucket_name")

    @osu_bucket_name.setter
    def osu_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketPrefix")
    def osu_bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        return pulumi.get(self, "osu_bucket_prefix")

    @osu_bucket_prefix.setter
    def osu_bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="publicationInterval")
    def publication_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        return pulumi.get(self, "publication_interval")

    @publication_interval.setter
    def publication_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "publication_interval", value)


if not MYPY:
    class LoadBalancerApplicationStickyCookiePolicyArgsDict(TypedDict):
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the application cookie used for stickiness.
        """
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the stickiness policy.
        """
elif False:
    LoadBalancerApplicationStickyCookiePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerApplicationStickyCookiePolicyArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cookie_name: The name of the application cookie used for stickiness.
        :param pulumi.Input[_builtins.str] policy_name: The name of the stickiness policy.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the application cookie used for stickiness.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the stickiness policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class LoadBalancerAttributesAccessLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        osu_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the OOS bucket for the access logs.
        """
        osu_bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        publication_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
elif False:
    LoadBalancerAttributesAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 osu_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 osu_bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 publication_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        :param pulumi.Input[_builtins.str] osu_bucket_name: The name of the OOS bucket for the access logs.
        :param pulumi.Input[_builtins.str] osu_bucket_prefix: The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        :param pulumi.Input[_builtins.int] publication_interval: The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if osu_bucket_name is not None:
            pulumi.set(__self__, "osu_bucket_name", osu_bucket_name)
        if osu_bucket_prefix is not None:
            pulumi.set(__self__, "osu_bucket_prefix", osu_bucket_prefix)
        if publication_interval is not None:
            pulumi.set(__self__, "publication_interval", publication_interval)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketName")
    def osu_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the OOS bucket for the access logs.
        """
        return pulumi.get(self, "osu_bucket_name")

    @osu_bucket_name.setter
    def osu_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketPrefix")
    def osu_bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        return pulumi.get(self, "osu_bucket_prefix")

    @osu_bucket_prefix.setter
    def osu_bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="publicationInterval")
    def publication_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        return pulumi.get(self, "publication_interval")

    @publication_interval.setter
    def publication_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "publication_interval", value)


if not MYPY:
    class LoadBalancerAttributesApplicationStickyCookiePolicyArgsDict(TypedDict):
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the application cookie used for stickiness.
        """
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the stickiness policy.
        """
elif False:
    LoadBalancerAttributesApplicationStickyCookiePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesApplicationStickyCookiePolicyArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cookie_name: The name of the application cookie used for stickiness.
        :param pulumi.Input[_builtins.str] policy_name: The name of the stickiness policy.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the application cookie used for stickiness.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the stickiness policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class LoadBalancerAttributesHealthCheckArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        The port number (between `1` and `65535`, both included).
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        check_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        healthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        unhealthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
elif False:
    LoadBalancerAttributesHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesHealthCheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 check_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 healthy_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: The port number (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] protocol: The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[_builtins.int] check_interval: The number of seconds between two requests (between `5` and `600` both included).
        :param pulumi.Input[_builtins.int] healthy_threshold: The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        :param pulumi.Input[_builtins.str] path: If you use the HTTP or HTTPS protocols, the request URL path.
        :param pulumi.Input[_builtins.int] timeout: The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        :param pulumi.Input[_builtins.int] unhealthy_threshold: The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port number (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "check_interval", value)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "healthy_threshold", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class LoadBalancerAttributesListenerArgsDict(TypedDict):
        backend_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        backend_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        load_balancer_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
        """
        load_balancer_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        policy_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The name of the policy you want to enable for the listener.
        """
        server_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns). If this parameter is specified, you must also specify the `load_balancer_port` parameter.
        """
elif False:
    LoadBalancerAttributesListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesListenerArgs:
    def __init__(__self__, *,
                 backend_port: Optional[pulumi.Input[_builtins.int]] = None,
                 backend_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 load_balancer_port: Optional[pulumi.Input[_builtins.int]] = None,
                 load_balancer_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 server_certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] backend_port: The port on which the backend VM is listening (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] backend_protocol: The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[_builtins.int] load_balancer_port: The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
        :param pulumi.Input[_builtins.str] load_balancer_protocol: The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_names: The name of the policy you want to enable for the listener.
        :param pulumi.Input[_builtins.str] server_certificate_id: The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns). If this parameter is specified, you must also specify the `load_balancer_port` parameter.
        """
        if backend_port is not None:
            pulumi.set(__self__, "backend_port", backend_port)
        if backend_protocol is not None:
            pulumi.set(__self__, "backend_protocol", backend_protocol)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)
        if load_balancer_protocol is not None:
            pulumi.set(__self__, "load_balancer_protocol", load_balancer_protocol)
        if policy_names is not None:
            pulumi.set(__self__, "policy_names", policy_names)
        if server_certificate_id is not None:
            pulumi.set(__self__, "server_certificate_id", server_certificate_id)

    @_builtins.property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "backend_port", value)

    @_builtins.property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backend_protocol", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
        """
        return pulumi.get(self, "load_balancer_port")

    @load_balancer_port.setter
    def load_balancer_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "load_balancer_port", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerProtocol")
    def load_balancer_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "load_balancer_protocol")

    @load_balancer_protocol.setter
    def load_balancer_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_balancer_protocol", value)

    @_builtins.property
    @pulumi.getter(name="policyNames")
    def policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The name of the policy you want to enable for the listener.
        """
        return pulumi.get(self, "policy_names")

    @policy_names.setter
    def policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_names", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificateId")
    def server_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns). If this parameter is specified, you must also specify the `load_balancer_port` parameter.
        """
        return pulumi.get(self, "server_certificate_id")

    @server_certificate_id.setter
    def server_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_certificate_id", value)


if not MYPY:
    class LoadBalancerAttributesLoadBalancerStickyCookiePolicyArgsDict(TypedDict):
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the stickiness policy.
        """
elif False:
    LoadBalancerAttributesLoadBalancerStickyCookiePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesLoadBalancerStickyCookiePolicyArgs:
    def __init__(__self__, *,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] policy_name: The name of the stickiness policy.
        """
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the stickiness policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class LoadBalancerAttributesSourceSecurityGroupArgsDict(TypedDict):
        security_group_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    LoadBalancerAttributesSourceSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesSourceSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_account_id: The account ID of the owner of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_account_id is not None:
            pulumi.set(__self__, "security_group_account_id", security_group_account_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupAccountId")
    def security_group_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the security group.
        """
        return pulumi.get(self, "security_group_account_id")

    @security_group_account_id.setter
    def security_group_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_account_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class LoadBalancerAttributesTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    LoadBalancerAttributesTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAttributesTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadBalancerHealthCheckArgsDict(TypedDict):
        check_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        healthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number (between `1` and `65535`, both included).
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        unhealthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
elif False:
    LoadBalancerHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerHealthCheckArgs:
    def __init__(__self__, *,
                 check_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 healthy_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] check_interval: The number of seconds between two requests (between `5` and `600` both included).
        :param pulumi.Input[_builtins.int] healthy_threshold: The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        :param pulumi.Input[_builtins.str] path: If you use the HTTP or HTTPS protocols, the request URL path.
        :param pulumi.Input[_builtins.int] port: The port number (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] protocol: The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[_builtins.int] timeout: The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        :param pulumi.Input[_builtins.int] unhealthy_threshold: The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "check_interval", value)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "healthy_threshold", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class LoadBalancerListenerArgsDict(TypedDict):
        backend_port: pulumi.Input[_builtins.int]
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        backend_protocol: pulumi.Input[_builtins.str]
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        load_balancer_port: pulumi.Input[_builtins.int]
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included).
        """
        load_balancer_protocol: pulumi.Input[_builtins.str]
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        policy_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The names of the policies. If there are no policies enabled, the list is empty.
        """
        server_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
elif False:
    LoadBalancerListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerArgs:
    def __init__(__self__, *,
                 backend_port: pulumi.Input[_builtins.int],
                 backend_protocol: pulumi.Input[_builtins.str],
                 load_balancer_port: pulumi.Input[_builtins.int],
                 load_balancer_protocol: pulumi.Input[_builtins.str],
                 policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 server_certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] backend_port: The port on which the backend VM is listening (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] backend_protocol: The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[_builtins.int] load_balancer_port: The port on which the load balancer is listening (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] load_balancer_protocol: The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_names: The names of the policies. If there are no policies enabled, the list is empty.
        :param pulumi.Input[_builtins.str] server_certificate_id: The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
        pulumi.set(__self__, "backend_port", backend_port)
        pulumi.set(__self__, "backend_protocol", backend_protocol)
        pulumi.set(__self__, "load_balancer_port", load_balancer_port)
        pulumi.set(__self__, "load_balancer_protocol", load_balancer_protocol)
        if policy_names is not None:
            pulumi.set(__self__, "policy_names", policy_names)
        if server_certificate_id is not None:
            pulumi.set(__self__, "server_certificate_id", server_certificate_id)

    @_builtins.property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "backend_port", value)

    @_builtins.property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "backend_protocol", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "load_balancer_port")

    @load_balancer_port.setter
    def load_balancer_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "load_balancer_port", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerProtocol")
    def load_balancer_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "load_balancer_protocol")

    @load_balancer_protocol.setter
    def load_balancer_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "load_balancer_protocol", value)

    @_builtins.property
    @pulumi.getter(name="policyNames")
    def policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The names of the policies. If there are no policies enabled, the list is empty.
        """
        return pulumi.get(self, "policy_names")

    @policy_names.setter
    def policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_names", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificateId")
    def server_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
        return pulumi.get(self, "server_certificate_id")

    @server_certificate_id.setter
    def server_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_certificate_id", value)


if not MYPY:
    class LoadBalancerListenerRuleListenerArgsDict(TypedDict):
        load_balancer_name: pulumi.Input[_builtins.str]
        """
        The name of the load balancer to which the listener is attached.
        """
        load_balancer_port: pulumi.Input[_builtins.int]
        """
        The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
        """
elif False:
    LoadBalancerListenerRuleListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerRuleListenerArgs:
    def __init__(__self__, *,
                 load_balancer_name: pulumi.Input[_builtins.str],
                 load_balancer_port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] load_balancer_name: The name of the load balancer to which the listener is attached.
        :param pulumi.Input[_builtins.int] load_balancer_port: The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
        """
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @_builtins.property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the load balancer to which the listener is attached.
        """
        return pulumi.get(self, "load_balancer_name")

    @load_balancer_name.setter
    def load_balancer_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "load_balancer_name", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
        """
        return pulumi.get(self, "load_balancer_port")

    @load_balancer_port.setter
    def load_balancer_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "load_balancer_port", value)


if not MYPY:
    class LoadBalancerListenerRuleListenerRuleArgsDict(TypedDict):
        listener_rule_name: pulumi.Input[_builtins.str]
        """
        A human-readable name for the listener rule.
        """
        priority: pulumi.Input[_builtins.int]
        """
        The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of action for the rule (always `forward`).
        """
        host_name_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except `-.?`.
        """
        listener_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the listener.
        """
        listener_rule_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the listener rule.
        """
        path_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except `_-.$/~&quot;'@:+?`.
        """
elif False:
    LoadBalancerListenerRuleListenerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerListenerRuleListenerRuleArgs:
    def __init__(__self__, *,
                 listener_rule_name: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 listener_id: Optional[pulumi.Input[_builtins.int]] = None,
                 listener_rule_id: Optional[pulumi.Input[_builtins.int]] = None,
                 path_pattern: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] listener_rule_name: A human-readable name for the listener rule.
        :param pulumi.Input[_builtins.int] priority: The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
        :param pulumi.Input[_builtins.str] action: The type of action for the rule (always `forward`).
        :param pulumi.Input[_builtins.str] host_name_pattern: A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except `-.?`.
        :param pulumi.Input[_builtins.int] listener_id: The ID of the listener.
        :param pulumi.Input[_builtins.int] listener_rule_id: The ID of the listener rule.
        :param pulumi.Input[_builtins.str] path_pattern: A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except `_-.$/~&quot;'@:+?`.
        """
        pulumi.set(__self__, "listener_rule_name", listener_rule_name)
        pulumi.set(__self__, "priority", priority)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if host_name_pattern is not None:
            pulumi.set(__self__, "host_name_pattern", host_name_pattern)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if listener_rule_id is not None:
            pulumi.set(__self__, "listener_rule_id", listener_rule_id)
        if path_pattern is not None:
            pulumi.set(__self__, "path_pattern", path_pattern)

    @_builtins.property
    @pulumi.getter(name="listenerRuleName")
    def listener_rule_name(self) -> pulumi.Input[_builtins.str]:
        """
        A human-readable name for the listener rule.
        """
        return pulumi.get(self, "listener_rule_name")

    @listener_rule_name.setter
    def listener_rule_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "listener_rule_name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of action for the rule (always `forward`).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="hostNamePattern")
    def host_name_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except `-.?`.
        """
        return pulumi.get(self, "host_name_pattern")

    @host_name_pattern.setter
    def host_name_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name_pattern", value)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the listener.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="listenerRuleId")
    def listener_rule_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the listener rule.
        """
        return pulumi.get(self, "listener_rule_id")

    @listener_rule_id.setter
    def listener_rule_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "listener_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except `_-.$/~&quot;'@:+?`.
        """
        return pulumi.get(self, "path_pattern")

    @path_pattern.setter
    def path_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_pattern", value)


if not MYPY:
    class LoadBalancerLoadBalancerStickyCookiePolicyArgsDict(TypedDict):
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the stickiness policy.
        """
elif False:
    LoadBalancerLoadBalancerStickyCookiePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerLoadBalancerStickyCookiePolicyArgs:
    def __init__(__self__, *,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] policy_name: The name of the stickiness policy.
        """
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the stickiness policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class LoadBalancerPolicyAccessLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        osu_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the OOS bucket for the access logs.
        """
        osu_bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        publication_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
elif False:
    LoadBalancerPolicyAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicyAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 osu_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 osu_bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 publication_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        :param pulumi.Input[_builtins.str] osu_bucket_name: The name of the OOS bucket for the access logs.
        :param pulumi.Input[_builtins.str] osu_bucket_prefix: The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        :param pulumi.Input[_builtins.int] publication_interval: The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if osu_bucket_name is not None:
            pulumi.set(__self__, "osu_bucket_name", osu_bucket_name)
        if osu_bucket_prefix is not None:
            pulumi.set(__self__, "osu_bucket_prefix", osu_bucket_prefix)
        if publication_interval is not None:
            pulumi.set(__self__, "publication_interval", publication_interval)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketName")
    def osu_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the OOS bucket for the access logs.
        """
        return pulumi.get(self, "osu_bucket_name")

    @osu_bucket_name.setter
    def osu_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketPrefix")
    def osu_bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        return pulumi.get(self, "osu_bucket_prefix")

    @osu_bucket_prefix.setter
    def osu_bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="publicationInterval")
    def publication_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        return pulumi.get(self, "publication_interval")

    @publication_interval.setter
    def publication_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "publication_interval", value)


if not MYPY:
    class LoadBalancerPolicyApplicationStickyCookiePolicyArgsDict(TypedDict):
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
        """
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
        """
elif False:
    LoadBalancerPolicyApplicationStickyCookiePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicyApplicationStickyCookiePolicyArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cookie_name: The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
        :param pulumi.Input[_builtins.str] policy_name: The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class LoadBalancerPolicyHealthCheckArgsDict(TypedDict):
        check_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        healthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number (between `1` and `65535`, both included).
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        unhealthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
elif False:
    LoadBalancerPolicyHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicyHealthCheckArgs:
    def __init__(__self__, *,
                 check_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 healthy_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] check_interval: The number of seconds between two requests (between `5` and `600` both included).
        :param pulumi.Input[_builtins.int] healthy_threshold: The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        :param pulumi.Input[_builtins.str] path: If you use the HTTP or HTTPS protocols, the request URL path.
        :param pulumi.Input[_builtins.int] port: The port number (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] protocol: The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[_builtins.int] timeout: The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        :param pulumi.Input[_builtins.int] unhealthy_threshold: The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "check_interval", value)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "healthy_threshold", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class LoadBalancerPolicyListenerArgsDict(TypedDict):
        backend_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        backend_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        load_balancer_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included).
        """
        load_balancer_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        policy_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The names of the policies. If there are no policies enabled, the list is empty.
        """
        server_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
elif False:
    LoadBalancerPolicyListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicyListenerArgs:
    def __init__(__self__, *,
                 backend_port: Optional[pulumi.Input[_builtins.int]] = None,
                 backend_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 load_balancer_port: Optional[pulumi.Input[_builtins.int]] = None,
                 load_balancer_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 server_certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] backend_port: The port on which the backend VM is listening (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] backend_protocol: The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[_builtins.int] load_balancer_port: The port on which the load balancer is listening (between `1` and `65535`, both included).
        :param pulumi.Input[_builtins.str] load_balancer_protocol: The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_names: The names of the policies. If there are no policies enabled, the list is empty.
        :param pulumi.Input[_builtins.str] server_certificate_id: The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
        if backend_port is not None:
            pulumi.set(__self__, "backend_port", backend_port)
        if backend_protocol is not None:
            pulumi.set(__self__, "backend_protocol", backend_protocol)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)
        if load_balancer_protocol is not None:
            pulumi.set(__self__, "load_balancer_protocol", load_balancer_protocol)
        if policy_names is not None:
            pulumi.set(__self__, "policy_names", policy_names)
        if server_certificate_id is not None:
            pulumi.set(__self__, "server_certificate_id", server_certificate_id)

    @_builtins.property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "backend_port", value)

    @_builtins.property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backend_protocol", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "load_balancer_port")

    @load_balancer_port.setter
    def load_balancer_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "load_balancer_port", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerProtocol")
    def load_balancer_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "load_balancer_protocol")

    @load_balancer_protocol.setter
    def load_balancer_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_balancer_protocol", value)

    @_builtins.property
    @pulumi.getter(name="policyNames")
    def policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The names of the policies. If there are no policies enabled, the list is empty.
        """
        return pulumi.get(self, "policy_names")

    @policy_names.setter
    def policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_names", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificateId")
    def server_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
        return pulumi.get(self, "server_certificate_id")

    @server_certificate_id.setter
    def server_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_certificate_id", value)


if not MYPY:
    class LoadBalancerPolicyLoadBalancerStickyCookiePolicyArgsDict(TypedDict):
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
        """
elif False:
    LoadBalancerPolicyLoadBalancerStickyCookiePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicyLoadBalancerStickyCookiePolicyArgs:
    def __init__(__self__, *,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] policy_name: The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
        """
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique name of the policy, with a maximum length of 32 alphanumeric characters and dashes (`-`).
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class LoadBalancerPolicySourceSecurityGroupArgsDict(TypedDict):
        security_group_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    LoadBalancerPolicySourceSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicySourceSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_account_id: The account ID of the owner of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_account_id is not None:
            pulumi.set(__self__, "security_group_account_id", security_group_account_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupAccountId")
    def security_group_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the security group.
        """
        return pulumi.get(self, "security_group_account_id")

    @security_group_account_id.setter
    def security_group_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_account_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class LoadBalancerPolicyTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    LoadBalancerPolicyTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPolicyTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadBalancerSourceSecurityGroupArgsDict(TypedDict):
        security_group_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    LoadBalancerSourceSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerSourceSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_account_id: The account ID of the owner of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_account_id is not None:
            pulumi.set(__self__, "security_group_account_id", security_group_account_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupAccountId")
    def security_group_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the security group.
        """
        return pulumi.get(self, "security_group_account_id")

    @security_group_account_id.setter
    def security_group_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_account_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class LoadBalancerTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    LoadBalancerTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadBalancerVmsTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    LoadBalancerVmsTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerVmsTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class MainRouteTableLinkTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    MainRouteTableLinkTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MainRouteTableLinkTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NatServicePublicIpArgsDict(TypedDict):
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP associated with the NAT service.
        """
        public_ip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The allocation ID of the public IP to associate with the NAT service.<br />
        If the public IP is already associated with another resource, you must first disassociate it.
        """
elif False:
    NatServicePublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatServicePublicIpArgs:
    def __init__(__self__, *,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] public_ip: The public IP associated with the NAT service.
        :param pulumi.Input[_builtins.str] public_ip_id: The allocation ID of the public IP to associate with the NAT service.<br />
               If the public IP is already associated with another resource, you must first disassociate it.
        """
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_id is not None:
            pulumi.set(__self__, "public_ip_id", public_ip_id)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP associated with the NAT service.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpId")
    def public_ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The allocation ID of the public IP to associate with the NAT service.<br />
        If the public IP is already associated with another resource, you must first disassociate it.
        """
        return pulumi.get(self, "public_ip_id")

    @public_ip_id.setter
    def public_ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_id", value)


if not MYPY:
    class NatServiceTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NatServiceTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatServiceTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetAccessPointTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NetAccessPointTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetAccessPointTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetAccessPointTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetAccessPointTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetAccessPointTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NetAttributesTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NetAttributesTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetAttributesTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetAttributesTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetAttributesTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetAttributesTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NetPeeringAcceptationAccepterNetArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        The account ID of the owner of the source Net.
        """
        ip_range: pulumi.Input[_builtins.str]
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        net_id: pulumi.Input[_builtins.str]
        """
        The ID of the source Net.
        """
elif False:
    NetPeeringAcceptationAccepterNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringAcceptationAccepterNetArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 ip_range: pulumi.Input[_builtins.str],
                 net_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the source Net.
        :param pulumi.Input[_builtins.str] ip_range: The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[_builtins.str] net_id: The ID of the source Net.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "net_id", net_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The account ID of the owner of the source Net.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the source Net.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_id", value)


if not MYPY:
    class NetPeeringAcceptationSourceNetArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        The account ID of the owner of the source Net.
        """
        ip_range: pulumi.Input[_builtins.str]
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        net_id: pulumi.Input[_builtins.str]
        """
        The ID of the source Net.
        """
elif False:
    NetPeeringAcceptationSourceNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringAcceptationSourceNetArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 ip_range: pulumi.Input[_builtins.str],
                 net_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the source Net.
        :param pulumi.Input[_builtins.str] ip_range: The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[_builtins.str] net_id: The ID of the source Net.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "net_id", net_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The account ID of the owner of the source Net.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the source Net.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_id", value)


if not MYPY:
    class NetPeeringAcceptationStateArgsDict(TypedDict):
        message: pulumi.Input[_builtins.str]
        """
        Additional information about the state of the Net peering.
        """
        name: pulumi.Input[_builtins.str]
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
elif False:
    NetPeeringAcceptationStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringAcceptationStateArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] message: Additional information about the state of the Net peering.
        :param pulumi.Input[_builtins.str] name: The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        Additional information about the state of the Net peering.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NetPeeringAcceptationTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NetPeeringAcceptationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringAcceptationTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetPeeringAcceptationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetPeeringAcceptationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringAcceptationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NetPeeringAccepterNetArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        The account ID of the owner of the source Net.
        """
        ip_range: pulumi.Input[_builtins.str]
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        net_id: pulumi.Input[_builtins.str]
        """
        The ID of the source Net.
        """
elif False:
    NetPeeringAccepterNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringAccepterNetArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 ip_range: pulumi.Input[_builtins.str],
                 net_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the source Net.
        :param pulumi.Input[_builtins.str] ip_range: The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[_builtins.str] net_id: The ID of the source Net.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "net_id", net_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The account ID of the owner of the source Net.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the source Net.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_id", value)


if not MYPY:
    class NetPeeringSourceNetArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        The account ID of the owner of the source Net.
        """
        ip_range: pulumi.Input[_builtins.str]
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        net_id: pulumi.Input[_builtins.str]
        """
        The ID of the source Net.
        """
elif False:
    NetPeeringSourceNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringSourceNetArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 ip_range: pulumi.Input[_builtins.str],
                 net_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the source Net.
        :param pulumi.Input[_builtins.str] ip_range: The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[_builtins.str] net_id: The ID of the source Net.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "net_id", net_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The account ID of the owner of the source Net.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the source Net.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_id", value)


if not MYPY:
    class NetPeeringStateArgsDict(TypedDict):
        message: pulumi.Input[_builtins.str]
        """
        Additional information about the state of the Net peering.
        """
        name: pulumi.Input[_builtins.str]
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
elif False:
    NetPeeringStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringStateArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] message: Additional information about the state of the Net peering.
        :param pulumi.Input[_builtins.str] name: The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        Additional information about the state of the Net peering.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NetPeeringTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NetPeeringTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetPeeringTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetPeeringTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetPeeringTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NetTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NetTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NicLinkNicArgsDict(TypedDict):
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.str]]
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        device_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        The device index for the NIC attachment (between `1` and `7`, both included).
        """
        link_nic_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the NIC to attach.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| `detaching`).
        """
        vm_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the VM.
        """
        vm_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the VM.
        """
elif False:
    NicLinkNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicLinkNicArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.str]] = None,
                 device_number: Optional[pulumi.Input[_builtins.int]] = None,
                 link_nic_id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 vm_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete_on_vm_deletion: If true, the NIC is deleted when the VM is terminated.
        :param pulumi.Input[_builtins.int] device_number: The device index for the NIC attachment (between `1` and `7`, both included).
        :param pulumi.Input[_builtins.str] link_nic_id: The ID of the NIC to attach.
        :param pulumi.Input[_builtins.str] state: The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| `detaching`).
        :param pulumi.Input[_builtins.str] vm_account_id: The account ID of the owner of the VM.
        :param pulumi.Input[_builtins.str] vm_id: The ID of the VM.
        """
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if link_nic_id is not None:
            pulumi.set(__self__, "link_nic_id", link_nic_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if vm_account_id is not None:
            pulumi.set(__self__, "vm_account_id", vm_account_id)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The device index for the NIC attachment (between `1` and `7`, both included).
        """
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "device_number", value)

    @_builtins.property
    @pulumi.getter(name="linkNicId")
    def link_nic_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the NIC to attach.
        """
        return pulumi.get(self, "link_nic_id")

    @link_nic_id.setter
    def link_nic_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_nic_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| `detaching`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="vmAccountId")
    def vm_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the VM.
        """
        return pulumi.get(self, "vm_account_id")

    @vm_account_id.setter
    def vm_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_account_id", value)

    @_builtins.property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the VM.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_id", value)


if not MYPY:
    class NicLinkPublicIpArgsDict(TypedDict):
        link_public_ip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
        """
        public_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the public DNS.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP associated with the NIC.
        """
        public_ip_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the public IP.
        """
        public_ip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The allocation ID of the public IP.
        """
elif False:
    NicLinkPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicLinkPublicIpArgs:
    def __init__(__self__, *,
                 link_public_ip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] link_public_ip_id: (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
        :param pulumi.Input[_builtins.str] public_dns_name: The name of the public DNS.
        :param pulumi.Input[_builtins.str] public_ip: The public IP associated with the NIC.
        :param pulumi.Input[_builtins.str] public_ip_account_id: The account ID of the owner of the public IP.
        :param pulumi.Input[_builtins.str] public_ip_id: The allocation ID of the public IP.
        """
        if link_public_ip_id is not None:
            pulumi.set(__self__, "link_public_ip_id", link_public_ip_id)
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_account_id is not None:
            pulumi.set(__self__, "public_ip_account_id", public_ip_account_id)
        if public_ip_id is not None:
            pulumi.set(__self__, "public_ip_id", public_ip_id)

    @_builtins.property
    @pulumi.getter(name="linkPublicIpId")
    def link_public_ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
        """
        return pulumi.get(self, "link_public_ip_id")

    @link_public_ip_id.setter
    def link_public_ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_public_ip_id", value)

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the public DNS.
        """
        return pulumi.get(self, "public_dns_name")

    @public_dns_name.setter
    def public_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP associated with the NIC.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAccountId")
    def public_ip_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the public IP.
        """
        return pulumi.get(self, "public_ip_account_id")

    @public_ip_account_id.setter
    def public_ip_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_account_id", value)

    @_builtins.property
    @pulumi.getter(name="publicIpId")
    def public_ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The allocation ID of the public IP.
        """
        return pulumi.get(self, "public_ip_id")

    @public_ip_id.setter
    def public_ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_id", value)


if not MYPY:
    class NicPrivateIpArgsDict(TypedDict):
        is_primary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the IP is the primary private IP of the NIC.
        """
        link_public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['NicPrivateIpLinkPublicIpArgsDict']]]]
        """
        Information about the public IP association.
        """
        private_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the private DNS.
        """
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP of the NIC.
        """
elif False:
    NicPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicPrivateIpArgs:
    def __init__(__self__, *,
                 is_primary: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_public_ips: Optional[pulumi.Input[Sequence[pulumi.Input['NicPrivateIpLinkPublicIpArgs']]]] = None,
                 private_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_primary: If true, the IP is the primary private IP of the NIC.
        :param pulumi.Input[Sequence[pulumi.Input['NicPrivateIpLinkPublicIpArgs']]] link_public_ips: Information about the public IP association.
        :param pulumi.Input[_builtins.str] private_dns_name: The name of the private DNS.
        :param pulumi.Input[_builtins.str] private_ip: The private IP of the NIC.
        """
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if link_public_ips is not None:
            pulumi.set(__self__, "link_public_ips", link_public_ips)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the IP is the primary private IP of the NIC.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_primary", value)

    @_builtins.property
    @pulumi.getter(name="linkPublicIps")
    def link_public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NicPrivateIpLinkPublicIpArgs']]]]:
        """
        Information about the public IP association.
        """
        return pulumi.get(self, "link_public_ips")

    @link_public_ips.setter
    def link_public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NicPrivateIpLinkPublicIpArgs']]]]):
        pulumi.set(self, "link_public_ips", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the private DNS.
        """
        return pulumi.get(self, "private_dns_name")

    @private_dns_name.setter
    def private_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP of the NIC.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class NicPrivateIpLinkPublicIpArgsDict(TypedDict):
        link_public_ip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
        """
        public_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the public DNS.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP associated with the NIC.
        """
        public_ip_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the public IP.
        """
        public_ip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The allocation ID of the public IP.
        """
elif False:
    NicPrivateIpLinkPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicPrivateIpLinkPublicIpArgs:
    def __init__(__self__, *,
                 link_public_ip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] link_public_ip_id: (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
        :param pulumi.Input[_builtins.str] public_dns_name: The name of the public DNS.
        :param pulumi.Input[_builtins.str] public_ip: The public IP associated with the NIC.
        :param pulumi.Input[_builtins.str] public_ip_account_id: The account ID of the owner of the public IP.
        :param pulumi.Input[_builtins.str] public_ip_id: The allocation ID of the public IP.
        """
        if link_public_ip_id is not None:
            pulumi.set(__self__, "link_public_ip_id", link_public_ip_id)
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_account_id is not None:
            pulumi.set(__self__, "public_ip_account_id", public_ip_account_id)
        if public_ip_id is not None:
            pulumi.set(__self__, "public_ip_id", public_ip_id)

    @_builtins.property
    @pulumi.getter(name="linkPublicIpId")
    def link_public_ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
        """
        return pulumi.get(self, "link_public_ip_id")

    @link_public_ip_id.setter
    def link_public_ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_public_ip_id", value)

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the public DNS.
        """
        return pulumi.get(self, "public_dns_name")

    @public_dns_name.setter
    def public_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP associated with the NIC.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAccountId")
    def public_ip_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the public IP.
        """
        return pulumi.get(self, "public_ip_account_id")

    @public_ip_account_id.setter
    def public_ip_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_account_id", value)

    @_builtins.property
    @pulumi.getter(name="publicIpId")
    def public_ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The allocation ID of the public IP.
        """
        return pulumi.get(self, "public_ip_id")

    @public_ip_id.setter
    def public_ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_id", value)


if not MYPY:
    class NicSecurityGroupArgsDict(TypedDict):
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    NicSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_id: The ID of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class NicTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    NicTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OutboundRuleRuleArgsDict(TypedDict):
        from_port_range: NotRequired[pulumi.Input[_builtins.int]]
        ip_protocol: NotRequired[pulumi.Input[_builtins.str]]
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        security_groups_members: NotRequired[pulumi.Input[Sequence[pulumi.Input['OutboundRuleRuleSecurityGroupsMemberArgsDict']]]]
        service_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        to_port_range: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    OutboundRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundRuleRuleArgs:
    def __init__(__self__, *,
                 from_port_range: Optional[pulumi.Input[_builtins.int]] = None,
                 ip_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups_members: Optional[pulumi.Input[Sequence[pulumi.Input['OutboundRuleRuleSecurityGroupsMemberArgs']]]] = None,
                 service_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 to_port_range: Optional[pulumi.Input[_builtins.int]] = None):
        if from_port_range is not None:
            pulumi.set(__self__, "from_port_range", from_port_range)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if security_groups_members is not None:
            pulumi.set(__self__, "security_groups_members", security_groups_members)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if to_port_range is not None:
            pulumi.set(__self__, "to_port_range", to_port_range)

    @_builtins.property
    @pulumi.getter(name="fromPortRange")
    def from_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "from_port_range")

    @from_port_range.setter
    def from_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port_range", value)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_ranges", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupsMembers")
    def security_groups_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OutboundRuleRuleSecurityGroupsMemberArgs']]]]:
        return pulumi.get(self, "security_groups_members")

    @security_groups_members.setter
    def security_groups_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OutboundRuleRuleSecurityGroupsMemberArgs']]]]):
        pulumi.set(self, "security_groups_members", value)

    @_builtins.property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "service_ids")

    @service_ids.setter
    def service_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "service_ids", value)

    @_builtins.property
    @pulumi.getter(name="toPortRange")
    def to_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "to_port_range")

    @to_port_range.setter
    def to_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port_range", value)


if not MYPY:
    class OutboundRuleRuleSecurityGroupsMemberArgsDict(TypedDict):
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OutboundRuleRuleSecurityGroupsMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundRuleRuleSecurityGroupsMemberArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class ProviderEndpointArgsDict(TypedDict):
        api: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use this to override the default service endpoint URL
        """
elif False:
    ProviderEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderEndpointArgs:
    def __init__(__self__, *,
                 api: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api: Use this to override the default service endpoint URL
        """
        if api is not None:
            pulumi.set(__self__, "api", api)

    @_builtins.property
    @pulumi.getter
    def api(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use this to override the default service endpoint URL
        """
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api", value)


if not MYPY:
    class PublicIpLinkTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PublicIpLinkTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PublicIpLinkTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PublicIpTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    PublicIpTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PublicIpTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteTableLinkRouteTableArgsDict(TypedDict):
        link_route_table_id: pulumi.Input[_builtins.str]
        """
        The ID of the association between the route table and the Net or Subnet.
        """
        main: pulumi.Input[_builtins.bool]
        """
        If true, the route table is the main one.
        """
        net_id: pulumi.Input[_builtins.str]
        """
        The ID of the Net for which you want to create a route table.
        """
        route_table_id: pulumi.Input[_builtins.str]
        """
        The ID of the route table.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        The ID of the Subnet, if the route table is explicitly linked to a Subnet.
        """
elif False:
    RouteTableLinkRouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableLinkRouteTableArgs:
    def __init__(__self__, *,
                 link_route_table_id: pulumi.Input[_builtins.str],
                 main: pulumi.Input[_builtins.bool],
                 net_id: pulumi.Input[_builtins.str],
                 route_table_id: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] link_route_table_id: The ID of the association between the route table and the Net or Subnet.
        :param pulumi.Input[_builtins.bool] main: If true, the route table is the main one.
        :param pulumi.Input[_builtins.str] net_id: The ID of the Net for which you want to create a route table.
        :param pulumi.Input[_builtins.str] route_table_id: The ID of the route table.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the Subnet, if the route table is explicitly linked to a Subnet.
        """
        pulumi.set(__self__, "link_route_table_id", link_route_table_id)
        pulumi.set(__self__, "main", main)
        pulumi.set(__self__, "net_id", net_id)
        pulumi.set(__self__, "route_table_id", route_table_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="linkRouteTableId")
    def link_route_table_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the association between the route table and the Net or Subnet.
        """
        return pulumi.get(self, "link_route_table_id")

    @link_route_table_id.setter
    def link_route_table_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "link_route_table_id", value)

    @_builtins.property
    @pulumi.getter
    def main(self) -> pulumi.Input[_builtins.bool]:
        """
        If true, the route table is the main one.
        """
        return pulumi.get(self, "main")

    @main.setter
    def main(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "main", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Net for which you want to create a route table.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_id", value)

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the route table.
        """
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "route_table_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Subnet, if the route table is explicitly linked to a Subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class RouteTableLinkTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RouteTableLinkTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableLinkTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class RouteTableRouteArgsDict(TypedDict):
        creation_method: pulumi.Input[_builtins.str]
        """
        The method used to create the route.
        """
        destination_ip_range: pulumi.Input[_builtins.str]
        """
        The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
        """
        destination_service_id: pulumi.Input[_builtins.str]
        """
        The ID of the OUTSCALE service.
        """
        gateway_id: pulumi.Input[_builtins.str]
        """
        The ID of the internet service or virtual gateway attached to the Net.
        """
        nat_service_id: pulumi.Input[_builtins.str]
        """
        The ID of a NAT service attached to the Net.
        """
        net_access_point_id: pulumi.Input[_builtins.str]
        """
        The ID of the Net access point.
        """
        net_peering_id: pulumi.Input[_builtins.str]
        """
        The ID of the Net peering.
        """
        nic_id: pulumi.Input[_builtins.str]
        """
        The ID of the NIC.
        """
        state: pulumi.Input[_builtins.str]
        """
        The state of a route in the route table (always `active`).
        """
        vm_account_id: pulumi.Input[_builtins.str]
        """
        The account ID of the owner of the VM.
        """
        vm_id: pulumi.Input[_builtins.str]
        """
        The ID of a VM specified in a route in the table.
        """
elif False:
    RouteTableRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableRouteArgs:
    def __init__(__self__, *,
                 creation_method: pulumi.Input[_builtins.str],
                 destination_ip_range: pulumi.Input[_builtins.str],
                 destination_service_id: pulumi.Input[_builtins.str],
                 gateway_id: pulumi.Input[_builtins.str],
                 nat_service_id: pulumi.Input[_builtins.str],
                 net_access_point_id: pulumi.Input[_builtins.str],
                 net_peering_id: pulumi.Input[_builtins.str],
                 nic_id: pulumi.Input[_builtins.str],
                 state: pulumi.Input[_builtins.str],
                 vm_account_id: pulumi.Input[_builtins.str],
                 vm_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] creation_method: The method used to create the route.
        :param pulumi.Input[_builtins.str] destination_ip_range: The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
        :param pulumi.Input[_builtins.str] destination_service_id: The ID of the OUTSCALE service.
        :param pulumi.Input[_builtins.str] gateway_id: The ID of the internet service or virtual gateway attached to the Net.
        :param pulumi.Input[_builtins.str] nat_service_id: The ID of a NAT service attached to the Net.
        :param pulumi.Input[_builtins.str] net_access_point_id: The ID of the Net access point.
        :param pulumi.Input[_builtins.str] net_peering_id: The ID of the Net peering.
        :param pulumi.Input[_builtins.str] nic_id: The ID of the NIC.
        :param pulumi.Input[_builtins.str] state: The state of a route in the route table (always `active`).
        :param pulumi.Input[_builtins.str] vm_account_id: The account ID of the owner of the VM.
        :param pulumi.Input[_builtins.str] vm_id: The ID of a VM specified in a route in the table.
        """
        pulumi.set(__self__, "creation_method", creation_method)
        pulumi.set(__self__, "destination_ip_range", destination_ip_range)
        pulumi.set(__self__, "destination_service_id", destination_service_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "nat_service_id", nat_service_id)
        pulumi.set(__self__, "net_access_point_id", net_access_point_id)
        pulumi.set(__self__, "net_peering_id", net_peering_id)
        pulumi.set(__self__, "nic_id", nic_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vm_account_id", vm_account_id)
        pulumi.set(__self__, "vm_id", vm_id)

    @_builtins.property
    @pulumi.getter(name="creationMethod")
    def creation_method(self) -> pulumi.Input[_builtins.str]:
        """
        The method used to create the route.
        """
        return pulumi.get(self, "creation_method")

    @creation_method.setter
    def creation_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "creation_method", value)

    @_builtins.property
    @pulumi.getter(name="destinationIpRange")
    def destination_ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
        """
        return pulumi.get(self, "destination_ip_range")

    @destination_ip_range.setter
    def destination_ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_ip_range", value)

    @_builtins.property
    @pulumi.getter(name="destinationServiceId")
    def destination_service_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the OUTSCALE service.
        """
        return pulumi.get(self, "destination_service_id")

    @destination_service_id.setter
    def destination_service_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_service_id", value)

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the internet service or virtual gateway attached to the Net.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "gateway_id", value)

    @_builtins.property
    @pulumi.getter(name="natServiceId")
    def nat_service_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a NAT service attached to the Net.
        """
        return pulumi.get(self, "nat_service_id")

    @nat_service_id.setter
    def nat_service_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nat_service_id", value)

    @_builtins.property
    @pulumi.getter(name="netAccessPointId")
    def net_access_point_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Net access point.
        """
        return pulumi.get(self, "net_access_point_id")

    @net_access_point_id.setter
    def net_access_point_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_access_point_id", value)

    @_builtins.property
    @pulumi.getter(name="netPeeringId")
    def net_peering_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Net peering.
        """
        return pulumi.get(self, "net_peering_id")

    @net_peering_id.setter
    def net_peering_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "net_peering_id", value)

    @_builtins.property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the NIC.
        """
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nic_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        The state of a route in the route table (always `active`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="vmAccountId")
    def vm_account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The account ID of the owner of the VM.
        """
        return pulumi.get(self, "vm_account_id")

    @vm_account_id.setter
    def vm_account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vm_account_id", value)

    @_builtins.property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a VM specified in a route in the table.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vm_id", value)


if not MYPY:
    class RouteTableRoutePropagatingVirtualGatewayArgsDict(TypedDict):
        virtual_gateway_id: pulumi.Input[_builtins.str]
        """
        The ID of the virtual gateway.
        """
elif False:
    RouteTableRoutePropagatingVirtualGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableRoutePropagatingVirtualGatewayArgs:
    def __init__(__self__, *,
                 virtual_gateway_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] virtual_gateway_id: The ID of the virtual gateway.
        """
        pulumi.set(__self__, "virtual_gateway_id", virtual_gateway_id)

    @_builtins.property
    @pulumi.getter(name="virtualGatewayId")
    def virtual_gateway_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the virtual gateway.
        """
        return pulumi.get(self, "virtual_gateway_id")

    @virtual_gateway_id.setter
    def virtual_gateway_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "virtual_gateway_id", value)


if not MYPY:
    class RouteTableTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    RouteTableTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RouteTableTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RouteTableTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class RouteTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RouteTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class SecurityGroupInboundRuleArgsDict(TypedDict):
        from_port_range: NotRequired[pulumi.Input[_builtins.int]]
        """
        The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        """
        ip_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        """
        security_groups_members: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        Information about one or more source or destination security groups.
        """
        to_port_range: NotRequired[pulumi.Input[_builtins.int]]
        """
        The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
elif False:
    SecurityGroupInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupInboundRuleArgs:
    def __init__(__self__, *,
                 from_port_range: Optional[pulumi.Input[_builtins.int]] = None,
                 ip_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups_members: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 to_port_range: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] from_port_range: The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        :param pulumi.Input[_builtins.str] ip_protocol: The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_ranges: One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] security_groups_members: Information about one or more source or destination security groups.
        :param pulumi.Input[_builtins.int] to_port_range: The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
        if from_port_range is not None:
            pulumi.set(__self__, "from_port_range", from_port_range)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if security_groups_members is not None:
            pulumi.set(__self__, "security_groups_members", security_groups_members)
        if to_port_range is not None:
            pulumi.set(__self__, "to_port_range", to_port_range)

    @_builtins.property
    @pulumi.getter(name="fromPortRange")
    def from_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        """
        return pulumi.get(self, "from_port_range")

    @from_port_range.setter
    def from_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port_range", value)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_ranges", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupsMembers")
    def security_groups_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        Information about one or more source or destination security groups.
        """
        return pulumi.get(self, "security_groups_members")

    @security_groups_members.setter
    def security_groups_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "security_groups_members", value)

    @_builtins.property
    @pulumi.getter(name="toPortRange")
    def to_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
        return pulumi.get(self, "to_port_range")

    @to_port_range.setter
    def to_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port_range", value)


if not MYPY:
    class SecurityGroupOutboundRuleArgsDict(TypedDict):
        from_port_range: NotRequired[pulumi.Input[_builtins.int]]
        """
        The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        """
        ip_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        """
        security_groups_members: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        Information about one or more source or destination security groups.
        """
        to_port_range: NotRequired[pulumi.Input[_builtins.int]]
        """
        The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
elif False:
    SecurityGroupOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupOutboundRuleArgs:
    def __init__(__self__, *,
                 from_port_range: Optional[pulumi.Input[_builtins.int]] = None,
                 ip_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups_members: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 to_port_range: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] from_port_range: The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        :param pulumi.Input[_builtins.str] ip_protocol: The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_ranges: One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] security_groups_members: Information about one or more source or destination security groups.
        :param pulumi.Input[_builtins.int] to_port_range: The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
        if from_port_range is not None:
            pulumi.set(__self__, "from_port_range", from_port_range)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if security_groups_members is not None:
            pulumi.set(__self__, "security_groups_members", security_groups_members)
        if to_port_range is not None:
            pulumi.set(__self__, "to_port_range", to_port_range)

    @_builtins.property
    @pulumi.getter(name="fromPortRange")
    def from_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        """
        return pulumi.get(self, "from_port_range")

    @from_port_range.setter
    def from_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port_range", value)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_ranges", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupsMembers")
    def security_groups_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        Information about one or more source or destination security groups.
        """
        return pulumi.get(self, "security_groups_members")

    @security_groups_members.setter
    def security_groups_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "security_groups_members", value)

    @_builtins.property
    @pulumi.getter(name="toPortRange")
    def to_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
        return pulumi.get(self, "to_port_range")

    @to_port_range.setter
    def to_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port_range", value)


if not MYPY:
    class SecurityGroupRuleRuleArgsDict(TypedDict):
        from_port_range: NotRequired[pulumi.Input[_builtins.int]]
        """
        The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        """
        ip_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        """
        security_groups_members: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityGroupRuleRuleSecurityGroupsMemberArgsDict']]]]
        """
        Information about one or more source or destination security groups.
        """
        service_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more service IDs to allow traffic from a Net to access the corresponding OUTSCALE services. For more information, see [ReadNetAccessPointServices](https://docs.outscale.com/api#readnetaccesspointservices).
        """
        to_port_range: NotRequired[pulumi.Input[_builtins.int]]
        """
        The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
elif False:
    SecurityGroupRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupRuleRuleArgs:
    def __init__(__self__, *,
                 from_port_range: Optional[pulumi.Input[_builtins.int]] = None,
                 ip_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups_members: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityGroupRuleRuleSecurityGroupsMemberArgs']]]] = None,
                 service_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 to_port_range: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] from_port_range: The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        :param pulumi.Input[_builtins.str] ip_protocol: The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_ranges: One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        :param pulumi.Input[Sequence[pulumi.Input['SecurityGroupRuleRuleSecurityGroupsMemberArgs']]] security_groups_members: Information about one or more source or destination security groups.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] service_ids: One or more service IDs to allow traffic from a Net to access the corresponding OUTSCALE services. For more information, see [ReadNetAccessPointServices](https://docs.outscale.com/api#readnetaccesspointservices).
        :param pulumi.Input[_builtins.int] to_port_range: The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
        if from_port_range is not None:
            pulumi.set(__self__, "from_port_range", from_port_range)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if security_groups_members is not None:
            pulumi.set(__self__, "security_groups_members", security_groups_members)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if to_port_range is not None:
            pulumi.set(__self__, "to_port_range", to_port_range)

    @_builtins.property
    @pulumi.getter(name="fromPortRange")
    def from_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
        """
        return pulumi.get(self, "from_port_range")

    @from_port_range.setter
    def from_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port_range", value)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
        """
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_ranges", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupsMembers")
    def security_groups_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityGroupRuleRuleSecurityGroupsMemberArgs']]]]:
        """
        Information about one or more source or destination security groups.
        """
        return pulumi.get(self, "security_groups_members")

    @security_groups_members.setter
    def security_groups_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityGroupRuleRuleSecurityGroupsMemberArgs']]]]):
        pulumi.set(self, "security_groups_members", value)

    @_builtins.property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more service IDs to allow traffic from a Net to access the corresponding OUTSCALE services. For more information, see [ReadNetAccessPointServices](https://docs.outscale.com/api#readnetaccesspointservices).
        """
        return pulumi.get(self, "service_ids")

    @service_ids.setter
    def service_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "service_ids", value)

    @_builtins.property
    @pulumi.getter(name="toPortRange")
    def to_port_range(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The end of the port range for the TCP and UDP protocols, or an ICMP code number.
        """
        return pulumi.get(self, "to_port_range")

    @to_port_range.setter
    def to_port_range(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port_range", value)


if not MYPY:
    class SecurityGroupRuleRuleSecurityGroupsMemberArgsDict(TypedDict):
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID that owns the source or destination security group.
        """
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a source or destination security group that you want to link to the security group of the rule.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
        """
elif False:
    SecurityGroupRuleRuleSecurityGroupsMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupRuleRuleSecurityGroupsMemberArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_id: The account ID that owns the source or destination security group.
        :param pulumi.Input[_builtins.str] security_group_id: The ID of a source or destination security group that you want to link to the security group of the rule.
        :param pulumi.Input[_builtins.str] security_group_name: (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID that owns the source or destination security group.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a source or destination security group that you want to link to the security group of the rule.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class SecurityGroupTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    SecurityGroupTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SnapshotAttributesPermissionsToCreateVolumeAdditionsArgsDict(TypedDict):
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The account ID of one or more users to whom you want to give permissions.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the resource is public. If false, the resource is private.
        """
elif False:
    SnapshotAttributesPermissionsToCreateVolumeAdditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotAttributesPermissionsToCreateVolumeAdditionsArgs:
    def __init__(__self__, *,
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: The account ID of one or more users to whom you want to give permissions.
        :param pulumi.Input[_builtins.bool] global_permission: If true, the resource is public. If false, the resource is private.
        """
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The account ID of one or more users to whom you want to give permissions.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class SnapshotAttributesPermissionsToCreateVolumeRemovalArgsDict(TypedDict):
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The account ID of one or more users from whom you want to remove permissions.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the resource is public. If false, the resource is private.
        """
elif False:
    SnapshotAttributesPermissionsToCreateVolumeRemovalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotAttributesPermissionsToCreateVolumeRemovalArgs:
    def __init__(__self__, *,
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: The account ID of one or more users from whom you want to remove permissions.
        :param pulumi.Input[_builtins.bool] global_permission: If true, the resource is public. If false, the resource is private.
        """
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The account ID of one or more users from whom you want to remove permissions.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class SnapshotExportTaskOsuExportArgsDict(TypedDict):
        disk_image_format: pulumi.Input[_builtins.str]
        """
        The format of the export disk (`qcow2` \\| `raw`).
        """
        osu_bucket: pulumi.Input[_builtins.str]
        """
        The name of the OOS bucket where you want to export the object.
        """
        osu_api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['SnapshotExportTaskOsuExportOsuApiKeyArgsDict']]]]
        """
        Information about the OOS API key.
        """
        osu_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prefix for the key of the OOS object.
        """
elif False:
    SnapshotExportTaskOsuExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotExportTaskOsuExportArgs:
    def __init__(__self__, *,
                 disk_image_format: pulumi.Input[_builtins.str],
                 osu_bucket: pulumi.Input[_builtins.str],
                 osu_api_keys: Optional[pulumi.Input[Sequence[pulumi.Input['SnapshotExportTaskOsuExportOsuApiKeyArgs']]]] = None,
                 osu_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] disk_image_format: The format of the export disk (`qcow2` \\| `raw`).
        :param pulumi.Input[_builtins.str] osu_bucket: The name of the OOS bucket where you want to export the object.
        :param pulumi.Input[Sequence[pulumi.Input['SnapshotExportTaskOsuExportOsuApiKeyArgs']]] osu_api_keys: Information about the OOS API key.
        :param pulumi.Input[_builtins.str] osu_prefix: The prefix for the key of the OOS object.
        """
        pulumi.set(__self__, "disk_image_format", disk_image_format)
        pulumi.set(__self__, "osu_bucket", osu_bucket)
        if osu_api_keys is not None:
            pulumi.set(__self__, "osu_api_keys", osu_api_keys)
        if osu_prefix is not None:
            pulumi.set(__self__, "osu_prefix", osu_prefix)

    @_builtins.property
    @pulumi.getter(name="diskImageFormat")
    def disk_image_format(self) -> pulumi.Input[_builtins.str]:
        """
        The format of the export disk (`qcow2` \\| `raw`).
        """
        return pulumi.get(self, "disk_image_format")

    @disk_image_format.setter
    def disk_image_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "disk_image_format", value)

    @_builtins.property
    @pulumi.getter(name="osuBucket")
    def osu_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OOS bucket where you want to export the object.
        """
        return pulumi.get(self, "osu_bucket")

    @osu_bucket.setter
    def osu_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "osu_bucket", value)

    @_builtins.property
    @pulumi.getter(name="osuApiKeys")
    def osu_api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SnapshotExportTaskOsuExportOsuApiKeyArgs']]]]:
        """
        Information about the OOS API key.
        """
        return pulumi.get(self, "osu_api_keys")

    @osu_api_keys.setter
    def osu_api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SnapshotExportTaskOsuExportOsuApiKeyArgs']]]]):
        pulumi.set(self, "osu_api_keys", value)

    @_builtins.property
    @pulumi.getter(name="osuPrefix")
    def osu_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prefix for the key of the OOS object.
        """
        return pulumi.get(self, "osu_prefix")

    @osu_prefix.setter
    def osu_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "osu_prefix", value)


if not MYPY:
    class SnapshotExportTaskOsuExportOsuApiKeyArgsDict(TypedDict):
        api_key_id: pulumi.Input[_builtins.str]
        """
        The API key of the OOS account that enables you to access the bucket.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The secret key of the OOS account that enables you to access the bucket.
        """
elif False:
    SnapshotExportTaskOsuExportOsuApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotExportTaskOsuExportOsuApiKeyArgs:
    def __init__(__self__, *,
                 api_key_id: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_key_id: The API key of the OOS account that enables you to access the bucket.
        :param pulumi.Input[_builtins.str] secret_key: The secret key of the OOS account that enables you to access the bucket.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The API key of the OOS account that enables you to access the bucket.
        """
        return pulumi.get(self, "api_key_id")

    @api_key_id.setter
    def api_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key of the OOS account that enables you to access the bucket.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class SnapshotExportTaskTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    SnapshotExportTaskTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotExportTaskTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SnapshotPermissionsToCreateVolumeArgsDict(TypedDict):
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the snapshot.
        """
        global_permission: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A global permission for all accounts.<br />
        (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
        (Response) If true, the resource is public. If false, the resource is private.
        """
elif False:
    SnapshotPermissionsToCreateVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotPermissionsToCreateVolumeArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 global_permission: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the snapshot.
        :param pulumi.Input[_builtins.bool] global_permission: A global permission for all accounts.<br />
               (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
               (Response) If true, the resource is public. If false, the resource is private.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if global_permission is not None:
            pulumi.set(__self__, "global_permission", global_permission)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the snapshot.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="globalPermission")
    def global_permission(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A global permission for all accounts.<br />
        (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
        (Response) If true, the resource is public. If false, the resource is private.
        """
        return pulumi.get(self, "global_permission")

    @global_permission.setter
    def global_permission(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "global_permission", value)


if not MYPY:
    class SnapshotTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    SnapshotTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    SubnetTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    SubnetTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class TagTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TagTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UserGroupPolicyArgsDict(TypedDict):
        policy_orn: pulumi.Input[_builtins.str]
        creation_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of creation of the user group.
        """
        default_version_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a policy version that you want to make the default one (the active one).
        """
        last_modification_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of the last modification of the user group.
        """
        policy_id: NotRequired[pulumi.Input[_builtins.str]]
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    UserGroupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPolicyArgs:
    def __init__(__self__, *,
                 policy_orn: pulumi.Input[_builtins.str],
                 creation_date: Optional[pulumi.Input[_builtins.str]] = None,
                 default_version_id: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modification_date: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] creation_date: The date and time (UTC) of creation of the user group.
        :param pulumi.Input[_builtins.str] default_version_id: The ID of a policy version that you want to make the default one (the active one).
        :param pulumi.Input[_builtins.str] last_modification_date: The date and time (UTC) of the last modification of the user group.
        """
        pulumi.set(__self__, "policy_orn", policy_orn)
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if default_version_id is not None:
            pulumi.set(__self__, "default_version_id", default_version_id)
        if last_modification_date is not None:
            pulumi.set(__self__, "last_modification_date", last_modification_date)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="policyOrn")
    def policy_orn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "policy_orn")

    @policy_orn.setter
    def policy_orn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_orn", value)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of creation of the user group.
        """
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creation_date", value)

    @_builtins.property
    @pulumi.getter(name="defaultVersionId")
    def default_version_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a policy version that you want to make the default one (the active one).
        """
        return pulumi.get(self, "default_version_id")

    @default_version_id.setter
    def default_version_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_version_id", value)

    @_builtins.property
    @pulumi.getter(name="lastModificationDate")
    def last_modification_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of the last modification of the user group.
        """
        return pulumi.get(self, "last_modification_date")

    @last_modification_date.setter
    def last_modification_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modification_date", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class UserGroupUserArgsDict(TypedDict):
        user_name: pulumi.Input[_builtins.str]
        creation_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of creation of the user group.
        """
        last_modification_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of the last modification of the user group.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the group. If not specified, it is set to a slash (`/`).
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    UserGroupUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupUserArgs:
    def __init__(__self__, *,
                 user_name: pulumi.Input[_builtins.str],
                 creation_date: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modification_date: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] creation_date: The date and time (UTC) of creation of the user group.
        :param pulumi.Input[_builtins.str] last_modification_date: The date and time (UTC) of the last modification of the user group.
        :param pulumi.Input[_builtins.str] path: The path to the group. If not specified, it is set to a slash (`/`).
        """
        pulumi.set(__self__, "user_name", user_name)
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if last_modification_date is not None:
            pulumi.set(__self__, "last_modification_date", last_modification_date)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of creation of the user group.
        """
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creation_date", value)

    @_builtins.property
    @pulumi.getter(name="lastModificationDate")
    def last_modification_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of the last modification of the user group.
        """
        return pulumi.get(self, "last_modification_date")

    @last_modification_date.setter
    def last_modification_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modification_date", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the group. If not specified, it is set to a slash (`/`).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class UserPolicyArgsDict(TypedDict):
        policy_orn: pulumi.Input[_builtins.str]
        creation_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of creation of the EIM user.
        """
        default_version_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a policy version that you want to make the default one (the active one).
        """
        last_modification_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of the last modification of the EIM user.
        """
        policy_id: NotRequired[pulumi.Input[_builtins.str]]
        policy_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    UserPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPolicyArgs:
    def __init__(__self__, *,
                 policy_orn: pulumi.Input[_builtins.str],
                 creation_date: Optional[pulumi.Input[_builtins.str]] = None,
                 default_version_id: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modification_date: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] creation_date: The date and time (UTC) of creation of the EIM user.
        :param pulumi.Input[_builtins.str] default_version_id: The ID of a policy version that you want to make the default one (the active one).
        :param pulumi.Input[_builtins.str] last_modification_date: The date and time (UTC) of the last modification of the EIM user.
        """
        pulumi.set(__self__, "policy_orn", policy_orn)
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if default_version_id is not None:
            pulumi.set(__self__, "default_version_id", default_version_id)
        if last_modification_date is not None:
            pulumi.set(__self__, "last_modification_date", last_modification_date)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="policyOrn")
    def policy_orn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "policy_orn")

    @policy_orn.setter
    def policy_orn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_orn", value)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of creation of the EIM user.
        """
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creation_date", value)

    @_builtins.property
    @pulumi.getter(name="defaultVersionId")
    def default_version_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a policy version that you want to make the default one (the active one).
        """
        return pulumi.get(self, "default_version_id")

    @default_version_id.setter
    def default_version_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_version_id", value)

    @_builtins.property
    @pulumi.getter(name="lastModificationDate")
    def last_modification_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of the last modification of the EIM user.
        """
        return pulumi.get(self, "last_modification_date")

    @last_modification_date.setter
    def last_modification_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modification_date", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_name", value)


if not MYPY:
    class VirtualGatewayLinkNetToVirtualGatewayLinkArgsDict(TypedDict):
        net_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Net to which you want to attach the virtual gateway.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the attachment (`attaching` \\| `attached` \\| `detaching` \\| `detached`).
        """
elif False:
    VirtualGatewayLinkNetToVirtualGatewayLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewayLinkNetToVirtualGatewayLinkArgs:
    def __init__(__self__, *,
                 net_id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] net_id: The ID of the Net to which you want to attach the virtual gateway.
        :param pulumi.Input[_builtins.str] state: The state of the attachment (`attaching` \\| `attached` \\| `detaching` \\| `detached`).
        """
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Net to which you want to attach the virtual gateway.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "net_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the attachment (`attaching` \\| `attached` \\| `detaching` \\| `detached`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class VirtualGatewayNetToVirtualGatewayLinkArgsDict(TypedDict):
        net_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Net to which the virtual gateway is attached.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the virtual gateway (`pending` \\| `available` \\| `deleting` \\| `deleted`).
        """
elif False:
    VirtualGatewayNetToVirtualGatewayLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewayNetToVirtualGatewayLinkArgs:
    def __init__(__self__, *,
                 net_id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] net_id: The ID of the Net to which the virtual gateway is attached.
        :param pulumi.Input[_builtins.str] state: The state of the virtual gateway (`pending` \\| `available` \\| `deleting` \\| `deleted`).
        """
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Net to which the virtual gateway is attached.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "net_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the virtual gateway (`pending` \\| `available` \\| `deleting` \\| `deleted`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class VirtualGatewayTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    VirtualGatewayTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualGatewayTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmActionsOnNextBootArgsDict(TypedDict):
        secure_boot: NotRequired[pulumi.Input[_builtins.str]]
        """
        One action to perform on the next boot of the VM (`enable` | `disable` | `setup-mode` |`none`). For more information, see [About Secure Boot](https://docs.outscale.com/en/userguide/About-Secure-Boot.html#_secure_boot_actions).
        """
elif False:
    VmActionsOnNextBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmActionsOnNextBootArgs:
    def __init__(__self__, *,
                 secure_boot: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secure_boot: One action to perform on the next boot of the VM (`enable` | `disable` | `setup-mode` |`none`). For more information, see [About Secure Boot](https://docs.outscale.com/en/userguide/About-Secure-Boot.html#_secure_boot_actions).
        """
        if secure_boot is not None:
            pulumi.set(__self__, "secure_boot", secure_boot)

    @_builtins.property
    @pulumi.getter(name="secureBoot")
    def secure_boot(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        One action to perform on the next boot of the VM (`enable` | `disable` | `setup-mode` |`none`). For more information, see [About Secure Boot](https://docs.outscale.com/en/userguide/About-Secure-Boot.html#_secure_boot_actions).
        """
        return pulumi.get(self, "secure_boot")

    @secure_boot.setter
    def secure_boot(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure_boot", value)


if not MYPY:
    class VmBlockDeviceMappingArgsDict(TypedDict):
        bsu: NotRequired[pulumi.Input['VmBlockDeviceMappingBsuArgsDict']]
        """
        Information about the BSU volume to create.
        """
        device_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the device.
        """
        no_device: NotRequired[pulumi.Input[_builtins.str]]
        virtual_device_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VmBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 bsu: Optional[pulumi.Input['VmBlockDeviceMappingBsuArgs']] = None,
                 device_name: Optional[pulumi.Input[_builtins.str]] = None,
                 no_device: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_device_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['VmBlockDeviceMappingBsuArgs'] bsu: Information about the BSU volume to create.
        :param pulumi.Input[_builtins.str] device_name: The name of the device.
        """
        if bsu is not None:
            pulumi.set(__self__, "bsu", bsu)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_device_name is not None:
            pulumi.set(__self__, "virtual_device_name", virtual_device_name)

    @_builtins.property
    @pulumi.getter
    def bsu(self) -> Optional[pulumi.Input['VmBlockDeviceMappingBsuArgs']]:
        """
        Information about the BSU volume to create.
        """
        return pulumi.get(self, "bsu")

    @bsu.setter
    def bsu(self, value: Optional[pulumi.Input['VmBlockDeviceMappingBsuArgs']]):
        pulumi.set(self, "bsu", value)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the device.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_device", value)

    @_builtins.property
    @pulumi.getter(name="virtualDeviceName")
    def virtual_device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "virtual_device_name")

    @virtual_device_name.setter
    def virtual_device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_device_name", value)


if not MYPY:
    class VmBlockDeviceMappingBsuArgsDict(TypedDict):
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot used to create the volume.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingBsuTagArgsDict']]]]
        """
        One or more tags associated with the VM.
        """
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume, in gibibytes (GiB).
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VmBlockDeviceMappingBsuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBlockDeviceMappingBsuArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingBsuTagArgs']]]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        :param pulumi.Input[_builtins.int] iops: The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot used to create the volume.
        :param pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingBsuTagArgs']]] tags: One or more tags associated with the VM.
        :param pulumi.Input[_builtins.int] volume_size: The size of the volume, in gibibytes (GiB).
        """
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot used to create the volume.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingBsuTagArgs']]]]:
        """
        One or more tags associated with the VM.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingBsuTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume, in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class VmBlockDeviceMappingBsuTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    VmBlockDeviceMappingBsuTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBlockDeviceMappingBsuTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmBlockDeviceMappingsCreatedArgsDict(TypedDict):
        bsus: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusArgsDict']]]]
        """
        Information about the created BSU volume.
        """
        device_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the device.
        """
elif False:
    VmBlockDeviceMappingsCreatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBlockDeviceMappingsCreatedArgs:
    def __init__(__self__, *,
                 bsus: Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusArgs']]]] = None,
                 device_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusArgs']]] bsus: Information about the created BSU volume.
        :param pulumi.Input[_builtins.str] device_name: The name of the device.
        """
        if bsus is not None:
            pulumi.set(__self__, "bsus", bsus)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)

    @_builtins.property
    @pulumi.getter
    def bsus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusArgs']]]]:
        """
        Information about the created BSU volume.
        """
        return pulumi.get(self, "bsus")

    @bsus.setter
    def bsus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusArgs']]]]):
        pulumi.set(self, "bsus", value)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the device.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_name", value)


if not MYPY:
    class VmBlockDeviceMappingsCreatedBsusArgsDict(TypedDict):
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        link_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) at which the volume was attached to the VM, in ISO 8601 date-time format.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusTagArgsDict']]]]
        """
        A tag to add to this resource. You can specify this argument several times.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the volume.
        """
elif False:
    VmBlockDeviceMappingsCreatedBsusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBlockDeviceMappingsCreatedBsusArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_date: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusTagArgs']]]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: If true, the NIC is deleted when the VM is terminated.
        :param pulumi.Input[_builtins.str] link_date: The date and time (UTC) at which the volume was attached to the VM, in ISO 8601 date-time format.
        :param pulumi.Input[_builtins.str] state: The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        :param pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusTagArgs']]] tags: A tag to add to this resource. You can specify this argument several times.
        :param pulumi.Input[_builtins.str] volume_id: The ID of the volume.
        """
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if link_date is not None:
            pulumi.set(__self__, "link_date", link_date)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter(name="linkDate")
    def link_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) at which the volume was attached to the VM, in ISO 8601 date-time format.
        """
        return pulumi.get(self, "link_date")

    @link_date.setter
    def link_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_date", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusTagArgs']]]]:
        """
        A tag to add to this resource. You can specify this argument several times.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmBlockDeviceMappingsCreatedBsusTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the volume.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VmBlockDeviceMappingsCreatedBsusTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    VmBlockDeviceMappingsCreatedBsusTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBlockDeviceMappingsCreatedBsusTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmNicArgsDict(TypedDict):
        device_number: pulumi.Input[_builtins.int]
        """
        The index of the VM device for the NIC attachment (between `1` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the NIC.
        """
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the NIC, if you are creating a NIC when creating the VM.
        """
        is_source_dest_checked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Net only) If true, the source/destination check is enabled. If false, it is disabled.
        """
        link_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmNicLinkNicArgsDict']]]]
        """
        Information about the network interface card (NIC).
        """
        link_public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmNicLinkPublicIpArgsDict']]]]
        """
        Information about the public IP associated with the NIC.
        """
        mac_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Media Access Control (MAC) address of the NIC.
        """
        net_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Net for the NIC.
        """
        nic_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the NIC, if you are attaching an existing NIC when creating a VM.
        """
        private_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the private DNS.
        """
        private_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpArgsDict']]]]
        """
        One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
        """
        secondary_private_ip_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `private_ips` parameter.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmNicSecurityGroupArgsDict']]]]
        """
        One or more security groups associated with the VM.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
        """
elif False:
    VmNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNicArgs:
    def __init__(__self__, *,
                 device_number: pulumi.Input[_builtins.int],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 is_source_dest_checked: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_nics: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicLinkNicArgs']]]] = None,
                 link_public_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicLinkPublicIpArgs']]]] = None,
                 mac_address: Optional[pulumi.Input[_builtins.str]] = None,
                 net_id: Optional[pulumi.Input[_builtins.str]] = None,
                 nic_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpArgs']]]] = None,
                 secondary_private_ip_count: Optional[pulumi.Input[_builtins.int]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicSecurityGroupArgs']]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] device_number: The index of the VM device for the NIC attachment (between `1` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the NIC.
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
        :param pulumi.Input[_builtins.str] description: The description of the NIC, if you are creating a NIC when creating the VM.
        :param pulumi.Input[_builtins.bool] is_source_dest_checked: (Net only) If true, the source/destination check is enabled. If false, it is disabled.
        :param pulumi.Input[Sequence[pulumi.Input['VmNicLinkNicArgs']]] link_nics: Information about the network interface card (NIC).
        :param pulumi.Input[Sequence[pulumi.Input['VmNicLinkPublicIpArgs']]] link_public_ips: Information about the public IP associated with the NIC.
        :param pulumi.Input[_builtins.str] mac_address: The Media Access Control (MAC) address of the NIC.
        :param pulumi.Input[_builtins.str] net_id: The ID of the Net for the NIC.
        :param pulumi.Input[_builtins.str] nic_id: The ID of the NIC, if you are attaching an existing NIC when creating a VM.
        :param pulumi.Input[_builtins.str] private_dns_name: The name of the private DNS.
        :param pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpArgs']]] private_ips: One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
        :param pulumi.Input[_builtins.int] secondary_private_ip_count: The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `private_ips` parameter.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
        :param pulumi.Input[Sequence[pulumi.Input['VmNicSecurityGroupArgs']]] security_groups: One or more security groups associated with the VM.
        :param pulumi.Input[_builtins.str] state: The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
        """
        pulumi.set(__self__, "device_number", device_number)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_source_dest_checked is not None:
            pulumi.set(__self__, "is_source_dest_checked", is_source_dest_checked)
        if link_nics is not None:
            pulumi.set(__self__, "link_nics", link_nics)
        if link_public_ips is not None:
            pulumi.set(__self__, "link_public_ips", link_public_ips)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if nic_id is not None:
            pulumi.set(__self__, "nic_id", nic_id)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ips is not None:
            pulumi.set(__self__, "private_ips", private_ips)
        if secondary_private_ip_count is not None:
            pulumi.set(__self__, "secondary_private_ip_count", secondary_private_ip_count)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the VM device for the NIC attachment (between `1` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
        """
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "device_number", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the NIC.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the NIC, if you are creating a NIC when creating the VM.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="isSourceDestChecked")
    def is_source_dest_checked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Net only) If true, the source/destination check is enabled. If false, it is disabled.
        """
        return pulumi.get(self, "is_source_dest_checked")

    @is_source_dest_checked.setter
    def is_source_dest_checked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_source_dest_checked", value)

    @_builtins.property
    @pulumi.getter(name="linkNics")
    def link_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmNicLinkNicArgs']]]]:
        """
        Information about the network interface card (NIC).
        """
        return pulumi.get(self, "link_nics")

    @link_nics.setter
    def link_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicLinkNicArgs']]]]):
        pulumi.set(self, "link_nics", value)

    @_builtins.property
    @pulumi.getter(name="linkPublicIps")
    def link_public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmNicLinkPublicIpArgs']]]]:
        """
        Information about the public IP associated with the NIC.
        """
        return pulumi.get(self, "link_public_ips")

    @link_public_ips.setter
    def link_public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicLinkPublicIpArgs']]]]):
        pulumi.set(self, "link_public_ips", value)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Media Access Control (MAC) address of the NIC.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac_address", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Net for the NIC.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "net_id", value)

    @_builtins.property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the NIC, if you are attaching an existing NIC when creating a VM.
        """
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nic_id", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the private DNS.
        """
        return pulumi.get(self, "private_dns_name")

    @private_dns_name.setter
    def private_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="privateIps")
    def private_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpArgs']]]]:
        """
        One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
        """
        return pulumi.get(self, "private_ips")

    @private_ips.setter
    def private_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpArgs']]]]):
        pulumi.set(self, "private_ips", value)

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpCount")
    def secondary_private_ip_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `private_ips` parameter.
        """
        return pulumi.get(self, "secondary_private_ip_count")

    @secondary_private_ip_count.setter
    def secondary_private_ip_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "secondary_private_ip_count", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmNicSecurityGroupArgs']]]]:
        """
        One or more security groups associated with the VM.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicSecurityGroupArgs']]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class VmNicLinkNicArgsDict(TypedDict):
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        device_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device index for the NIC attachment (between `1` and `7`, both included).
        """
        link_nic_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the NIC to attach.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
elif False:
    VmNicLinkNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNicLinkNicArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 device_number: Optional[pulumi.Input[_builtins.str]] = None,
                 link_nic_id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: If true, the NIC is deleted when the VM is terminated.
        :param pulumi.Input[_builtins.str] device_number: The device index for the NIC attachment (between `1` and `7`, both included).
        :param pulumi.Input[_builtins.str] link_nic_id: The ID of the NIC to attach.
        :param pulumi.Input[_builtins.str] state: The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if link_nic_id is not None:
            pulumi.set(__self__, "link_nic_id", link_nic_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device index for the NIC attachment (between `1` and `7`, both included).
        """
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_number", value)

    @_builtins.property
    @pulumi.getter(name="linkNicId")
    def link_nic_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the NIC to attach.
        """
        return pulumi.get(self, "link_nic_id")

    @link_nic_id.setter
    def link_nic_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_nic_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class VmNicLinkPublicIpArgsDict(TypedDict):
        public_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the public DNS.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP of the VM.
        """
        public_ip_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the public IP.
        """
elif False:
    VmNicLinkPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNicLinkPublicIpArgs:
    def __init__(__self__, *,
                 public_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_account_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] public_dns_name: The name of the public DNS.
        :param pulumi.Input[_builtins.str] public_ip: The public IP of the VM.
        :param pulumi.Input[_builtins.str] public_ip_account_id: The account ID of the owner of the public IP.
        """
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_account_id is not None:
            pulumi.set(__self__, "public_ip_account_id", public_ip_account_id)

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the public DNS.
        """
        return pulumi.get(self, "public_dns_name")

    @public_dns_name.setter
    def public_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP of the VM.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAccountId")
    def public_ip_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the public IP.
        """
        return pulumi.get(self, "public_ip_account_id")

    @public_ip_account_id.setter
    def public_ip_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_account_id", value)


if not MYPY:
    class VmNicPrivateIpArgsDict(TypedDict):
        is_primary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the IP is the primary private IP of the NIC.
        """
        link_public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpLinkPublicIpArgsDict']]]]
        """
        Information about the public IP associated with the NIC.
        """
        private_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the private DNS.
        """
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP of the NIC.
        """
elif False:
    VmNicPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNicPrivateIpArgs:
    def __init__(__self__, *,
                 is_primary: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_public_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpLinkPublicIpArgs']]]] = None,
                 private_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_primary: If true, the IP is the primary private IP of the NIC.
        :param pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpLinkPublicIpArgs']]] link_public_ips: Information about the public IP associated with the NIC.
        :param pulumi.Input[_builtins.str] private_dns_name: The name of the private DNS.
        :param pulumi.Input[_builtins.str] private_ip: The private IP of the NIC.
        """
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if link_public_ips is not None:
            pulumi.set(__self__, "link_public_ips", link_public_ips)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the IP is the primary private IP of the NIC.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_primary", value)

    @_builtins.property
    @pulumi.getter(name="linkPublicIps")
    def link_public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpLinkPublicIpArgs']]]]:
        """
        Information about the public IP associated with the NIC.
        """
        return pulumi.get(self, "link_public_ips")

    @link_public_ips.setter
    def link_public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmNicPrivateIpLinkPublicIpArgs']]]]):
        pulumi.set(self, "link_public_ips", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the private DNS.
        """
        return pulumi.get(self, "private_dns_name")

    @private_dns_name.setter
    def private_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP of the NIC.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class VmNicPrivateIpLinkPublicIpArgsDict(TypedDict):
        public_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the public DNS.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP of the VM.
        """
        public_ip_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the public IP.
        """
elif False:
    VmNicPrivateIpLinkPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNicPrivateIpLinkPublicIpArgs:
    def __init__(__self__, *,
                 public_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_account_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] public_dns_name: The name of the public DNS.
        :param pulumi.Input[_builtins.str] public_ip: The public IP of the VM.
        :param pulumi.Input[_builtins.str] public_ip_account_id: The account ID of the owner of the public IP.
        """
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_account_id is not None:
            pulumi.set(__self__, "public_ip_account_id", public_ip_account_id)

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the public DNS.
        """
        return pulumi.get(self, "public_dns_name")

    @public_dns_name.setter
    def public_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP of the VM.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAccountId")
    def public_ip_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the public IP.
        """
        return pulumi.get(self, "public_ip_account_id")

    @public_ip_account_id.setter
    def public_ip_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_account_id", value)


if not MYPY:
    class VmNicSecurityGroupArgsDict(TypedDict):
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    VmNicSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNicSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_id: The ID of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class VmPrimaryNicArgsDict(TypedDict):
        device_number: pulumi.Input[_builtins.int]
        """
        The index of the VM device for the NIC attachment (must be `0`). This parameter is required if you create a NIC when creating the VM.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the NIC.
        """
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the NIC, if you are creating a NIC when creating the VM.
        """
        is_source_dest_checked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Net only) If true, the source/destination check is enabled. If false, it is disabled.
        """
        link_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkNicArgsDict']]]]
        """
        Information about the network interface card (NIC).
        """
        link_public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkPublicIpArgsDict']]]]
        """
        Information about the public IP associated with the NIC.
        """
        mac_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Media Access Control (MAC) address of the NIC.
        """
        net_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Net for the NIC.
        """
        nic_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the NIC, if you are attaching an existing NIC when creating a VM.
        """
        private_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the private DNS.
        """
        private_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpArgsDict']]]]
        """
        One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
        """
        secondary_private_ip_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `private_ips` parameter.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicSecurityGroupArgsDict']]]]
        """
        One or more security groups associated with the VM.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
        """
elif False:
    VmPrimaryNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmPrimaryNicArgs:
    def __init__(__self__, *,
                 device_number: pulumi.Input[_builtins.int],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 is_source_dest_checked: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_nics: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkNicArgs']]]] = None,
                 link_public_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkPublicIpArgs']]]] = None,
                 mac_address: Optional[pulumi.Input[_builtins.str]] = None,
                 net_id: Optional[pulumi.Input[_builtins.str]] = None,
                 nic_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpArgs']]]] = None,
                 secondary_private_ip_count: Optional[pulumi.Input[_builtins.int]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicSecurityGroupArgs']]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] device_number: The index of the VM device for the NIC attachment (must be `0`). This parameter is required if you create a NIC when creating the VM.
        :param pulumi.Input[_builtins.str] account_id: The account ID of the owner of the NIC.
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
        :param pulumi.Input[_builtins.str] description: The description of the NIC, if you are creating a NIC when creating the VM.
        :param pulumi.Input[_builtins.bool] is_source_dest_checked: (Net only) If true, the source/destination check is enabled. If false, it is disabled.
        :param pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkNicArgs']]] link_nics: Information about the network interface card (NIC).
        :param pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkPublicIpArgs']]] link_public_ips: Information about the public IP associated with the NIC.
        :param pulumi.Input[_builtins.str] mac_address: The Media Access Control (MAC) address of the NIC.
        :param pulumi.Input[_builtins.str] net_id: The ID of the Net for the NIC.
        :param pulumi.Input[_builtins.str] nic_id: The ID of the NIC, if you are attaching an existing NIC when creating a VM.
        :param pulumi.Input[_builtins.str] private_dns_name: The name of the private DNS.
        :param pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpArgs']]] private_ips: One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
        :param pulumi.Input[_builtins.int] secondary_private_ip_count: The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `private_ips` parameter.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
        :param pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicSecurityGroupArgs']]] security_groups: One or more security groups associated with the VM.
        :param pulumi.Input[_builtins.str] state: The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
        """
        pulumi.set(__self__, "device_number", device_number)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_source_dest_checked is not None:
            pulumi.set(__self__, "is_source_dest_checked", is_source_dest_checked)
        if link_nics is not None:
            pulumi.set(__self__, "link_nics", link_nics)
        if link_public_ips is not None:
            pulumi.set(__self__, "link_public_ips", link_public_ips)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if nic_id is not None:
            pulumi.set(__self__, "nic_id", nic_id)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ips is not None:
            pulumi.set(__self__, "private_ips", private_ips)
        if secondary_private_ip_count is not None:
            pulumi.set(__self__, "secondary_private_ip_count", secondary_private_ip_count)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the VM device for the NIC attachment (must be `0`). This parameter is required if you create a NIC when creating the VM.
        """
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "device_number", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the NIC.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](https://docs.outscale.com/api#updatenic).
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the NIC, if you are creating a NIC when creating the VM.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="isSourceDestChecked")
    def is_source_dest_checked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Net only) If true, the source/destination check is enabled. If false, it is disabled.
        """
        return pulumi.get(self, "is_source_dest_checked")

    @is_source_dest_checked.setter
    def is_source_dest_checked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_source_dest_checked", value)

    @_builtins.property
    @pulumi.getter(name="linkNics")
    def link_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkNicArgs']]]]:
        """
        Information about the network interface card (NIC).
        """
        return pulumi.get(self, "link_nics")

    @link_nics.setter
    def link_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkNicArgs']]]]):
        pulumi.set(self, "link_nics", value)

    @_builtins.property
    @pulumi.getter(name="linkPublicIps")
    def link_public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkPublicIpArgs']]]]:
        """
        Information about the public IP associated with the NIC.
        """
        return pulumi.get(self, "link_public_ips")

    @link_public_ips.setter
    def link_public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicLinkPublicIpArgs']]]]):
        pulumi.set(self, "link_public_ips", value)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Media Access Control (MAC) address of the NIC.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac_address", value)

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Net for the NIC.
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "net_id", value)

    @_builtins.property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the NIC, if you are attaching an existing NIC when creating a VM.
        """
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nic_id", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the private DNS.
        """
        return pulumi.get(self, "private_dns_name")

    @private_dns_name.setter
    def private_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="privateIps")
    def private_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpArgs']]]]:
        """
        One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
        """
        return pulumi.get(self, "private_ips")

    @private_ips.setter
    def private_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpArgs']]]]):
        pulumi.set(self, "private_ips", value)

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpCount")
    def secondary_private_ip_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `private_ips` parameter.
        """
        return pulumi.get(self, "secondary_private_ip_count")

    @secondary_private_ip_count.setter
    def secondary_private_ip_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "secondary_private_ip_count", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicSecurityGroupArgs']]]]:
        """
        One or more security groups associated with the VM.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicSecurityGroupArgs']]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class VmPrimaryNicLinkNicArgsDict(TypedDict):
        delete_on_vm_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        device_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device index for the NIC attachment (between `1` and `7`, both included).
        """
        link_nic_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the NIC to attach.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
elif False:
    VmPrimaryNicLinkNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmPrimaryNicLinkNicArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 device_number: Optional[pulumi.Input[_builtins.str]] = None,
                 link_nic_id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: If true, the NIC is deleted when the VM is terminated.
        :param pulumi.Input[_builtins.str] device_number: The device index for the NIC attachment (between `1` and `7`, both included).
        :param pulumi.Input[_builtins.str] link_nic_id: The ID of the NIC to attach.
        :param pulumi.Input[_builtins.str] state: The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        if delete_on_vm_deletion is not None:
            pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if link_nic_id is not None:
            pulumi.set(__self__, "link_nic_id", link_nic_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the NIC is deleted when the VM is terminated.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device index for the NIC attachment (between `1` and `7`, both included).
        """
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_number", value)

    @_builtins.property
    @pulumi.getter(name="linkNicId")
    def link_nic_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the NIC to attach.
        """
        return pulumi.get(self, "link_nic_id")

    @link_nic_id.setter
    def link_nic_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_nic_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the VM (`running` | `stopped`). If set to `stopped`, the VM is stopped regardless of the value of the `vm_initiated_shutdown_behavior` argument.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class VmPrimaryNicLinkPublicIpArgsDict(TypedDict):
        public_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the public DNS.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP of the VM.
        """
        public_ip_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the public IP.
        """
elif False:
    VmPrimaryNicLinkPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmPrimaryNicLinkPublicIpArgs:
    def __init__(__self__, *,
                 public_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_account_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] public_dns_name: The name of the public DNS.
        :param pulumi.Input[_builtins.str] public_ip: The public IP of the VM.
        :param pulumi.Input[_builtins.str] public_ip_account_id: The account ID of the owner of the public IP.
        """
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_account_id is not None:
            pulumi.set(__self__, "public_ip_account_id", public_ip_account_id)

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the public DNS.
        """
        return pulumi.get(self, "public_dns_name")

    @public_dns_name.setter
    def public_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP of the VM.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAccountId")
    def public_ip_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the public IP.
        """
        return pulumi.get(self, "public_ip_account_id")

    @public_ip_account_id.setter
    def public_ip_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_account_id", value)


if not MYPY:
    class VmPrimaryNicPrivateIpArgsDict(TypedDict):
        is_primary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the IP is the primary private IP of the NIC.
        """
        link_public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpLinkPublicIpArgsDict']]]]
        """
        Information about the public IP associated with the NIC.
        """
        private_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the private DNS.
        """
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP of the NIC.
        """
elif False:
    VmPrimaryNicPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmPrimaryNicPrivateIpArgs:
    def __init__(__self__, *,
                 is_primary: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_public_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpLinkPublicIpArgs']]]] = None,
                 private_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_primary: If true, the IP is the primary private IP of the NIC.
        :param pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpLinkPublicIpArgs']]] link_public_ips: Information about the public IP associated with the NIC.
        :param pulumi.Input[_builtins.str] private_dns_name: The name of the private DNS.
        :param pulumi.Input[_builtins.str] private_ip: The private IP of the NIC.
        """
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if link_public_ips is not None:
            pulumi.set(__self__, "link_public_ips", link_public_ips)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the IP is the primary private IP of the NIC.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_primary", value)

    @_builtins.property
    @pulumi.getter(name="linkPublicIps")
    def link_public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpLinkPublicIpArgs']]]]:
        """
        Information about the public IP associated with the NIC.
        """
        return pulumi.get(self, "link_public_ips")

    @link_public_ips.setter
    def link_public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmPrimaryNicPrivateIpLinkPublicIpArgs']]]]):
        pulumi.set(self, "link_public_ips", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the private DNS.
        """
        return pulumi.get(self, "private_dns_name")

    @private_dns_name.setter
    def private_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP of the NIC.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class VmPrimaryNicPrivateIpLinkPublicIpArgsDict(TypedDict):
        public_dns_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the public DNS.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP of the VM.
        """
        public_ip_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID of the owner of the public IP.
        """
elif False:
    VmPrimaryNicPrivateIpLinkPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmPrimaryNicPrivateIpLinkPublicIpArgs:
    def __init__(__self__, *,
                 public_dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_account_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] public_dns_name: The name of the public DNS.
        :param pulumi.Input[_builtins.str] public_ip: The public IP of the VM.
        :param pulumi.Input[_builtins.str] public_ip_account_id: The account ID of the owner of the public IP.
        """
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_account_id is not None:
            pulumi.set(__self__, "public_ip_account_id", public_ip_account_id)

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the public DNS.
        """
        return pulumi.get(self, "public_dns_name")

    @public_dns_name.setter
    def public_dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_dns_name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP of the VM.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpAccountId")
    def public_ip_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID of the owner of the public IP.
        """
        return pulumi.get(self, "public_ip_account_id")

    @public_ip_account_id.setter
    def public_ip_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_account_id", value)


if not MYPY:
    class VmPrimaryNicSecurityGroupArgsDict(TypedDict):
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    VmPrimaryNicSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmPrimaryNicSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_id: The ID of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class VmSecurityGroupArgsDict(TypedDict):
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the security group.
        """
        security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the security group.
        """
elif False:
    VmSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmSecurityGroupArgs:
    def __init__(__self__, *,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_group_id: The ID of the security group.
        :param pulumi.Input[_builtins.str] security_group_name: The name of the security group.
        """
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the security group.
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_name", value)


if not MYPY:
    class VmTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    VmTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VolumeLinkTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    VolumeLinkTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeLinkTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class VolumeLinkedVolumeArgsDict(TypedDict):
        delete_on_vm_deletion: pulumi.Input[_builtins.bool]
        """
        If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        device_name: pulumi.Input[_builtins.str]
        """
        The name of the device.
        """
        state: pulumi.Input[_builtins.str]
        """
        The state of the volume (`creating` \\| `available` \\| `in-use` \\| `updating` \\| `deleting` \\| `error`).
        """
        vm_id: pulumi.Input[_builtins.str]
        """
        The ID of the VM.
        """
        volume_id: pulumi.Input[_builtins.str]
        """
        The ID of the volume.
        """
elif False:
    VolumeLinkedVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeLinkedVolumeArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: pulumi.Input[_builtins.bool],
                 device_name: pulumi.Input[_builtins.str],
                 state: pulumi.Input[_builtins.str],
                 vm_id: pulumi.Input[_builtins.str],
                 volume_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] delete_on_vm_deletion: If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        :param pulumi.Input[_builtins.str] device_name: The name of the device.
        :param pulumi.Input[_builtins.str] state: The state of the volume (`creating` \\| `available` \\| `in-use` \\| `updating` \\| `deleting` \\| `error`).
        :param pulumi.Input[_builtins.str] vm_id: The ID of the VM.
        :param pulumi.Input[_builtins.str] volume_id: The ID of the volume.
        """
        pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vm_id", vm_id)
        pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> pulumi.Input[_builtins.bool]:
        """
        If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the device.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        The state of the volume (`creating` \\| `available` \\| `in-use` \\| `updating` \\| `deleting` \\| `error`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the VM.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vm_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the volume.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VolumeTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    VolumeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VolumeTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    VolumeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class VpnConnectionRouteArgsDict(TypedDict):
        destination_ip_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
        """
        route_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of route (always `static`).
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the IPSEC tunnel (`UP` \\| `DOWN`).
        """
elif False:
    VpnConnectionRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionRouteArgs:
    def __init__(__self__, *,
                 destination_ip_range: Optional[pulumi.Input[_builtins.str]] = None,
                 route_type: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_ip_range: The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
        :param pulumi.Input[_builtins.str] route_type: The type of route (always `static`).
        :param pulumi.Input[_builtins.str] state: The state of the IPSEC tunnel (`UP` \\| `DOWN`).
        """
        if destination_ip_range is not None:
            pulumi.set(__self__, "destination_ip_range", destination_ip_range)
        if route_type is not None:
            pulumi.set(__self__, "route_type", route_type)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="destinationIpRange")
    def destination_ip_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
        """
        return pulumi.get(self, "destination_ip_range")

    @destination_ip_range.setter
    def destination_ip_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_ip_range", value)

    @_builtins.property
    @pulumi.getter(name="routeType")
    def route_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of route (always `static`).
        """
        return pulumi.get(self, "route_type")

    @route_type.setter
    def route_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_type", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the IPSEC tunnel (`UP` \\| `DOWN`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class VpnConnectionTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    VpnConnectionTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the tag, with a minimum of 1 character.
        :param pulumi.Input[_builtins.str] value: The value of the tag, between 0 and 255 characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionVgwTelemetryArgsDict(TypedDict):
        accepted_route_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
        """
        last_state_change_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time (UTC) of the latest state update.
        """
        outside_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP on the OUTSCALE side of the tunnel.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the IPSEC tunnel (`UP` \\| `DOWN`).
        """
        state_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the current state of the tunnel.
        """
elif False:
    VpnConnectionVgwTelemetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionVgwTelemetryArgs:
    def __init__(__self__, *,
                 accepted_route_count: Optional[pulumi.Input[_builtins.int]] = None,
                 last_state_change_date: Optional[pulumi.Input[_builtins.str]] = None,
                 outside_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 state_description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] accepted_route_count: The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
        :param pulumi.Input[_builtins.str] last_state_change_date: The date and time (UTC) of the latest state update.
        :param pulumi.Input[_builtins.str] outside_ip_address: The IP on the OUTSCALE side of the tunnel.
        :param pulumi.Input[_builtins.str] state: The state of the IPSEC tunnel (`UP` \\| `DOWN`).
        :param pulumi.Input[_builtins.str] state_description: A description of the current state of the tunnel.
        """
        if accepted_route_count is not None:
            pulumi.set(__self__, "accepted_route_count", accepted_route_count)
        if last_state_change_date is not None:
            pulumi.set(__self__, "last_state_change_date", last_state_change_date)
        if outside_ip_address is not None:
            pulumi.set(__self__, "outside_ip_address", outside_ip_address)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @_builtins.property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
        """
        return pulumi.get(self, "accepted_route_count")

    @accepted_route_count.setter
    def accepted_route_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "accepted_route_count", value)

    @_builtins.property
    @pulumi.getter(name="lastStateChangeDate")
    def last_state_change_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time (UTC) of the latest state update.
        """
        return pulumi.get(self, "last_state_change_date")

    @last_state_change_date.setter
    def last_state_change_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_state_change_date", value)

    @_builtins.property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP on the OUTSCALE side of the tunnel.
        """
        return pulumi.get(self, "outside_ip_address")

    @outside_ip_address.setter
    def outside_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outside_ip_address", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the IPSEC tunnel (`UP` \\| `DOWN`).
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the current state of the tunnel.
        """
        return pulumi.get(self, "state_description")

    @state_description.setter
    def state_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state_description", value)


if not MYPY:
    class GetAccessKeyFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetAccessKeyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessKeyFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetAccessKeysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetAccessKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessKeysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetApiAccessRuleFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetApiAccessRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiAccessRuleFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetApiAccessRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetApiAccessRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiAccessRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCaFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetCaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCaFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCasFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetCasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetClientGatewayFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetClientGatewayFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClientGatewayFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetClientGatewaysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetClientGatewaysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClientGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDhcpOptionFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetDhcpOptionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDhcpOptionFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDhcpOptionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetDhcpOptionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDhcpOptionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetFlexibleGpuCatalogFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetFlexibleGpuCatalogFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFlexibleGpuCatalogFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetFlexibleGpuFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetFlexibleGpuFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFlexibleGpuFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetFlexibleGpusFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetFlexibleGpusFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFlexibleGpusFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetImageBlockDeviceMappingArgsDict(TypedDict):
        bsus: Sequence['GetImageBlockDeviceMappingBsusArgsDict']
        """
        Information about the BSU volume to create.
        """
        device_name: _builtins.str
        """
        The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
        """
        virtual_device_name: _builtins.str
        """
        The name of the virtual device (`ephemeralN`).
        """
elif False:
    GetImageBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImageBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 bsus: Sequence['GetImageBlockDeviceMappingBsusArgs'],
                 device_name: _builtins.str,
                 virtual_device_name: _builtins.str):
        """
        :param Sequence['GetImageBlockDeviceMappingBsusArgs'] bsus: Information about the BSU volume to create.
        :param _builtins.str device_name: The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
        :param _builtins.str virtual_device_name: The name of the virtual device (`ephemeralN`).
        """
        pulumi.set(__self__, "bsus", bsus)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_device_name", virtual_device_name)

    @_builtins.property
    @pulumi.getter
    def bsus(self) -> Sequence['GetImageBlockDeviceMappingBsusArgs']:
        """
        Information about the BSU volume to create.
        """
        return pulumi.get(self, "bsus")

    @bsus.setter
    def bsus(self, value: Sequence['GetImageBlockDeviceMappingBsusArgs']):
        pulumi.set(self, "bsus", value)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: _builtins.str):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter(name="virtualDeviceName")
    def virtual_device_name(self) -> _builtins.str:
        """
        The name of the virtual device (`ephemeralN`).
        """
        return pulumi.get(self, "virtual_device_name")

    @virtual_device_name.setter
    def virtual_device_name(self, value: _builtins.str):
        pulumi.set(self, "virtual_device_name", value)


if not MYPY:
    class GetImageBlockDeviceMappingBsusArgsDict(TypedDict):
        delete_on_vm_deletion: _builtins.bool
        """
        By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        iops: _builtins.int
        """
        The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        """
        snapshot_id: _builtins.str
        """
        The ID of the snapshot used to create the volume.
        """
        volume_size: _builtins.int
        """
        The size of the volume, in gibibytes (GiB).<br />
        If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
        If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
        """
        volume_type: _builtins.str
        """
        The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />
        For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
        """
elif False:
    GetImageBlockDeviceMappingBsusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImageBlockDeviceMappingBsusArgs:
    def __init__(__self__, *,
                 delete_on_vm_deletion: _builtins.bool,
                 iops: _builtins.int,
                 snapshot_id: _builtins.str,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.bool delete_on_vm_deletion: By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        :param _builtins.int iops: The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        :param _builtins.str snapshot_id: The ID of the snapshot used to create the volume.
        :param _builtins.int volume_size: The size of the volume, in gibibytes (GiB).<br />
               If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
               If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
        :param _builtins.str volume_type: The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />
               For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
        """
        pulumi.set(__self__, "delete_on_vm_deletion", delete_on_vm_deletion)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnVmDeletion")
    def delete_on_vm_deletion(self) -> _builtins.bool:
        """
        By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
        """
        return pulumi.get(self, "delete_on_vm_deletion")

    @delete_on_vm_deletion.setter
    def delete_on_vm_deletion(self, value: _builtins.bool):
        pulumi.set(self, "delete_on_vm_deletion", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: _builtins.int):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        The ID of the snapshot used to create the volume.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: _builtins.str):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        """
        The size of the volume, in gibibytes (GiB).<br />
        If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
        If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: _builtins.int):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />
        For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: _builtins.str):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class GetImageExportTaskFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetImageExportTaskFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImageExportTaskFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetImageExportTasksFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetImageExportTasksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImageExportTasksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetImageFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetImageFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImageFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetImagesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetImagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetInternetServiceFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetInternetServiceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInternetServiceFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetInternetServicesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetInternetServicesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInternetServicesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetKeypairFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetKeypairFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKeypairFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetKeypairsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetKeypairsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKeypairsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetLoadBalancerAccessLogArgsDict(TypedDict):
        is_enabled: _builtins.bool
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        osu_bucket_name: _builtins.str
        """
        The name of the OOS bucket for the access logs.
        """
        osu_bucket_prefix: _builtins.str
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        publication_interval: _builtins.int
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
elif False:
    GetLoadBalancerAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: _builtins.bool,
                 osu_bucket_name: _builtins.str,
                 osu_bucket_prefix: _builtins.str,
                 publication_interval: _builtins.int):
        """
        :param _builtins.bool is_enabled: If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        :param _builtins.str osu_bucket_name: The name of the OOS bucket for the access logs.
        :param _builtins.str osu_bucket_prefix: The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        :param _builtins.int publication_interval: The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "osu_bucket_name", osu_bucket_name)
        pulumi.set(__self__, "osu_bucket_prefix", osu_bucket_prefix)
        pulumi.set(__self__, "publication_interval", publication_interval)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        If true, access logs are enabled for your load balancer. If false, they are not. If you set this to true in your request, the `osu_bucket_name` parameter is required.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: _builtins.bool):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketName")
    def osu_bucket_name(self) -> _builtins.str:
        """
        The name of the OOS bucket for the access logs.
        """
        return pulumi.get(self, "osu_bucket_name")

    @osu_bucket_name.setter
    def osu_bucket_name(self, value: _builtins.str):
        pulumi.set(self, "osu_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="osuBucketPrefix")
    def osu_bucket_prefix(self) -> _builtins.str:
        """
        The path to the folder of the access logs in your OOS bucket (by default, the `root` level of your bucket).
        """
        return pulumi.get(self, "osu_bucket_prefix")

    @osu_bucket_prefix.setter
    def osu_bucket_prefix(self, value: _builtins.str):
        pulumi.set(self, "osu_bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="publicationInterval")
    def publication_interval(self) -> _builtins.int:
        """
        The time interval for the publication of access logs in the OOS bucket, in minutes. This value can be either `5` or `60` (by default, `60`).
        """
        return pulumi.get(self, "publication_interval")

    @publication_interval.setter
    def publication_interval(self, value: _builtins.int):
        pulumi.set(self, "publication_interval", value)


if not MYPY:
    class GetLoadBalancerFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetLoadBalancerFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetLoadBalancerHealthCheckArgsDict(TypedDict):
        check_interval: _builtins.int
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        healthy_threshold: _builtins.int
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        path: _builtins.str
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        port: _builtins.int
        """
        The port number (between `1` and `65535`, both included).
        """
        protocol: _builtins.str
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        timeout: _builtins.int
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        unhealthy_threshold: _builtins.int
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
elif False:
    GetLoadBalancerHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerHealthCheckArgs:
    def __init__(__self__, *,
                 check_interval: _builtins.int,
                 healthy_threshold: _builtins.int,
                 path: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 timeout: _builtins.int,
                 unhealthy_threshold: _builtins.int):
        """
        :param _builtins.int check_interval: The number of seconds between two requests (between `5` and `600` both included).
        :param _builtins.int healthy_threshold: The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        :param _builtins.str path: If you use the HTTP or HTTPS protocols, the request URL path.
        :param _builtins.int port: The port number (between `1` and `65535`, both included).
        :param _builtins.str protocol: The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param _builtins.int timeout: The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        :param _builtins.int unhealthy_threshold: The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        pulumi.set(__self__, "check_interval", check_interval)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> _builtins.int:
        """
        The number of seconds between two requests (between `5` and `600` both included).
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: _builtins.int):
        pulumi.set(self, "check_interval", value)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: _builtins.int):
        pulumi.set(self, "healthy_threshold", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        If you use the HTTP or HTTPS protocols, the request URL path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: _builtins.int):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: _builtins.int):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class GetLoadBalancerListenerArgsDict(TypedDict):
        backend_port: _builtins.int
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        backend_protocol: _builtins.str
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        load_balancer_port: _builtins.int
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included).
        """
        load_balancer_protocol: _builtins.str
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        policy_names: Sequence[_builtins.str]
        """
        The names of the policies. If there are no policies enabled, the list is empty.
        """
        server_certificate_id: _builtins.str
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
elif False:
    GetLoadBalancerListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerListenerArgs:
    def __init__(__self__, *,
                 backend_port: _builtins.int,
                 backend_protocol: _builtins.str,
                 load_balancer_port: _builtins.int,
                 load_balancer_protocol: _builtins.str,
                 policy_names: Sequence[_builtins.str],
                 server_certificate_id: _builtins.str):
        """
        :param _builtins.int backend_port: The port on which the backend VM is listening (between `1` and `65535`, both included).
        :param _builtins.str backend_protocol: The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param _builtins.int load_balancer_port: The port on which the load balancer is listening (between `1` and `65535`, both included).
        :param _builtins.str load_balancer_protocol: The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        :param Sequence[_builtins.str] policy_names: The names of the policies. If there are no policies enabled, the list is empty.
        :param _builtins.str server_certificate_id: The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
        pulumi.set(__self__, "backend_port", backend_port)
        pulumi.set(__self__, "backend_protocol", backend_protocol)
        pulumi.set(__self__, "load_balancer_port", load_balancer_port)
        pulumi.set(__self__, "load_balancer_protocol", load_balancer_protocol)
        pulumi.set(__self__, "policy_names", policy_names)
        pulumi.set(__self__, "server_certificate_id", server_certificate_id)

    @_builtins.property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> _builtins.int:
        """
        The port on which the backend VM is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: _builtins.int):
        pulumi.set(self, "backend_port", value)

    @_builtins.property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> _builtins.str:
        """
        The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: _builtins.str):
        pulumi.set(self, "backend_protocol", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> _builtins.int:
        """
        The port on which the load balancer is listening (between `1` and `65535`, both included).
        """
        return pulumi.get(self, "load_balancer_port")

    @load_balancer_port.setter
    def load_balancer_port(self, value: _builtins.int):
        pulumi.set(self, "load_balancer_port", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerProtocol")
    def load_balancer_protocol(self) -> _builtins.str:
        """
        The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
        """
        return pulumi.get(self, "load_balancer_protocol")

    @load_balancer_protocol.setter
    def load_balancer_protocol(self, value: _builtins.str):
        pulumi.set(self, "load_balancer_protocol", value)

    @_builtins.property
    @pulumi.getter(name="policyNames")
    def policy_names(self) -> Sequence[_builtins.str]:
        """
        The names of the policies. If there are no policies enabled, the list is empty.
        """
        return pulumi.get(self, "policy_names")

    @policy_names.setter
    def policy_names(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "policy_names", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificateId")
    def server_certificate_id(self) -> _builtins.str:
        """
        The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
        """
        return pulumi.get(self, "server_certificate_id")

    @server_certificate_id.setter
    def server_certificate_id(self, value: _builtins.str):
        pulumi.set(self, "server_certificate_id", value)


if not MYPY:
    class GetLoadBalancerListenerRuleFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetLoadBalancerListenerRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerListenerRuleFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetLoadBalancerListenerRulesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetLoadBalancerListenerRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerListenerRulesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetLoadBalancerTagArgsDict(TypedDict):
        key: _builtins.str
        """
        The key of the tag, with a minimum of 1 character.
        """
        value: _builtins.str
        """
        The value of the tag, between 0 and 255 characters.
        """
elif False:
    GetLoadBalancerTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of the tag, with a minimum of 1 character.
        :param _builtins.str value: The value of the tag, between 0 and 255 characters.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the tag, with a minimum of 1 character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the tag, between 0 and 255 characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetLoadBalancerTagsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetLoadBalancerTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerTagsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetLoadBalancerVmHealthFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetLoadBalancerVmHealthFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerVmHealthFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetLoadBalancersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetLoadBalancersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNatServiceFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNatServiceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNatServiceFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNatServicesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNatServicesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNatServicesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetAccessPointFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNetAccessPointFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetAccessPointFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetAccessPointServicesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNetAccessPointServicesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetAccessPointServicesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetAccessPointsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNetAccessPointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetAccessPointsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetPeeringFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        values: Sequence[_builtins.str]
elif False:
    GetNetPeeringFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetPeeringFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetPeeringsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        values: Sequence[_builtins.str]
elif False:
    GetNetPeeringsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetPeeringsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The state of the Net peering (`pending-acceptance` \\| `active` \\| `rejected` \\| `failed` \\| `expired` \\| `deleted`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNicFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNicFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNicFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNicsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetNicsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNicsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPoliciesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPoliciesLinkedToUserGroupFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetPoliciesLinkedToUserGroupFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPoliciesLinkedToUserGroupFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetProductTypeFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetProductTypeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProductTypeFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetProductTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetProductTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProductTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPublicIpFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetPublicIpFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPublicIpFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPublicIpsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetPublicIpsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPublicIpsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetQuotaFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The unique name of the quota.
        """
        values: Sequence[_builtins.str]
elif False:
    GetQuotaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetQuotaFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The unique name of the quota.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The unique name of the quota.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetQuotasFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The unique name of the quota.
        """
        values: Sequence[_builtins.str]
elif False:
    GetQuotasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetQuotasFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The unique name of the quota.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The unique name of the quota.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRouteTableFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetRouteTableFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteTableFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRouteTablesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetRouteTablesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSecurityGroupFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSecurityGroupFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityGroupFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSecurityGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSecurityGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetServerCertificateFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the server certificate.
        """
        values: Sequence[_builtins.str]
elif False:
    GetServerCertificateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerCertificateFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the server certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the server certificate.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetServerCertificatesFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the server certificate.
        """
        values: Sequence[_builtins.str]
elif False:
    GetServerCertificatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the server certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the server certificate.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSnapshotExportTaskFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSnapshotExportTaskFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSnapshotExportTaskFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSnapshotExportTasksFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSnapshotExportTasksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSnapshotExportTasksFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSnapshotFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSnapshotFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSnapshotFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSnapshotsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSnapshotsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSnapshotsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSubnetFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSubnetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSubnetsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSubnetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSubregionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetSubregionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubregionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetUserFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetUserFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetUserGroupUserArgsDict(TypedDict):
        creation_date: _builtins.str
        """
        The date and time (UTC) of creation of the EIM user.
        """
        last_modification_date: _builtins.str
        """
        The date and time (UTC) of the last modification of the EIM user.
        """
        path: _builtins.str
        """
        The path to the group. If not specified, it is set to a slash (`/`).
        """
        user_email: _builtins.str
        """
        The email address of the EIM user.
        """
        user_id: _builtins.str
        """
        The ID of the EIM user.
        """
        user_name: _builtins.str
        """
        The name of the EIM user.
        """
elif False:
    GetUserGroupUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserGroupUserArgs:
    def __init__(__self__, *,
                 creation_date: _builtins.str,
                 last_modification_date: _builtins.str,
                 path: _builtins.str,
                 user_email: _builtins.str,
                 user_id: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str creation_date: The date and time (UTC) of creation of the EIM user.
        :param _builtins.str last_modification_date: The date and time (UTC) of the last modification of the EIM user.
        :param _builtins.str path: The path to the group. If not specified, it is set to a slash (`/`).
        :param _builtins.str user_email: The email address of the EIM user.
        :param _builtins.str user_id: The ID of the EIM user.
        :param _builtins.str user_name: The name of the EIM user.
        """
        pulumi.set(__self__, "creation_date", creation_date)
        pulumi.set(__self__, "last_modification_date", last_modification_date)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "user_email", user_email)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> _builtins.str:
        """
        The date and time (UTC) of creation of the EIM user.
        """
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: _builtins.str):
        pulumi.set(self, "creation_date", value)

    @_builtins.property
    @pulumi.getter(name="lastModificationDate")
    def last_modification_date(self) -> _builtins.str:
        """
        The date and time (UTC) of the last modification of the EIM user.
        """
        return pulumi.get(self, "last_modification_date")

    @last_modification_date.setter
    def last_modification_date(self, value: _builtins.str):
        pulumi.set(self, "last_modification_date", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the group. If not specified, it is set to a slash (`/`).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> _builtins.str:
        """
        The email address of the EIM user.
        """
        return pulumi.get(self, "user_email")

    @user_email.setter
    def user_email(self, value: _builtins.str):
        pulumi.set(self, "user_email", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        The ID of the EIM user.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: _builtins.str):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The name of the EIM user.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: _builtins.str):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class GetUserGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the user group.
        """
        values: Sequence[_builtins.str]
elif False:
    GetUserGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the user group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetUsersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetUsersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVirtualGatewayFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVirtualGatewayFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVirtualGatewayFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVirtualGatewaysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVirtualGatewaysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVirtualGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVmFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVmFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVmStateFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVmStateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmStateFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVmStatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVmStatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmStatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVmTypesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVmTypesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmTypesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVmsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVmsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVolumeFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVolumeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVolumesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVolumesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVpnConnectionFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVpnConnectionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVpnConnectionFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetVpnConnectionsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetVpnConnectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVpnConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


